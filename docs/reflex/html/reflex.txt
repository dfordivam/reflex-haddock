-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Higher-order Functional Reactive Programming
--   
--   Reflex is a high-performance, deterministic, higher-order Functional
--   Reactive Programming system
@url http://dfordivam.github.io/reflex-haddock/docs/reflex/html/
@package reflex
@version 0.5


-- | The interface for types which represent changes made to other types
module Reflex.Patch.Class

-- | A <a>Patch</a> type represents a kind of change made to a
--   datastructure.
class Patch p where type PatchTarget p :: * where {
    type family PatchTarget p :: *;
}

-- | Apply the patch <tt>p a</tt> to the value <tt>a</tt>. If no change is
--   needed, return <a>Nothing</a>.
apply :: Patch p => p -> PatchTarget p -> Maybe (PatchTarget p)

-- | Apply a <a>Patch</a>; if it does nothing, return the original value
applyAlways :: Patch p => p -> PatchTarget p -> PatchTarget p

-- | <a>Identity</a> can be used as a <a>Patch</a> that always fully
--   replaces the value
instance Reflex.Patch.Class.Patch (Data.Functor.Identity.Identity a)

module Reflex.Patch.IntMap
newtype PatchIntMap a
PatchIntMap :: (IntMap (Maybe a)) -> PatchIntMap a

-- | <tt>a &lt;&gt; b</tt> will apply the changes of <tt>b</tt> and then
--   apply the changes of <tt>a</tt>. If the same key is modified by both
--   patches, the one on the left will take precedence.
traverseIntMapPatchWithKey :: Applicative t => (Int -> a -> t b) -> PatchIntMap a -> t (PatchIntMap b)
patchIntMapNewElements :: PatchIntMap a -> [a]
patchIntMapNewElementsMap :: PatchIntMap a -> IntMap a
getDeletions :: PatchIntMap v -> IntMap v' -> IntMap v'
instance GHC.Base.Monoid (Reflex.Patch.IntMap.PatchIntMap a)
instance Data.Traversable.Traversable Reflex.Patch.IntMap.PatchIntMap
instance Data.Foldable.Foldable Reflex.Patch.IntMap.PatchIntMap
instance GHC.Base.Functor Reflex.Patch.IntMap.PatchIntMap
instance Reflex.Patch.Class.Patch (Reflex.Patch.IntMap.PatchIntMap a)
instance Data.Semigroup.Semigroup (Reflex.Patch.IntMap.PatchIntMap v)


-- | <a>Patch</a>es on <a>Map</a> that consist only of insertions
--   (including overwrites) and deletions
module Reflex.Patch.Map

-- | A set of changes to a <a>Map</a>. Any element may be inserted/updated
--   or deleted. Insertions are represented as values wrapped in
--   <a>Just</a>, while deletions are represented as <a>Nothing</a>s
newtype PatchMap k v
PatchMap :: Map k (Maybe v) -> PatchMap k v
[unPatchMap] :: PatchMap k v -> Map k (Maybe v)

-- | Applying a <a>PatchMap</a> will update the <a>Map</a> by performing
--   the insertions and deletions specified

-- | <tt>a &lt;&gt; b</tt> will apply the changes of <tt>b</tt> and then
--   apply the changes of <tt>a</tt>. If the same key is modified by both
--   patches, the one on the left will take precedence.

-- | The empty <a>PatchMap</a> contains no insertions or deletions

-- | <a>fmap</a>ping a <a>PatchMap</a> will alter all of the values it will
--   insert. Deletions are unaffected.

-- | Returns all the new elements that will be added to the <a>Map</a>
patchMapNewElements :: PatchMap k v -> [v]

-- | Returns all the new elements that will be added to the <a>Map</a>
patchMapNewElementsMap :: PatchMap k v -> Map k v
instance (GHC.Classes.Ord v, GHC.Classes.Ord k) => GHC.Classes.Ord (Reflex.Patch.Map.PatchMap k v)
instance (GHC.Classes.Eq v, GHC.Classes.Eq k) => GHC.Classes.Eq (Reflex.Patch.Map.PatchMap k v)
instance (GHC.Read.Read v, GHC.Read.Read k, GHC.Classes.Ord k) => GHC.Read.Read (Reflex.Patch.Map.PatchMap k v)
instance (GHC.Show.Show v, GHC.Show.Show k) => GHC.Show.Show (Reflex.Patch.Map.PatchMap k v)
instance GHC.Classes.Ord k => Reflex.Patch.Class.Patch (Reflex.Patch.Map.PatchMap k v)
instance GHC.Classes.Ord k => Data.Semigroup.Semigroup (Reflex.Patch.Map.PatchMap k v)
instance GHC.Classes.Ord k => GHC.Base.Monoid (Reflex.Patch.Map.PatchMap k v)
instance GHC.Base.Functor (Reflex.Patch.Map.PatchMap k)


-- | <a>Patch</a>es on <a>Map</a> that can insert, delete, and move values
--   from one key to another
module Reflex.Patch.MapWithMove

-- | Patch a DMap with additions, deletions, and moves. Invariant: If key
--   <tt>k1</tt> is coming from <tt>From_Move k2</tt>, then key <tt>k2</tt>
--   should be going to <tt>Just k1</tt>, and vice versa. There should
--   never be any unpaired From/To keys.
newtype PatchMapWithMove k v
PatchMapWithMove :: (Map k (NodeInfo k v)) -> PatchMapWithMove k v

-- | Holds the information about each key: where its new value should come
--   from, and where its old value should go to
data NodeInfo k v
NodeInfo :: !(From k v) -> !(To k) -> NodeInfo k v

-- | Where do we get the new value for this key?
[_nodeInfo_from] :: NodeInfo k v -> !(From k v)

-- | If the old value is being kept (i.e. moved rather than deleted or
--   replaced), where is it going?
[_nodeInfo_to] :: NodeInfo k v -> !(To k)

-- | Create a <a>PatchMapWithMove</a>, validating it
patchMapWithMove :: Ord k => Map k (NodeInfo k v) -> Maybe (PatchMapWithMove k v)

-- | Extract the internal representation of the <a>PatchMapWithMove</a>
unPatchMapWithMove :: PatchMapWithMove k v -> Map k (NodeInfo k v)

-- | Warning: when using this function, you must ensure that the invariants
--   of <a>PatchMapWithMove</a> are preserved; they will not be checked.
unsafePatchMapWithMove :: Map k (NodeInfo k v) -> PatchMapWithMove k v

-- | Describe how a key's new value should be produced
data From k v

-- | Insert the given value here
From_Insert :: v -> From k v

-- | Delete the existing value, if any, from here
From_Delete :: From k v

-- | Move the value here from the given key
From_Move :: !k -> From k v

-- | Describe where a key's old value will go. If this is <a>Just</a>, that
--   means the key's old value will be moved to the given other key; if it
--   is <a>Nothing</a>, that means it will be deleted.
type To = Maybe

-- | Apply the insertions, deletions, and moves to a given <a>Map</a>

-- | Returns all the new elements that will be added to the <a>Map</a>
patchMapWithMoveNewElements :: PatchMapWithMove k v -> [v]
patchMapWithMoveNewElementsMap :: PatchMapWithMove k v -> Map k v

-- | Create a <a>PatchMapWithMove</a> that, if applied to the given
--   <a>Map</a>, will sort its values using the given ordering function.
--   The set keys of the <a>Map</a> is not changed.
patchThatSortsMapWith :: Ord k => (v -> v -> Ordering) -> Map k v -> PatchMapWithMove k v

-- | Create a <a>PatchMapWithMove</a> that, if applied to the first
--   <a>Map</a> provided, will produce a <a>Map</a> with the same values as
--   the second <a>Map</a> but with the values sorted with the given
--   ordering function.
patchThatChangesAndSortsMapWith :: forall k v. (Ord k, Ord v) => (v -> v -> Ordering) -> Map k v -> Map k v -> PatchMapWithMove k v

-- | Change the <a>From</a> value of a <a>NodeInfo</a>
nodeInfoMapFrom :: (From k v -> From k v) -> NodeInfo k v -> NodeInfo k v

-- | Change the <a>From</a> value of a <a>NodeInfo</a>, using a
--   <a>Functor</a> (or <a>Applicative</a>, <a>Monad</a>, etc.) action to
--   get the new value
nodeInfoMapMFrom :: Functor f => (From k v -> f (From k v)) -> NodeInfo k v -> f (NodeInfo k v)

-- | Set the <a>To</a> field of a <a>NodeInfo</a>
nodeInfoSetTo :: To k -> NodeInfo k v -> NodeInfo k v
instance Data.Traversable.Traversable (Reflex.Patch.MapWithMove.PatchMapWithMove k)
instance Data.Foldable.Foldable (Reflex.Patch.MapWithMove.PatchMapWithMove k)
instance GHC.Base.Functor (Reflex.Patch.MapWithMove.PatchMapWithMove k)
instance (GHC.Classes.Ord v, GHC.Classes.Ord k) => GHC.Classes.Ord (Reflex.Patch.MapWithMove.PatchMapWithMove k v)
instance (GHC.Classes.Eq v, GHC.Classes.Eq k) => GHC.Classes.Eq (Reflex.Patch.MapWithMove.PatchMapWithMove k v)
instance (GHC.Show.Show v, GHC.Show.Show k) => GHC.Show.Show (Reflex.Patch.MapWithMove.PatchMapWithMove k v)
instance Data.Traversable.Traversable (Reflex.Patch.MapWithMove.NodeInfo k)
instance Data.Foldable.Foldable (Reflex.Patch.MapWithMove.NodeInfo k)
instance GHC.Base.Functor (Reflex.Patch.MapWithMove.NodeInfo k)
instance (GHC.Classes.Ord v, GHC.Classes.Ord k) => GHC.Classes.Ord (Reflex.Patch.MapWithMove.NodeInfo k v)
instance (GHC.Classes.Eq v, GHC.Classes.Eq k) => GHC.Classes.Eq (Reflex.Patch.MapWithMove.NodeInfo k v)
instance (GHC.Read.Read v, GHC.Read.Read k) => GHC.Read.Read (Reflex.Patch.MapWithMove.NodeInfo k v)
instance (GHC.Show.Show v, GHC.Show.Show k) => GHC.Show.Show (Reflex.Patch.MapWithMove.NodeInfo k v)
instance Data.Traversable.Traversable (Reflex.Patch.MapWithMove.From k)
instance Data.Foldable.Foldable (Reflex.Patch.MapWithMove.From k)
instance GHC.Base.Functor (Reflex.Patch.MapWithMove.From k)
instance (GHC.Classes.Ord k, GHC.Classes.Ord v) => GHC.Classes.Ord (Reflex.Patch.MapWithMove.From k v)
instance (GHC.Classes.Eq k, GHC.Classes.Eq v) => GHC.Classes.Eq (Reflex.Patch.MapWithMove.From k v)
instance (GHC.Read.Read k, GHC.Read.Read v) => GHC.Read.Read (Reflex.Patch.MapWithMove.From k v)
instance (GHC.Show.Show k, GHC.Show.Show v) => GHC.Show.Show (Reflex.Patch.MapWithMove.From k v)
instance GHC.Classes.Ord k => Reflex.Patch.Class.Patch (Reflex.Patch.MapWithMove.PatchMapWithMove k v)


-- | This module defines the FunctorMaybe class, which extends Functors
--   with the ability to delete values.
module Reflex.FunctorMaybe

-- | A class for values that combines filtering and mapping using
--   <a>Maybe</a>. Morally, <tt><a>FunctorMaybe</a> ~ KleisliFunctor
--   <a>Maybe</a></tt>. Also similar is the <tt>Witherable</tt> typeclass,
--   but it requires <tt>Foldable f</tt> and <tt>Traverable f</tt>, and
--   e.g. <tt>Event</tt> is instance of neither.
--   
--   A definition of <a>fmapMaybe</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i><i>identity</i></i> <tt><a>fmapMaybe</a> <a>Just</a> ≡
--   <a>id</a></tt></li>
--   <li><i><i>composition</i></i> <tt><a>fmapMaybe</a> (f &lt;=&lt; g) ≡
--   <a>fmapMaybe</a> f . <a>fmapMaybe</a> g</tt></li>
--   </ul>
class FunctorMaybe f

-- | Combined mapping and filtering function.
fmapMaybe :: FunctorMaybe f => (a -> Maybe b) -> f a -> f b
instance Reflex.FunctorMaybe.FunctorMaybe GHC.Base.Maybe
instance Reflex.FunctorMaybe.FunctorMaybe []

module Reflex.FastWeak
data FastWeakTicket a
type FastWeak a = Weak a
mkFastWeakTicket :: a -> IO (FastWeakTicket a)
getFastWeakTicketValue :: FastWeakTicket a -> IO a
getFastWeakTicketWeak :: FastWeakTicket a -> IO (FastWeak a)
getFastWeakValue :: FastWeak a -> IO (Maybe a)
getFastWeakTicket :: forall a. FastWeak a -> IO (Maybe (FastWeakTicket a))

-- | A weak reference that is always empty
emptyFastWeak :: FastWeak a


-- | This module defines the <a>WeakBag</a> type, which represents a
--   mutable collection of items that does not cause the items to be
--   retained in memory. This is useful for situations where a value needs
--   to be inspected or modified if it is still alive, but can be ignored
--   if it is dead.
module Data.WeakBag

-- | A <tt>WeakBag a</tt> holds a set of values of type <tt>a</tt>, but
--   does not retain them - that is, they can still be garbage-collected.
--   As long as the <tt>a</tt>s remain alive, the <a>WeakBag</a> will
--   continue to refer to them.
data WeakBag a

-- | When inserting an item into a <a>WeakBag</a>, a <a>WeakBagTicket</a>
--   is returned. If the caller retains the ticket, the item is guranteed
--   to stay in memory (and thus in the <a>WeakBag</a>). The ticket can
--   also be used to remove the item from the <a>WeakBag</a> prematurely
--   (i.e. while it is still alive), using <a>remove</a>.
data WeakBagTicket

-- | Create an empty <a>WeakBag</a>.
empty :: IO (WeakBag a)

-- | Create a <a>WeakBag</a> with one item; equivalent to creating the
--   <a>WeakBag</a> with <a>empty</a>, then using <a>insert</a>.
singleton :: a -> IORef (Weak b) -> (b -> IO ()) -> IO (WeakBag a, WeakBagTicket)

-- | Insert an item into a <a>WeakBag</a>.
insert :: a -> WeakBag a -> IORef (Weak b) -> (b -> IO ()) -> IO WeakBagTicket

-- | Visit every node in the given list. If new nodes are appended during
--   the traversal, they will not be visited. Every live node that was in
--   the list when the traversal began will be visited exactly once;
--   however, no guarantee is made about the order of the traversal.
traverse :: MonadIO m => WeakBag a -> (a -> m ()) -> m ()

-- | Remove an item from the <a>WeakBag</a>; does nothing if invoked
--   multiple times on the same <a>WeakBagTicket</a>.
remove :: WeakBagTicket -> IO ()

-- | The items referenced by the WeakBag
_weakBag_children :: WeakBag a -> (IORef (IntMap (Weak a)))

module Data.Map.Misc
diffMapNoEq :: (Ord k) => Map k v -> Map k v -> Map k (Maybe v)
diffMap :: (Ord k, Eq v) => Map k v -> Map k v -> Map k (Maybe v)
applyMap :: Ord k => Map k (Maybe v) -> Map k v -> Map k v
mapPartitionEithers :: Map k (Either a b) -> (Map k a, Map k b)

-- | Apply a map patch to a set &gt; applyMapKeysSet patch (Map.keysSet m)
--   == Map.keysSet (applyMap patch m)
applyMapKeysSet :: Ord k => Map k (Maybe v) -> Set k -> Set k


-- | This module provides types and functions with no particular theme, but
--   which are relevant to the use of <a>Functor</a>-based datastructures
--   like <a>DMap</a>.
module Data.Functor.Misc

-- | <a>Const2</a> stores a value of a given type <tt>k</tt> and ensures
--   that a particular type <tt>v</tt> is always given for the last type
--   parameter
data Const2 :: * -> x -> x -> *
[Const2] :: k -> Const2 k v v

-- | Extract the value from a Const2
unConst2 :: Const2 k v v' -> k

-- | Convert a <a>DMap</a> to a regular <a>Map</a>
dmapToMap :: DMap (Const2 k v) Identity -> Map k v

-- | Convert a <a>DMap</a> to an <a>IntMap</a>
dmapToIntMap :: DMap (Const2 Key v) Identity -> IntMap v

-- | Convert a <a>DMap</a> to a regular <a>Map</a>, applying the given
--   function to remove the wrapping <a>Functor</a>
dmapToMapWith :: (f v -> v') -> DMap (Const2 k v) f -> Map k v'

-- | Convert a regular <a>Map</a> to a <a>DMap</a>
mapToDMap :: Map k v -> DMap (Const2 k v) Identity

-- | Convert a <a>DMap</a> to a regular <a>Map</a> by forgetting the types
--   associated with the keys, using a function to remove the wrapping
--   <a>Functor</a>
weakenDMapWith :: (forall a. v a -> v') -> DMap k v -> Map (Some k) v'

-- | <a>WrapArg</a> can be used to tag a value in one functor with a type
--   representing another functor. This was primarily used with
--   dependent-map &lt; 0.2, in which the value type was not wrapped in a
--   separate functor.
data WrapArg :: (k -> *) -> (k -> *) -> * -> *
[WrapArg] :: f a -> WrapArg g f (g a)

-- | Convert a regular <a>Map</a>, where the values are already wrapped in
--   a functor, to a <a>DMap</a>
mapWithFunctorToDMap :: Map k (f v) -> DMap (Const2 k v) f

-- | Convert a regular <a>IntMap</a>, where the values are already wrapped
--   in a functor, to a <a>DMap</a>
intMapWithFunctorToDMap :: IntMap (f v) -> DMap (Const2 Key v) f

-- | Map over all key/value pairs in a <a>DMap</a>, potentially altering
--   the key as well as the value. The provided function MUST preserve the
--   ordering of the keys, or the resulting <a>DMap</a> will be malformed.
mapKeyValuePairsMonotonic :: (DSum k v -> DSum k' v') -> DMap k v -> DMap k' v'

-- | Union two <a>DMap</a>s of different types, yielding another type. Each
--   key that is present in either input map will be present in the output.
combineDMapsWithKey :: forall f g h i. GCompare f => (forall a. f a -> These (g a) (h a) -> i a) -> DMap f g -> DMap f h -> DMap f i

-- | Tag type for <a>Either</a> to use it as a <a>DSum</a>.
data EitherTag l r a
[LeftTag] :: EitherTag l r l
[RightTag] :: EitherTag l r r

-- | Extract the values of a <a>DMap</a> of <a>EitherTag</a>s.
dmapToThese :: DMap (EitherTag a b) Identity -> Maybe (These a b)

-- | Convert <a>Either</a> to a <a>DSum</a>. Inverse of
--   <a>dsumToEither</a>.
eitherToDSum :: Either a b -> DSum (EitherTag a b) Identity

-- | Convert <a>DSum</a> to <a>Either</a>. Inverse of <a>eitherToDSum</a>.
dsumToEither :: DSum (EitherTag a b) Identity -> Either a b

-- | Run the actions contained in the <a>DMap</a>

-- | <i>Deprecated: Use 'Data.Dependent.Map.traverseWithKey (_ -&gt; fmap
--   Identity)' instead</i>
sequenceDmap :: Applicative t => DMap f t -> t (DMap f Identity)

-- | Replace the <a>Identity</a> functor for a <tt>DMap'</tt>s values with
--   a different functor

-- | <i>Deprecated: Use 'Data.Dependent.Map.map (f . runIdentity)'
--   instead</i>
wrapDMap :: (forall a. a -> f a) -> DMap k Identity -> DMap k f

-- | Replace one functor for a <tt>DMap'</tt>s values with a different
--   functor

-- | <i>Deprecated: Use <a>map</a> instead</i>
rewrapDMap :: (forall (a :: *). f a -> g a) -> DMap k f -> DMap k g

-- | Replace one functor for a <tt>DMap'</tt>s values with the
--   <a>Identity</a> functor

-- | <i>Deprecated: Use 'Data.Dependent.Map.map (Identity . f)' instead</i>
unwrapDMap :: (forall a. f a -> a) -> DMap k f -> DMap k Identity

-- | Like <a>unwrapDMap</a>, but possibly delete some values from the DMap

-- | <i>Deprecated: Use 'Data.Dependent.Map.mapMaybeWithKey (_ a -&gt; fmap
--   Identity $ f a)' instead</i>
unwrapDMapMaybe :: GCompare k => (forall a. f a -> Maybe a) -> DMap k f -> DMap k Identity

-- | Eliminate the <a>Identity</a> functor in a <a>DMap</a> and replace it
--   with the underlying functor

-- | <i>Deprecated: Use 'mapKeyValuePairsMonotonic ((Const2 k :=&gt;
--   Identity v) -&gt; Const2 k :=&gt; v)' instead</i>
extractFunctorDMap :: DMap (Const2 k (f v)) Identity -> DMap (Const2 k v) f

-- | We can't use <tt>Compose Maybe</tt> instead of <a>ComposeMaybe</a>,
--   because that would make the <tt>f</tt> parameter have a nominal type
--   role. We need f to be representational so that we can use safe
--   <tt>coerce</tt>.
newtype ComposeMaybe (f :: * -> *) (a :: *)
ComposeMaybe :: Maybe (f a) -> ComposeMaybe
[getComposeMaybe] :: ComposeMaybe -> Maybe (f a)
instance GHC.Classes.Ord (f a) => GHC.Classes.Ord (Data.Functor.Misc.ComposeMaybe f a)
instance GHC.Classes.Eq (f a) => GHC.Classes.Eq (Data.Functor.Misc.ComposeMaybe f a)
instance GHC.Show.Show (f a) => GHC.Show.Show (Data.Functor.Misc.ComposeMaybe f a)
instance forall x k (v :: x) (v' :: x). GHC.Classes.Eq k => GHC.Classes.Eq (Data.Functor.Misc.Const2 k v v')
instance forall x k (v :: x) (v' :: x). GHC.Classes.Ord k => GHC.Classes.Ord (Data.Functor.Misc.Const2 k v v')
instance forall x k (v :: x) (v' :: x). GHC.Show.Show k => GHC.Show.Show (Data.Functor.Misc.Const2 k v v')
instance forall x k (v :: x). GHC.Read.Read k => GHC.Read.Read (Data.Functor.Misc.Const2 k v v)
instance forall k (f :: k -> *) (a :: k) (g :: k -> GHC.Types.*) (g' :: k -> GHC.Types.*). GHC.Classes.Eq (f a) => GHC.Classes.Eq (Data.Functor.Misc.WrapArg g f (g' a))
instance forall k (f :: k -> *) (a :: k) (g :: k -> GHC.Types.*) (g' :: k -> GHC.Types.*). GHC.Classes.Ord (f a) => GHC.Classes.Ord (Data.Functor.Misc.WrapArg g f (g' a))
instance forall k (f :: k -> *) (a :: k) (g :: k -> GHC.Types.*) (g' :: k -> GHC.Types.*). GHC.Show.Show (f a) => GHC.Show.Show (Data.Functor.Misc.WrapArg g f (g' a))
instance forall k (f :: k -> *) (a :: k) (g :: k -> GHC.Types.*). GHC.Read.Read (f a) => GHC.Read.Read (Data.Functor.Misc.WrapArg g f (g a))
instance forall k (l :: k) (r :: k) (a :: k). GHC.Show.Show (Data.Functor.Misc.EitherTag l r a)
instance forall k (l :: k) (r :: k) (a :: k). GHC.Classes.Eq (Data.Functor.Misc.EitherTag l r a)
instance forall k (l :: k) (r :: k) (a :: k). GHC.Classes.Ord (Data.Functor.Misc.EitherTag l r a)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Functor.Misc.ComposeMaybe f)
instance forall k k1 (v :: k). GHC.Show.Show k1 => Data.GADT.Show.GShow (Data.Functor.Misc.Const2 k1 v)
instance forall k k1 (f :: k -> *) (v :: k). (GHC.Show.Show k1, GHC.Show.Show (f v)) => Data.Dependent.Sum.ShowTag (Data.Functor.Misc.Const2 k1 v) f
instance forall k k1 (v :: k). GHC.Classes.Eq k1 => Data.GADT.Compare.GEq (Data.Functor.Misc.Const2 k1 v)
instance forall k k1 (v :: k). GHC.Classes.Ord k1 => Data.GADT.Compare.GCompare (Data.Functor.Misc.Const2 k1 v)
instance forall k (f :: k -> *) (g :: k -> GHC.Types.*). Data.GADT.Compare.GEq f => Data.GADT.Compare.GEq (Data.Functor.Misc.WrapArg g f)
instance forall k (f :: k -> *) (g :: k -> GHC.Types.*). Data.GADT.Compare.GCompare f => Data.GADT.Compare.GCompare (Data.Functor.Misc.WrapArg g f)
instance forall k (l :: k) (r :: k). Data.GADT.Compare.GEq (Data.Functor.Misc.EitherTag l r)
instance forall k (l :: k) (r :: k). Data.GADT.Compare.GCompare (Data.Functor.Misc.EitherTag l r)
instance forall k (l :: k) (r :: k). Data.GADT.Show.GShow (Data.Functor.Misc.EitherTag l r)
instance (GHC.Show.Show l, GHC.Show.Show r) => Data.Dependent.Sum.ShowTag (Data.Functor.Misc.EitherTag l r) Data.Functor.Identity.Identity

module Reflex.Patch.DMap

-- | A set of changes to a <a>DMap</a>. Any element may be inserted/updated
--   or deleted.
newtype PatchDMap k v
PatchDMap :: DMap k (ComposeMaybe v) -> PatchDMap k v
[unPatchDMap] :: PatchDMap k v -> DMap k (ComposeMaybe v)
mapPatchDMap :: (forall a. v a -> v' a) -> PatchDMap k v -> PatchDMap k v'
traversePatchDMap :: Applicative m => (forall a. v a -> m (v' a)) -> PatchDMap k v -> m (PatchDMap k v')
traversePatchDMapWithKey :: Applicative m => (forall a. k a -> v a -> m (v' a)) -> PatchDMap k v -> m (PatchDMap k v')
weakenPatchDMapWith :: (forall a. v a -> v') -> PatchDMap k v -> PatchMap (Some k) v'
patchDMapToPatchMapWith :: (f v -> v') -> PatchDMap (Const2 k v) f -> PatchMap k v'
const2PatchDMapWith :: forall k v f a. (v -> f a) -> PatchMap k v -> PatchDMap (Const2 k a) f
const2IntPatchDMapWith :: forall v f a. (v -> f a) -> PatchIntMap v -> PatchDMap (Const2 Key a) f

-- | Get the values that will be deleted if the given patch is applied to
--   the given <a>DMap</a>. Includes values that will be replaced.
getDeletions :: GCompare k => PatchDMap k v -> DMap k v' -> DMap k v'
instance Data.GADT.Compare.GCompare k => Data.Semigroup.Semigroup (Reflex.Patch.DMap.PatchDMap k v)
instance Data.GADT.Compare.GCompare k => GHC.Base.Monoid (Reflex.Patch.DMap.PatchDMap k v)
instance Data.GADT.Compare.GCompare k => Reflex.Patch.Class.Patch (Reflex.Patch.DMap.PatchDMap k v)

module Reflex.Patch.DMapWithMove

-- | Like <a>PatchMapWithMove</a>, but for <a>DMap</a>.
newtype PatchDMapWithMove k v
PatchDMapWithMove :: (DMap k (NodeInfo k v)) -> PatchDMapWithMove k v
data NodeInfo k v a
NodeInfo :: !(From k v a) -> !(To k a) -> NodeInfo k v a
[_nodeInfo_from] :: NodeInfo k v a -> !(From k v a)
[_nodeInfo_to] :: NodeInfo k v a -> !(To k a)
data From (k :: a -> *) (v :: a -> *) :: a -> *
[From_Insert] :: v a -> From k v a
[From_Delete] :: From k v a
[From_Move] :: !(k a) -> From k v a
type To = ComposeMaybe
validPatchDMapWithMove :: forall k v. (GCompare k, EqTag k (ComposeMaybe k)) => PatchDMapWithMove k v -> Bool
data Pair1 f g a
Pair1 :: (f a) -> (g a) -> Pair1 f g a
data Fixup k v a
Fixup_Delete :: Fixup k v a
Fixup_Update :: (These (From k v a) (To k a)) -> Fixup k v a
getHere :: These a b -> Maybe a
getThere :: These a b -> Maybe b
moveDMapKey :: GCompare k => k a -> k a -> PatchDMapWithMove k v
deleteDMapKey :: k a -> PatchDMapWithMove k v
unPatchDMapWithMove :: PatchDMapWithMove k v -> DMap k (NodeInfo k v)

-- | Warning: when using this function, you must ensure that the invariants
--   of <a>PatchDMapWithMove</a> are preserved; they will not be checked.
unsafePatchDMapWithMove :: DMap k (NodeInfo k v) -> PatchDMapWithMove k v
mapPatchDMapWithMove :: forall k v v'. (forall a. v a -> v' a) -> PatchDMapWithMove k v -> PatchDMapWithMove k v'
traversePatchDMapWithMove :: forall m k v v'. Applicative m => (forall a. v a -> m (v' a)) -> PatchDMapWithMove k v -> m (PatchDMapWithMove k v')
traversePatchDMapWithMoveWithKey :: forall m k v v'. Applicative m => (forall a. k a -> v a -> m (v' a)) -> PatchDMapWithMove k v -> m (PatchDMapWithMove k v')
nodeInfoMapFrom :: (From k v a -> From k v' a) -> NodeInfo k v a -> NodeInfo k v' a
nodeInfoMapFromM :: Functor f => (From k v a -> f (From k v' a)) -> NodeInfo k v a -> f (NodeInfo k v' a)
weakenPatchDMapWithMoveWith :: forall k v v'. (forall a. v a -> v') -> PatchDMapWithMove k v -> PatchMapWithMove (Some k) v'
patchDMapWithMoveToPatchMapWithMoveWith :: forall k f v v'. (f v -> v') -> PatchDMapWithMove (Const2 k v) f -> PatchMapWithMove k v'
const2PatchDMapWithMoveWith :: forall k v f a. (v -> f a) -> PatchMapWithMove k v -> PatchDMapWithMove (Const2 k a) f

-- | Get the values that will be deleted or moved if the given patch is
--   applied to the given <a>DMap</a>.
getDeletionsAndMoves :: GCompare k => PatchDMapWithMove k v -> DMap k v' -> DMap k (Product v' (ComposeMaybe k))
instance (GHC.Show.Show (v a), GHC.Show.Show (k a)) => GHC.Show.Show (Reflex.Patch.DMapWithMove.NodeInfo k v a)
instance forall a (k :: a -> GHC.Types.*) (v :: a -> GHC.Types.*) (b :: a). (GHC.Classes.Ord (k b), GHC.Classes.Ord (v b)) => GHC.Classes.Ord (Reflex.Patch.DMapWithMove.From k v b)
instance forall a (k :: a -> GHC.Types.*) (v :: a -> GHC.Types.*) (b :: a). (GHC.Classes.Eq (k b), GHC.Classes.Eq (v b)) => GHC.Classes.Eq (Reflex.Patch.DMapWithMove.From k v b)
instance forall a (k :: a -> GHC.Types.*) (v :: a -> GHC.Types.*) (b :: a). (GHC.Read.Read (k b), GHC.Read.Read (v b)) => GHC.Read.Read (Reflex.Patch.DMapWithMove.From k v b)
instance forall a (k :: a -> GHC.Types.*) (v :: a -> GHC.Types.*) (b :: a). (GHC.Show.Show (k b), GHC.Show.Show (v b)) => GHC.Show.Show (Reflex.Patch.DMapWithMove.From k v b)
instance Data.Dependent.Sum.EqTag k (Reflex.Patch.DMapWithMove.NodeInfo k v) => GHC.Classes.Eq (Reflex.Patch.DMapWithMove.PatchDMapWithMove k v)
instance Data.GADT.Compare.GCompare k => Data.Semigroup.Semigroup (Reflex.Patch.DMapWithMove.PatchDMapWithMove k v)
instance Data.GADT.Compare.GCompare k => GHC.Base.Monoid (Reflex.Patch.DMapWithMove.PatchDMapWithMove k v)
instance Data.GADT.Compare.GCompare k => Reflex.Patch.Class.Patch (Reflex.Patch.DMapWithMove.PatchDMapWithMove k v)


-- | This module defines the <a>Patch</a> class, which is used by Reflex to
--   manage changes to <a>Incremental</a> values.
module Reflex.Patch

-- | A <a>Group</a> is a <a>Monoid</a> where every element has an inverse.
class (Semigroup q, Monoid q) => Group q where r ~~ s = r <> negateG s
negateG :: Group q => q -> q
(~~) :: Group q => q -> q -> q

-- | An <a>Additive</a> <a>Semigroup</a> is one where (&lt;&gt;) is
--   commutative
class Semigroup q => Additive q

-- | The elements of an <a>Additive</a> <a>Semigroup</a> can be considered
--   as patches of their own type.
newtype AdditivePatch p
AdditivePatch :: p -> AdditivePatch p
[unAdditivePatch] :: AdditivePatch p -> p
instance Reflex.Patch.Additive p => Reflex.Patch.Class.Patch (Reflex.Patch.AdditivePatch p)


-- | This module defines the <a>FastWeakBag</a> type, which represents a
--   mutable collection of items that does not cause the items to be
--   retained in memory. This is useful for situations where a value needs
--   to be inspected or modified if it is still alive, but can be ignored
--   if it is dead.
module Data.FastWeakBag

-- | A <tt>FastWeakBag a</tt> holds a set of values of type <tt>a</tt>, but
--   does not retain them - that is, they can still be garbage-collected.
--   As long as the <tt>a</tt>s remain alive, the <a>FastWeakBag</a> will
--   continue to refer to them.
data FastWeakBag a

-- | When inserting an item into a <a>FastWeakBag</a>, a
--   <a>FastWeakBagTicket</a> is returned. If the caller retains the
--   ticket, the item is guranteed to stay in memory (and thus in the
--   <a>FastWeakBag</a>). The ticket can also be used to remove the item
--   from the <a>FastWeakBag</a> prematurely (i.e. while it is still
--   alive), using <a>remove</a>.
data FastWeakBagTicket a

-- | Create an empty <a>FastWeakBag</a>.
empty :: IO (FastWeakBag a)

-- | Check whether a <a>FastWeakBag</a> is empty.
isEmpty :: FastWeakBag a -> IO Bool

-- | Insert an item into a <a>FastWeakBag</a>.
insert :: a -> FastWeakBag a -> IO (FastWeakBagTicket a)

-- | Visit every node in the given list. If new nodes are appended during
--   the traversal, they will not be visited. Every live node that was in
--   the list when the traversal began will be visited exactly once;
--   however, no guarantee is made about the order of the traversal.
traverse :: forall a m. MonadIO m => FastWeakBag a -> (a -> m ()) -> m ()

-- | Remove an item from the <a>FastWeakBag</a>; does nothing if invoked
--   multiple times on the same <a>FastWeakBagTicket</a>.
remove :: FastWeakBagTicket a -> IO ()
_weakBag_children :: FastWeakBag a -> (IORef (IntMap (Weak a)))

module Data.FastMutableIntMap
data FastMutableIntMap a
new :: IntMap a -> IO (FastMutableIntMap a)
newEmpty :: IO (FastMutableIntMap a)
insert :: FastMutableIntMap a -> Int -> a -> IO ()
isEmpty :: FastMutableIntMap a -> IO Bool

-- | Make an immutable snapshot of the datastructure and clear it
getFrozenAndClear :: FastMutableIntMap a -> IO (IntMap a)
size :: FastMutableIntMap a -> IO Int
applyPatch :: FastMutableIntMap a -> PatchIntMap a -> IO (IntMap a)
newtype PatchIntMap a
PatchIntMap :: (IntMap (Maybe a)) -> PatchIntMap a
traverseIntMapPatchWithKey :: Applicative t => (Int -> a -> t b) -> PatchIntMap a -> t (PatchIntMap b)
lookup :: FastMutableIntMap a -> Int -> IO (Maybe a)
forIntersectionWithImmutable_ :: MonadIO m => FastMutableIntMap a -> IntMap b -> (a -> b -> m ()) -> m ()
for_ :: MonadIO m => FastMutableIntMap a -> (a -> m ()) -> m ()
patchIntMapNewElements :: PatchIntMap a -> [a]
patchIntMapNewElementsMap :: PatchIntMap a -> IntMap a
getDeletions :: PatchIntMap v -> IntMap v' -> IntMap v'


-- | This module contains the Reflex interface, as well as a variety of
--   convenience functions for working with <a>Event</a>s,
--   <a>Behavior</a>s, and other signals.
module Reflex.Class

-- | The <a>Reflex</a> class contains all the primitive functionality
--   needed for Functional Reactive Programming (FRP). The <tt>t</tt> type
--   parameter indicates which "timeline" is in use. Timelines are
--   fully-independent FRP contexts, and the type of the timeline
--   determines the FRP engine to be used. For most purposes, the
--   <a>Spider</a> implementation is recommended.
class (MonadHold t (PushM t), MonadSample t (PullM t), MonadFix (PushM t), Functor (Dynamic t), Applicative (Dynamic t), Monad (Dynamic t)) => Reflex t where data Behavior t :: * -> * data Event t :: * -> * data Dynamic t :: * -> * data Incremental t :: * -> * type PushM t :: * -> * type PullM t :: * -> * where {
    data family Behavior t :: * -> *;
    data family Event t :: * -> *;
    data family Dynamic t :: * -> *;
    data family Incremental t :: * -> *;
    type family PushM t :: * -> *;
    type family PullM t :: * -> *;
}

-- | An <a>Event</a> with no occurrences
never :: Reflex t => Event t a

-- | Create a <a>Behavior</a> that always has the given value
constant :: Reflex t => a -> Behavior t a

-- | Create an <a>Event</a> from another <a>Event</a>; the provided
--   function can sample <a>Behavior</a>s and hold <a>Event</a>s, and use
--   the results to produce a occurring (Just) or non-occurring (Nothing)
--   result
push :: Reflex t => (a -> PushM t (Maybe b)) -> Event t a -> Event t b

-- | Like <a>push</a> but intended for functions that the implementation
--   can consider cheap to compute for performance considerations. WARNING:
--   The function passed to <a>pushCheap</a> may be run multiple times
--   without any caching.
pushCheap :: Reflex t => (a -> PushM t (Maybe b)) -> Event t a -> Event t b

-- | Create a <a>Behavior</a> by reading from other <a>Behavior</a>s; the
--   result will be recomputed whenever any of the read <a>Behavior</a>s
--   changes
pull :: Reflex t => PullM t a -> Behavior t a

-- | Merge a collection of events; the resulting <a>Event</a> will only
--   occur if at least one input event is occuring, and will contain all of
--   the input keys that are occurring simultaneously
merge :: (Reflex t, GCompare k) => DMap k (Event t) -> Event t (DMap k Identity)

-- | Efficiently fan-out an event to many destinations. This function
--   should be partially applied, and then the result applied repeatedly to
--   create child events
fan :: (Reflex t, GCompare k) => Event t (DMap k Identity) -> EventSelector t k

-- | Create an <a>Event</a> that will occur whenever the currently-selected
--   input <a>Event</a> occurs
switch :: Reflex t => Behavior t (Event t a) -> Event t a

-- | Create an <a>Event</a> that will occur whenever the input event is
--   occurring and its occurrence value, another <a>Event</a>, is also
--   occurring
coincidence :: Reflex t => Event t (Event t a) -> Event t a

-- | Extract the <a>Behavior</a> of a <a>Dynamic</a>.
current :: Reflex t => Dynamic t a -> Behavior t a

-- | Extract the <a>Event</a> of the <a>Dynamic</a>.
updated :: Reflex t => Dynamic t a -> Event t a

-- | Create a new <a>Dynamic</a>. The given <a>PullM</a> must always return
--   the most recent firing of the given <a>Event</a>, if any.
unsafeBuildDynamic :: Reflex t => PullM t a -> Event t a -> Dynamic t a

-- | Create a new <a>Incremental</a>. The given <tt>PullM'</tt>s value must
--   always change in the same way that the accumulated application of
--   patches would change that value.
unsafeBuildIncremental :: (Reflex t, Patch p) => PullM t (PatchTarget p) -> Event t p -> Incremental t p

-- | Create a merge whose parents can change over time
mergeIncremental :: (Reflex t, GCompare k) => Incremental t (PatchDMap k (Event t)) -> Event t (DMap k Identity)

-- | Experimental: Create a merge whose parents can change over time;
--   changing the key of an Event is more efficient than with
--   mergeIncremental
mergeIncrementalWithMove :: (Reflex t, GCompare k) => Incremental t (PatchDMapWithMove k (Event t)) -> Event t (DMap k Identity)

-- | Extract the <a>Behavior</a> component of an <a>Incremental</a>
currentIncremental :: (Reflex t, Patch p) => Incremental t p -> Behavior t (PatchTarget p)

-- | Extract the <a>Event</a> component of an <a>Incremental</a>
updatedIncremental :: (Reflex t, Patch p) => Incremental t p -> Event t p

-- | Convert an <a>Incremental</a> to a <a>Dynamic</a>
incrementalToDynamic :: (Reflex t, Patch p) => Incremental t p -> Dynamic t (PatchTarget p)

-- | Construct a <a>Coercion</a> for a <a>Behavior</a> given an
--   <a>Coercion</a> for its occurrence type
behaviorCoercion :: Reflex t => Coercion a b -> Coercion (Behavior t a) (Behavior t b)

-- | Construct a <a>Coercion</a> for an <a>Event</a> given an
--   <a>Coercion</a> for its occurrence type
eventCoercion :: Reflex t => Coercion a b -> Coercion (Event t a) (Event t b)

-- | Construct a <a>Coercion</a> for a <a>Dynamic</a> given an
--   <a>Coercion</a> for its occurrence type
dynamicCoercion :: Reflex t => Coercion a b -> Coercion (Dynamic t a) (Dynamic t b)
mergeIntIncremental :: Reflex t => Incremental t (PatchIntMap (Event t a)) -> Event t (IntMap a)
fanInt :: Reflex t => Event t (IntMap a) -> EventSelectorInt t a
mergeInt :: Reflex t => IntMap (Event t a) -> Event t (IntMap a)

-- | Coerce a <a>Behavior</a> between representationally-equivalent value
--   types
coerceBehavior :: (Reflex t, Coercible a b) => Behavior t a -> Behavior t b

-- | Coerce an <a>Event</a> between representationally-equivalent
--   occurrence types
coerceEvent :: (Reflex t, Coercible a b) => Event t a -> Event t b

-- | Coerce a <a>Dynamic</a> between representationally-equivalent value
--   types
coerceDynamic :: (Reflex t, Coercible a b) => Dynamic t a -> Dynamic t b

-- | <a>MonadSample</a> designates monads that can read the current value
--   of a <a>Behavior</a>. This includes both <a>PullM</a> and
--   <a>PushM</a>.
class (Applicative m, Monad m) => MonadSample t m | m -> t

-- | Get the current value in the <a>Behavior</a>
sample :: MonadSample t m => Behavior t a -> m a

-- | <a>MonadHold</a> designates monads that can create new
--   <a>Behavior</a>s based on <a>Event</a>s; usually this will be
--   <a>PushM</a> or a monad based on it. <a>MonadHold</a> is required to
--   create any stateful computations with Reflex.
class MonadSample t m => MonadHold t m where hold v0 = lift . hold v0 holdDyn v0 = lift . holdDyn v0 holdIncremental v0 = lift . holdIncremental v0

-- | Create a new <a>Behavior</a> whose value will initially be equal to
--   the given value and will be updated whenever the given <a>Event</a>
--   occurs. The update takes effect immediately after the <a>Event</a>
--   occurs; if the occurrence that sets the <a>Behavior</a> (or one that
--   is simultaneous with it) is used to sample the <a>Behavior</a>, it
--   will see the _old_ value of the <a>Behavior</a>, not the new one.
hold :: MonadHold t m => a -> Event t a -> m (Behavior t a)

-- | Create a new <a>Behavior</a> whose value will initially be equal to
--   the given value and will be updated whenever the given <a>Event</a>
--   occurs. The update takes effect immediately after the <a>Event</a>
--   occurs; if the occurrence that sets the <a>Behavior</a> (or one that
--   is simultaneous with it) is used to sample the <a>Behavior</a>, it
--   will see the _old_ value of the <a>Behavior</a>, not the new one.
hold :: (MonadHold t m, m ~ f m', MonadTrans f, MonadHold t m') => a -> Event t a -> m (Behavior t a)

-- | Create a <a>Dynamic</a> value using the given initial value that
--   changes every time the <a>Event</a> occurs.
holdDyn :: MonadHold t m => a -> Event t a -> m (Dynamic t a)

-- | Create a <a>Dynamic</a> value using the given initial value that
--   changes every time the <a>Event</a> occurs.
holdDyn :: (MonadHold t m, m ~ f m', MonadTrans f, MonadHold t m') => a -> Event t a -> m (Dynamic t a)

-- | Create an <a>Incremental</a> value using the given initial value that
--   changes every time the <a>Event</a> occurs.
holdIncremental :: (MonadHold t m, Patch p) => PatchTarget p -> Event t p -> m (Incremental t p)

-- | Create an <a>Incremental</a> value using the given initial value that
--   changes every time the <a>Event</a> occurs.
holdIncremental :: (MonadHold t m, Patch p, m ~ f m', MonadTrans f, MonadHold t m') => PatchTarget p -> Event t p -> m (Incremental t p)
buildDynamic :: MonadHold t m => PullM t a -> Event t a -> m (Dynamic t a)

-- | Create a new <a>Event</a> that only occurs only once, on the first
--   occurence of the supplied <a>Event</a>.
headE :: MonadHold t m => Event t a -> m (Event t a)

-- | An <a>EventSelector</a> allows you to efficiently <a>select</a> an
--   <a>Event</a> based on a key. This is much more efficient than
--   filtering for each key with <a>fmapMaybe</a>.
newtype EventSelector t k
EventSelector :: (forall a. k a -> Event t a) -> EventSelector t k

-- | Retrieve the <a>Event</a> for the given key. The type of the
--   <a>Event</a> is determined by the type of the key, so this can be used
--   to fan-out <a>Event</a>s whose sub-<a>Event</a>s have different types.
--   
--   Using <a>EventSelector</a>s and the <a>fan</a> primitive is far more
--   efficient than (but equivalent to) using <a>fmapMaybe</a> to select
--   only the relevant occurrences of an <a>Event</a>.
[select] :: EventSelector t k -> forall a. k a -> Event t a
newtype EventSelectorInt t a
EventSelectorInt :: (Int -> Event t a) -> EventSelectorInt t a
[selectInt] :: EventSelectorInt t a -> Int -> Event t a

-- | Construct a <a>Dynamic</a> value that never changes
constDyn :: Reflex t => a -> Dynamic t a

-- | Create an <a>Event</a> from another <a>Event</a>. The provided
--   function can sample <a>Behavior</a>s and hold <a>Event</a>s.
pushAlways :: Reflex t => (a -> PushM t b) -> Event t a -> Event t b

-- | Create a new <a>Event</a> that occurs if at least one of the
--   <a>Event</a>s in the list occurs. If multiple occur at the same time
--   the value is the value of the leftmost event.
leftmost :: Reflex t => [Event t a] -> Event t a

-- | Create a new <a>Event</a> combining the map of <a>Event</a>s into an
--   <a>Event</a> that occurs if at least one of them occurs and has a map
--   of values of all <a>Event</a>s occuring at that time.
mergeMap :: (Reflex t, Ord k) => Map k (Event t a) -> Event t (Map k a)

-- | Create a merge whose parents can change over time
mergeMapIncremental :: (Reflex t, Ord k) => Incremental t (PatchMap k (Event t a)) -> Event t (Map k a)

-- | Experimental: Create a merge whose parents can change over time;
--   changing the key of an Event is more efficient than with
--   mergeIncremental
mergeMapIncrementalWithMove :: (Reflex t, Ord k) => Incremental t (PatchMapWithMove k (Event t a)) -> Event t (Map k a)

-- | Create a merge whose parents can change over time
mergeIntMapIncremental :: Reflex t => Incremental t (PatchIntMap (Event t a)) -> Event t (IntMap a)

-- | Create a new <a>Event</a> that occurs if at least one of the
--   <a>Event</a>s in the list occurs and has a list of the values of all
--   <a>Event</a>s occuring at that time.
mergeList :: Reflex t => [Event t a] -> Event t (NonEmpty a)

-- | Create a new <a>Event</a> that occurs if at least one of the
--   <a>Event</a>s in the list occurs. If multiple occur at the same time
--   they are folded from the left with the given function.
mergeWith :: Reflex t => (a -> a -> a) -> [Event t a] -> Event t a

-- | Create a new <a>Event</a> that occurs when the first supplied
--   <a>Event</a> occurs unless the second supplied <a>Event</a> occurs
--   simultaneously.
difference :: Reflex t => Event t a -> Event t b -> Event t a
alignEventWithMaybe :: Reflex t => (These a b -> Maybe c) -> Event t a -> Event t b -> Event t c

-- | Split the supplied <a>Event</a> into two individual <a>Event</a>s
--   occuring at the same time with the respective values from the tuple.
splitE :: Reflex t => Event t (a, b) -> (Event t a, Event t b)

-- | Split the event into separate events for <a>Left</a> and <a>Right</a>
--   values.
fanEither :: Reflex t => Event t (Either a b) -> (Event t a, Event t b)

-- | Split the event into separate events for <a>This</a> and <a>That</a>
--   values, allowing them to fire simultaneously when the input value is
--   <a>These</a>.
fanThese :: Reflex t => Event t (These a b) -> (Event t a, Event t b)

-- | Split the event into an <a>EventSelector</a> that allows efficient
--   selection of the individual <a>Event</a>s.
fanMap :: (Reflex t, Ord k) => Event t (Map k a) -> EventSelector t (Const2 k a)

-- | Extract the values of a <a>DMap</a> of <a>EitherTag</a>s.
dmapToThese :: DMap (EitherTag a b) Identity -> Maybe (These a b)

-- | Tag type for <a>Either</a> to use it as a <a>DSum</a>.
data EitherTag l r a
[LeftTag] :: EitherTag l r l
[RightTag] :: EitherTag l r r

-- | Convert <a>Either</a> to a <a>DSum</a>. Inverse of
--   <a>dsumToEither</a>.
eitherToDSum :: Either a b -> DSum (EitherTag a b) Identity

-- | Convert <a>DSum</a> to <a>Either</a>. Inverse of <a>eitherToDSum</a>.
dsumToEither :: DSum (EitherTag a b) Identity -> Either a b

-- | Switches to the new event whenever it receives one. Only the old event
--   is considered the moment a new one is switched in; the output event
--   will fire at that moment if only if the old event does.
--   
--   Because the simultaneous firing case is irrelevant, this function
--   imposes laxer "timing requirements" on the overall circuit, avoiding
--   many potential cyclic dependency / metastability failures. It's also
--   more performant. Use this rather than <a>switchHoldPromptly</a> and
--   <a>switchHoldPromptOnly</a> unless you are absolutely sure you need to
--   act on the new event in the coincidental case.
switchHold :: (Reflex t, MonadHold t m) => Event t a -> Event t (Event t a) -> m (Event t a)

-- | Switches to the new event whenever it receives one. Whenever a new
--   event is provided, if it is firing, its value will be the resulting
--   event's value; if it is not firing, but the old one is, the old one's
--   value will be used.
--   
--   <a>switchHold</a>, by always forwarding the old event the moment it is
--   switched out, avoids many potential cyclic dependency problems /
--   metastability problems. It's also more performant. Use it instead
--   unless you are sure you cannot.
switchHoldPromptly :: (Reflex t, MonadHold t m) => Event t a -> Event t (Event t a) -> m (Event t a)

-- | switches to a new event whenever it receives one. At the moment of
--   switching, the old event will be ignored if it fires, and the new one
--   will be used if it fires; this is the opposite of <a>switch</a>, which
--   will use only the old value.
--   
--   <a>switchHold</a>, by always forwarding the old event the moment it is
--   switched out, avoids many potential cyclic dependency problems /
--   metastability problems. It's also more performant. Use it instead
--   unless you are sure you cannot.
switchHoldPromptOnly :: (Reflex t, MonadHold t m) => Event t a -> Event t (Event t a) -> m (Event t a)

-- | Replace each occurrence value of the <a>Event</a> with the value of
--   the <a>Behavior</a> at the time of that occurrence.
tag :: Reflex t => Behavior t b -> Event t a -> Event t b

-- | Create a new <a>Event</a> that combines occurences of supplied
--   <a>Event</a> with the current value of the <a>Behavior</a>.
attach :: Reflex t => Behavior t a -> Event t b -> Event t (a, b)

-- | Create a new <a>Event</a> that occurs when the supplied <a>Event</a>
--   occurs by combining it with the current value of the <a>Behavior</a>.
attachWith :: Reflex t => (a -> b -> c) -> Behavior t a -> Event t b -> Event t c

-- | Create a new <a>Event</a> by combining each occurence with the current
--   value of the <a>Behavior</a>. The occurrence is discarded if the
--   combining function returns Nothing
attachWithMaybe :: Reflex t => (a -> b -> Maybe c) -> Behavior t a -> Event t b -> Event t c

-- | Create a new <a>Event</a> that only occurs if the supplied
--   <a>Event</a> occurs and the <a>Behavior</a> is true at the time of
--   occurence.
gate :: Reflex t => Behavior t Bool -> Event t a -> Event t a

-- | This function converts a <a>DMap</a> whose elements are
--   <a>Dynamic</a>s into a <a>Dynamic</a> <a>DMap</a>. Its implementation
--   is more efficient than doing the same through the use of multiple uses
--   of <tt>zipWithDyn</tt> or <a>Applicative</a> operators.
distributeDMapOverDynPure :: forall t k. (Reflex t, GCompare k) => DMap k (Dynamic t) -> Dynamic t (DMap k Identity)

-- | Convert a list of <a>Dynamic</a>s into a <a>Dynamic</a> list.
distributeListOverDyn :: Reflex t => [Dynamic t a] -> Dynamic t [a]

-- | Create a new <a>Dynamic</a> by applying a combining function to a list
--   of <a>Dynamic</a>s
distributeListOverDynWith :: Reflex t => ([a] -> b) -> [Dynamic t a] -> Dynamic t b

-- | Combine two <a>Dynamic</a>s. The result will change whenever either
--   (or both) input <a>Dynamic</a> changes. Equivalent to <tt>zipDynWith
--   (,)</tt>.
zipDyn :: Reflex t => Dynamic t a -> Dynamic t b -> Dynamic t (a, b)

-- | Combine two <a>Dynamic</a>s with a combining function. The result will
--   change whenever either (or both) input <a>Dynamic</a> changes. More
--   efficient than liftA2.
zipDynWith :: Reflex t => (a -> b -> c) -> Dynamic t a -> Dynamic t b -> Dynamic t c

-- | An <a>Accumulator</a> type can be built by accumulating occurrences of
--   an <a>Event</a>.
class Reflex t => Accumulator t f | f -> t where accum f = accumMaybe $ \ v o -> Just $ f v o accumM f = accumMaybeM $ \ v o -> Just <$> f v o accumMaybe f = accumMaybeM $ \ v o -> return $ f v o mapAccum f = mapAccumMaybe $ \ v o -> bimap Just Just $ f v o mapAccumM f = mapAccumMaybeM $ \ v o -> bimap Just Just <$> f v o mapAccumMaybe f = mapAccumMaybeM $ \ v o -> return $ f v o

-- | <i>Warning: ghc &lt; 8.2.1 doesn't seem to be able to specialize
--   functions in this class, which can lead to poor performance</i>
accum :: (Accumulator t f, MonadHold t m, MonadFix m) => (a -> b -> a) -> a -> Event t b -> m (f a)

-- | <i>Warning: ghc &lt; 8.2.1 doesn't seem to be able to specialize
--   functions in this class, which can lead to poor performance</i>
accumM :: (Accumulator t f, MonadHold t m, MonadFix m) => (a -> b -> PushM t a) -> a -> Event t b -> m (f a)

-- | <i>Warning: ghc &lt; 8.2.1 doesn't seem to be able to specialize
--   functions in this class, which can lead to poor performance</i>
accumMaybe :: (Accumulator t f, MonadHold t m, MonadFix m) => (a -> b -> Maybe a) -> a -> Event t b -> m (f a)

-- | <i>Warning: ghc &lt; 8.2.1 doesn't seem to be able to specialize
--   functions in this class, which can lead to poor performance</i>
accumMaybeM :: (Accumulator t f, MonadHold t m, MonadFix m) => (a -> b -> PushM t (Maybe a)) -> a -> Event t b -> m (f a)
mapAccum :: (Accumulator t f, MonadHold t m, MonadFix m) => (a -> b -> (a, c)) -> a -> Event t b -> m (f a, Event t c)
mapAccumM :: (Accumulator t f, MonadHold t m, MonadFix m) => (a -> b -> PushM t (a, c)) -> a -> Event t b -> m (f a, Event t c)
mapAccumMaybe :: (Accumulator t f, MonadHold t m, MonadFix m) => (a -> b -> (Maybe a, Maybe c)) -> a -> Event t b -> m (f a, Event t c)
mapAccumMaybeM :: (Accumulator t f, MonadHold t m, MonadFix m) => (a -> b -> PushM t (Maybe a, Maybe c)) -> a -> Event t b -> m (f a, Event t c)
accumDyn :: (Reflex t, MonadHold t m, MonadFix m) => (a -> b -> a) -> a -> Event t b -> m (Dynamic t a)
accumMDyn :: (Reflex t, MonadHold t m, MonadFix m) => (a -> b -> PushM t a) -> a -> Event t b -> m (Dynamic t a)
accumMaybeDyn :: (Reflex t, MonadHold t m, MonadFix m) => (a -> b -> Maybe a) -> a -> Event t b -> m (Dynamic t a)
accumMaybeMDyn :: (Reflex t, MonadHold t m, MonadFix m) => (a -> b -> PushM t (Maybe a)) -> a -> Event t b -> m (Dynamic t a)
mapAccumDyn :: (Reflex t, MonadHold t m, MonadFix m) => (a -> b -> (a, c)) -> a -> Event t b -> m (Dynamic t a, Event t c)
mapAccumMDyn :: (Reflex t, MonadHold t m, MonadFix m) => (a -> b -> PushM t (a, c)) -> a -> Event t b -> m (Dynamic t a, Event t c)
mapAccumMaybeDyn :: (Reflex t, MonadHold t m, MonadFix m) => (a -> b -> (Maybe a, Maybe c)) -> a -> Event t b -> m (Dynamic t a, Event t c)
mapAccumMaybeMDyn :: (Reflex t, MonadHold t m, MonadFix m) => (a -> b -> PushM t (Maybe a, Maybe c)) -> a -> Event t b -> m (Dynamic t a, Event t c)
accumB :: (Reflex t, MonadHold t m, MonadFix m) => (a -> b -> a) -> a -> Event t b -> m (Behavior t a)
accumMB :: (Reflex t, MonadHold t m, MonadFix m) => (a -> b -> PushM t a) -> a -> Event t b -> m (Behavior t a)
accumMaybeB :: (Reflex t, MonadHold t m, MonadFix m) => (a -> b -> Maybe a) -> a -> Event t b -> m (Behavior t a)
accumMaybeMB :: (Reflex t, MonadHold t m, MonadFix m) => (a -> b -> PushM t (Maybe a)) -> a -> Event t b -> m (Behavior t a)
mapAccumB :: (Reflex t, MonadHold t m, MonadFix m) => (a -> b -> (a, c)) -> a -> Event t b -> m (Behavior t a, Event t c)
mapAccumMB :: (Reflex t, MonadHold t m, MonadFix m) => (a -> b -> PushM t (a, c)) -> a -> Event t b -> m (Behavior t a, Event t c)
mapAccumMaybeB :: (Reflex t, MonadHold t m, MonadFix m) => (a -> b -> (Maybe a, Maybe c)) -> a -> Event t b -> m (Behavior t a, Event t c)
mapAccumMaybeMB :: (Reflex t, MonadHold t m, MonadFix m) => (a -> b -> PushM t (Maybe a, Maybe c)) -> a -> Event t b -> m (Behavior t a, Event t c)

-- | Accumulate occurrences of an <a>Event</a>, producing an output
--   occurrence each time. Discard the underlying <a>Accumulator</a>.
mapAccum_ :: forall t m a b c. (Reflex t, MonadHold t m, MonadFix m) => (a -> b -> (a, c)) -> a -> Event t b -> m (Event t c)

-- | Accumulate occurrences of an <a>Event</a>, using a <a>PushM</a> action
--   and producing an output occurrence each time. Discard the underlying
--   <a>Accumulator</a>.
mapAccumM_ :: forall t m a b c. (Reflex t, MonadHold t m, MonadFix m) => (a -> b -> PushM t (a, c)) -> a -> Event t b -> m (Event t c)

-- | Accumulate occurrences of an <a>Event</a>, possibly producing an
--   output occurrence each time. Discard the underlying
--   <a>Accumulator</a>.
mapAccumMaybe_ :: forall t m a b c. (Reflex t, MonadHold t m, MonadFix m) => (a -> b -> (Maybe a, Maybe c)) -> a -> Event t b -> m (Event t c)

-- | Accumulate occurrences of an <a>Event</a>, using a <a>PushM</a> action
--   and possibly producing an output occurrence each time. Discard the
--   underlying <a>Accumulator</a>.
mapAccumMaybeM_ :: forall t m a b c. (Reflex t, MonadHold t m, MonadFix m) => (a -> b -> PushM t (Maybe a, Maybe c)) -> a -> Event t b -> m (Event t c)

-- | Create a new <a>Event</a> by combining each occurence with the next
--   value of the list using the supplied function. If the list runs out of
--   items, all subsequent <a>Event</a> occurrences will be ignored.
zipListWithEvent :: (Reflex t, MonadHold t m, MonadFix m) => (a -> b -> c) -> [a] -> Event t b -> m (Event t c)

-- | Assign a number to each occurence of the given <a>Event</a>, starting
--   from 0
numberOccurrences :: (Reflex t, MonadHold t m, MonadFix m, Num b) => Event t a -> m (Event t (b, a))

-- | Assign a number to each occurence of the given <a>Event</a>
numberOccurrencesFrom :: (Reflex t, MonadHold t m, MonadFix m, Num b) => b -> Event t a -> m (Event t (b, a))

-- | Assign a number to each occurence of the given <a>Event</a>; discard
--   the occurrences' values
numberOccurrencesFrom_ :: (Reflex t, MonadHold t m, MonadFix m, Num b) => b -> Event t a -> m (Event t b)

-- | This is used to sample the value of a <a>Behavior</a> using an
--   <a>Event</a>.
--   
--   The <a>&lt;@&gt;</a> operator is intended to be used in conjunction
--   with the <a>Applicative</a> instance for <a>Behavior</a>.
--   
--   This is useful when we want to combine the values of one <a>Event</a>
--   and the value of several <a>Behavior</a>s at the time the <a>Event</a>
--   is firing.
--   
--   If we have:
--   
--   <pre>
--   f  :: a -&gt; b -&gt; c -&gt; d
--   b1 :: Behavior t a
--   b2 :: Behavior t b
--   e  :: Event t c
--   </pre>
--   
--   then we can do:
--   
--   <pre>
--   f &lt;$&gt; b1 &lt;*&gt; b2 &lt;@&gt; e :: Event t d
--   </pre>
--   
--   in order to apply the function <tt>f</tt> to the relevant values.
--   
--   The alternative would be something like:
--   
--   <pre>
--   attachWith (\(x1, x2) y -&gt; f x1 x2 y) ((,) &lt;$&gt; b1 &lt;*&gt; b2) e :: Event t d
--   </pre>
--   
--   or a variation involing a custom data type to hold the combination of
--   <a>Behavior</a>s even when that combination might only ever be used by
--   <tt>f</tt>.
--   
--   A more suggestive example might be:
--   
--   <pre>
--   handleMouse &lt;$&gt; bPlayerState &lt;*&gt; bMousePosition &lt;@&gt; eMouseClick :: Event t (GameState -&gt; GameState)
--   </pre>
(<@>) :: Reflex t => Behavior t (a -> b) -> Event t a -> Event t b
infixl 4 <@>

-- | An version of <a>&lt;@&gt;</a> that does not use the value of the
--   <a>Event</a>.
--   
--   Alternatively, it is <a>tag</a> in operator form.
--   
--   This is useful when we want to combine the values of several
--   <a>Behavior</a>s at particular points in time using an
--   <a>Applicative</a> style syntax.
--   
--   If we have:
--   
--   <pre>
--   g  :: a -&gt; b -&gt; d
--   b1 :: Behavior t a
--   b2 :: Behavior t b
--   e  :: Event t c
--   </pre>
--   
--   where <tt>e</tt> is firing at the points in time of interest.
--   
--   Then we can use <a>&lt;@</a>:
--   
--   <pre>
--   g &lt;$&gt; b1 &lt;*&gt; b2 &lt;@  e :: Event t d
--   </pre>
--   
--   to combine the values of <tt>b1</tt> and <tt>b2</tt> at each of those
--   points of time, with the function <tt>g</tt> being used to combine the
--   values.
--   
--   This is the same as <a>&lt;@&gt;</a> except that the <a>Event</a> is
--   being used only to act as a trigger.
(<@) :: (Reflex t) => Behavior t b -> Event t a -> Event t b
infixl 4 <@

-- | Create a new <a>Event</a> that occurs on all but the first occurence
--   of the supplied <a>Event</a>.
tailE :: (Reflex t, MonadHold t m, MonadFix m) => Event t a -> m (Event t a)

-- | Create a tuple of two <a>Event</a>s with the first one occuring only
--   the first time the supplied <a>Event</a> occurs and the second
--   occuring on all but the first occurence.
headTailE :: (Reflex t, MonadHold t m, MonadFix m) => Event t a -> m (Event t a, Event t a)

-- | Starting at the current time, fire all the occurrences of the
--   <a>Event</a> for which the given predicate returns <a>True</a>. When
--   <a>False</a> is returned, do not fire, and permanently stop firing,
--   even if <a>True</a> values are encountered later.
takeWhileE :: forall t m a. (Reflex t, MonadFix m, MonadHold t m) => (a -> Bool) -> Event t a -> m (Event t a)

-- | Create a new behavior given a starting behavior and switch to a the
--   behvior carried by the event when it fires.
switcher :: (Reflex t, MonadHold t m) => Behavior t a -> Event t (Behavior t a) -> m (Behavior t a)

-- | Print the supplied <a>String</a> and the value of the <a>Event</a> on
--   each occurence. This should <i>only</i> be used for debugging.
--   
--   Note: As with Debug.Trace.trace, the message will only be printed if
--   the <a>Event</a> is actually used.
traceEvent :: (Reflex t, Show a) => String -> Event t a -> Event t a

-- | Print the output of the supplied function on each occurence of the
--   <a>Event</a>. This should <i>only</i> be used for debugging.
--   
--   Note: As with Debug.Trace.trace, the message will only be printed if
--   the <a>Event</a> is actually used.
traceEventWith :: Reflex t => (a -> String) -> Event t a -> Event t a

-- | Construct a <a>Dynamic</a> from a <a>Behavior</a> and an <a>Event</a>.
--   The <a>Behavior</a> _must_ change when and only when the <a>Event</a>
--   fires, such that the <tt>Behavior'</tt>s value is always equal to the
--   most recent firing of the <a>Event</a>; if this is not the case, the
--   resulting <a>Dynamic</a> will behave nondeterministically.
unsafeDynamic :: Reflex t => Behavior t a -> Event t a -> Dynamic t a
unsafeMapIncremental :: (Reflex t, Patch p, Patch p') => (PatchTarget p -> PatchTarget p') -> (p -> p') -> Incremental t p -> Incremental t p'

-- | A class for values that combines filtering and mapping using
--   <a>Maybe</a>. Morally, <tt><a>FunctorMaybe</a> ~ KleisliFunctor
--   <a>Maybe</a></tt>. Also similar is the <tt>Witherable</tt> typeclass,
--   but it requires <tt>Foldable f</tt> and <tt>Traverable f</tt>, and
--   e.g. <tt>Event</tt> is instance of neither.
--   
--   A definition of <a>fmapMaybe</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i><i>identity</i></i> <tt><a>fmapMaybe</a> <a>Just</a> ≡
--   <a>id</a></tt></li>
--   <li><i><i>composition</i></i> <tt><a>fmapMaybe</a> (f &lt;=&lt; g) ≡
--   <a>fmapMaybe</a> f . <a>fmapMaybe</a> g</tt></li>
--   </ul>
class FunctorMaybe f

-- | Combined mapping and filtering function.
fmapMaybe :: FunctorMaybe f => (a -> Maybe b) -> f a -> f b

-- | Flipped version of <a>fmapMaybe</a>.
fforMaybe :: FunctorMaybe f => f a -> (a -> Maybe b) -> f b

-- | Filter 'f a' using the provided predicate. Relies on <a>fforMaybe</a>.
ffilter :: FunctorMaybe f => (a -> Bool) -> f a -> f a

-- | Filter <a>Left</a>s from 'f (Either a b)' into <tt>a</tt>.
filterLeft :: FunctorMaybe f => f (Either a b) -> f a

-- | Filter <a>Right</a>s from 'f (Either a b)' into <tt>b</tt>.
filterRight :: FunctorMaybe f => f (Either a b) -> f b

-- | A <a>Monad</a> that supports adjustment over time. After an action has
--   been run, if the given events fire, it will adjust itself so that its
--   net effect is as though it had originally been run with the new value.
--   Note that there is some issue here with persistent side-effects:
--   obviously, IO (and some other side-effects) cannot be undone, so it is
--   up to the instance implementer to determine what the best meaning for
--   this class is in such cases.
class (Reflex t, Monad m) => Adjustable t m | m -> t
runWithReplace :: Adjustable t m => m a -> Event t (m b) -> m (a, Event t b)
traverseIntMapWithKeyWithAdjust :: Adjustable t m => (Key -> v -> m v') -> IntMap v -> Event t (PatchIntMap v) -> m (IntMap v', Event t (PatchIntMap v'))
traverseDMapWithKeyWithAdjust :: (Adjustable t m, GCompare k) => (forall a. k a -> v a -> m (v' a)) -> DMap k v -> Event t (PatchDMap k v) -> m (DMap k v', Event t (PatchDMap k v'))
traverseDMapWithKeyWithAdjustWithMove :: (Adjustable t m, GCompare k) => (forall a. k a -> v a -> m (v' a)) -> DMap k v -> Event t (PatchDMapWithMove k v) -> m (DMap k v', Event t (PatchDMapWithMove k v'))
sequenceDMapWithAdjust :: (GCompare k, Adjustable t m) => DMap k m -> Event t (PatchDMap k m) -> m (DMap k Identity, Event t (PatchDMap k Identity))
sequenceDMapWithAdjustWithMove :: (GCompare k, Adjustable t m) => DMap k m -> Event t (PatchDMapWithMove k m) -> m (DMap k Identity, Event t (PatchDMapWithMove k Identity))
mapMapWithAdjustWithMove :: forall t m k v v'. (Adjustable t m, Ord k) => (k -> v -> m v') -> Map k v -> Event t (PatchMapWithMove k v) -> m (Map k v', Event t (PatchMapWithMove k v'))

-- | Flipped version of <a>fmap</a>.
ffor :: Functor f => f a -> (a -> b) -> f b

-- | <i>Deprecated: Use Adjustable instead</i>
type MonadAdjust = Adjustable

-- | Create a new <a>Event</a> that occurs if at least one of the supplied
--   <a>Event</a>s occurs. If both occur at the same time they are combined
--   using <a>mappend</a>.

-- | <i>Deprecated: If a 'Semigroup a' instance is available, use
--   <a>mappend</a>; otherwise, use 'alignWith (mergeThese mappend)'
--   instead</i>
appendEvents :: (Reflex t, Monoid a) => Event t a -> Event t a -> Event t a

-- | Alias for <a>headE</a>

-- | <i>Deprecated: Use <a>headE</a> instead</i>
onceE :: (Reflex t, MonadHold t m, MonadFix m) => Event t a -> m (Event t a)

-- | Run both sides of a <a>These</a> monadically, combining the results.

-- | <i>Deprecated: Use bisequenceA or bisequence from the bifunctors
--   package instead</i>
sequenceThese :: Monad m => These (m a) (m b) -> m (These a b)
fmapMaybeCheap :: Reflex t => (a -> Maybe b) -> Event t a -> Event t b
fmapCheap :: Reflex t => (a -> b) -> Event t a -> Event t b
fforCheap :: Reflex t => Event t a -> (a -> b) -> Event t b
fforMaybeCheap :: Reflex t => Event t a -> (a -> Maybe b) -> Event t b
pushAlwaysCheap :: Reflex t => (a -> PushM t b) -> Event t a -> Event t b
tagCheap :: Reflex t => Behavior t b -> Event t a -> Event t b
mergeWithCheap :: Reflex t => (a -> a -> a) -> [Event t a] -> Event t a
mergeWithCheap' :: Reflex t => (a -> b) -> (b -> b -> b) -> [Event t a] -> Event t b

-- | <i>Deprecated: Use <a>switchHoldPromptly</a> instead. The
--   'switchHold*' naming convention was chosen because those functions are
--   more closely related to each other than they are to <a>switch</a>.
--   </i>
switchPromptly :: (Reflex t, MonadHold t m) => Event t a -> Event t (Event t a) -> m (Event t a)

-- | <i>Deprecated: Use <a>switchHoldPromptOnly</a> instead. The
--   'switchHold*' naming convention was chosen because those functions are
--   more closely related to each other than they are to <a>switch</a>.
--   </i>
switchPromptOnly :: (Reflex t, MonadHold t m) => Event t a -> Event t (Event t a) -> m (Event t a)
slowHeadE :: (Reflex t, MonadHold t m, MonadFix m) => Event t a -> m (Event t a)
instance (Reflex.Class.Reflex t, Data.Default.Class.Default a) => Data.Default.Class.Default (Reflex.Class.Dynamic t a)
instance Reflex.Class.MonadSample t m => Reflex.Class.MonadSample t (Control.Monad.Trans.Reader.ReaderT r m)
instance Reflex.Class.MonadHold t m => Reflex.Class.MonadHold t (Control.Monad.Trans.Reader.ReaderT r m)
instance (Reflex.Class.MonadSample t m, GHC.Base.Monoid r) => Reflex.Class.MonadSample t (Control.Monad.Trans.Writer.Lazy.WriterT r m)
instance (Reflex.Class.MonadHold t m, GHC.Base.Monoid r) => Reflex.Class.MonadHold t (Control.Monad.Trans.Writer.Lazy.WriterT r m)
instance Reflex.Class.MonadSample t m => Reflex.Class.MonadSample t (Control.Monad.Trans.State.Strict.StateT s m)
instance Reflex.Class.MonadHold t m => Reflex.Class.MonadHold t (Control.Monad.Trans.State.Strict.StateT s m)
instance Reflex.Class.MonadSample t m => Reflex.Class.MonadSample t (Control.Monad.Trans.Except.ExceptT e m)
instance Reflex.Class.MonadHold t m => Reflex.Class.MonadHold t (Control.Monad.Trans.Except.ExceptT e m)
instance (Reflex.Class.MonadSample t m, GHC.Base.Monoid w) => Reflex.Class.MonadSample t (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (Reflex.Class.MonadHold t m, GHC.Base.Monoid w) => Reflex.Class.MonadHold t (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance Reflex.Class.MonadSample t m => Reflex.Class.MonadSample t (Control.Monad.Trans.Cont.ContT r m)
instance Reflex.Class.MonadHold t m => Reflex.Class.MonadHold t (Control.Monad.Trans.Cont.ContT r m)
instance Reflex.Class.Reflex t => GHC.Base.Applicative (Reflex.Class.Behavior t)
instance Reflex.Class.Reflex t => Data.Functor.Bind.Class.Apply (Reflex.Class.Behavior t)
instance Reflex.Class.Reflex t => Data.Functor.Bind.Class.Bind (Reflex.Class.Behavior t)
instance (Reflex.Class.Reflex t, GHC.Real.Fractional a) => GHC.Real.Fractional (Reflex.Class.Behavior t a)
instance Reflex.Class.Reflex t => GHC.Base.Functor (Reflex.Class.Behavior t)
instance (Reflex.Class.Reflex t, Data.String.IsString a) => Data.String.IsString (Reflex.Class.Behavior t a)
instance Reflex.Class.Reflex t => GHC.Base.Monad (Reflex.Class.Behavior t)
instance (Reflex.Class.Reflex t, GHC.Base.Monoid a) => GHC.Base.Monoid (Reflex.Class.Behavior t a)
instance (Reflex.Class.Reflex t, GHC.Num.Num a) => GHC.Num.Num (Reflex.Class.Behavior t a)
instance (Reflex.Class.Reflex t, Data.Semigroup.Semigroup a) => Data.Semigroup.Semigroup (Reflex.Class.Behavior t a)
instance Reflex.Class.Reflex t => Data.Functor.Alt.Alt (Reflex.Class.Event t)
instance Reflex.Class.Reflex t => Data.Functor.Bind.Class.Apply (Reflex.Class.Event t)
instance Reflex.Class.Reflex t => Data.Functor.Bind.Class.Bind (Reflex.Class.Event t)
instance Reflex.Class.Reflex t => GHC.Base.Functor (Reflex.Class.Event t)
instance Reflex.Class.Reflex t => Reflex.FunctorMaybe.FunctorMaybe (Reflex.Class.Event t)
instance Reflex.Class.Reflex t => Data.Functor.Plus.Plus (Reflex.Class.Event t)
instance (Data.Semigroup.Semigroup a, Reflex.Class.Reflex t) => Data.Semigroup.Semigroup (Reflex.Class.Event t a)
instance (Data.Semigroup.Semigroup a, Reflex.Class.Reflex t) => GHC.Base.Monoid (Reflex.Class.Event t a)
instance Reflex.Class.Reflex t => Data.Align.Align (Reflex.Class.Event t)
instance (Reflex.Class.Reflex t, Data.String.IsString a) => Data.String.IsString (Reflex.Class.Dynamic t a)
instance (Reflex.Class.Reflex t, Data.Semigroup.Semigroup a) => Data.Semigroup.Semigroup (Reflex.Class.Dynamic t a)
instance (Reflex.Class.Reflex t, GHC.Base.Monoid a) => GHC.Base.Monoid (Reflex.Class.Dynamic t a)
instance Reflex.Class.Reflex t => Reflex.Class.Accumulator t (Reflex.Class.Dynamic t)
instance Reflex.Class.Reflex t => Reflex.Class.Accumulator t (Reflex.Class.Behavior t)
instance Reflex.Class.Reflex t => Reflex.Class.Accumulator t (Reflex.Class.Event t)
instance Reflex.Class.Adjustable t m => Reflex.Class.Adjustable t (Control.Monad.Trans.Reader.ReaderT r m)


-- | This module contains various functions for working with <a>Dynamic</a>
--   values. <a>Dynamic</a> and its primitives have been moved to the
--   <a>Reflex</a> class.
module Reflex.Dynamic

-- | Extract the <a>Behavior</a> of a <a>Dynamic</a>.
current :: Reflex t => Dynamic t a -> Behavior t a

-- | Extract the <a>Event</a> of the <a>Dynamic</a>.
updated :: Reflex t => Dynamic t a -> Event t a

-- | Create a <a>Dynamic</a> value using the given initial value that
--   changes every time the <a>Event</a> occurs.
holdDyn :: MonadHold t m => a -> Event t a -> m (Dynamic t a)

-- | Map a sampling function over a <a>Dynamic</a>.
mapDynM :: forall t m a b. (Reflex t, MonadHold t m) => (forall m'. MonadSample t m' => a -> m' b) -> Dynamic t a -> m (Dynamic t b)

-- | Flipped version of <a>mapDynM</a>
forDynM :: forall t m a b. (Reflex t, MonadHold t m) => Dynamic t a -> (forall m'. MonadSample t m' => a -> m' b) -> m (Dynamic t b)

-- | Construct a <a>Dynamic</a> value that never changes
constDyn :: Reflex t => a -> Dynamic t a

-- | Create a new <a>Dynamic</a> that counts the occurences of the
--   <a>Event</a>.
count :: (Reflex t, MonadHold t m, MonadFix m, Num b) => Event t a -> m (Dynamic t b)

-- | Create a new <a>Dynamic</a> using the initial value that flips its
--   value every time the <a>Event</a> occurs.
toggle :: (Reflex t, MonadHold t m, MonadFix m) => Bool -> Event t a -> m (Dynamic t Bool)

-- | Switches to the new <a>Event</a> whenever it receives one. Only the
--   old event is considered the moment a new one is switched in; the
--   output event will fire at that moment if only if the old event does.
--   
--   Prefer this to <a>switchPromptlyDyn</a> where possible. The lack of
--   doing double work when the outer and (new) inner fires means this
--   imposes fewer "timing requirements" and thus is far more easy to use
--   without introducing fresh failure cases. <a>switchDyn</a> is also more
--   performant.
switchDyn :: forall t a. Reflex t => Dynamic t (Event t a) -> Event t a

-- | Switches to the new <a>Event</a> whenever it receives one. Switching
--   occurs *before* the inner <a>Event</a> fires - so if the
--   <a>Dynamic</a> changes and both the old and new inner Events fire
--   simultaneously, the output will fire with the value of the *new*
--   <a>Event</a>.
--   
--   Prefer <a>switchDyn</a> to this where possible. The timing
--   requirements that switching before imposes are likely to bring down
--   your app unless you are very careful. <a>switchDyn</a> is also more
--   performant.
switchPromptlyDyn :: forall t a. Reflex t => Dynamic t (Event t a) -> Event t a

-- | Replace the value of the <a>Event</a> with the current value of the
--   <a>Dynamic</a> each time the <a>Event</a> occurs.
--   
--   Note: `tagPromptlyDyn d e` differs from `tag (current d) e` in the
--   case that <tt>e</tt> is firing at the same time that <tt>d</tt> is
--   changing. With `tagPromptlyDyn d e`, the *new* value of <tt>d</tt>
--   will replace the value of <tt>e</tt>, whereas with `tag (current d)
--   e`, the *old* value will be used, since the <a>Behavior</a> won't be
--   updated until the end of the frame. Additionally, this means that the
--   output <a>Event</a> may not be used to directly change the input
--   <a>Dynamic</a>, because that would mean its value depends on itself.
--   When creating cyclic data flows, generally `tag (current d) e` is
--   preferred.
tagPromptlyDyn :: Reflex t => Dynamic t a -> Event t b -> Event t a

-- | Attach the current value of the <a>Dynamic</a> to the value of the
--   <a>Event</a> each time it occurs.
--   
--   Note: `attachPromptlyDyn d` is not the same as `attach (current d)`.
--   See <a>tagPromptlyDyn</a> for details.
attachPromptlyDyn :: Reflex t => Dynamic t a -> Event t b -> Event t (a, b)

-- | Combine the current value of the <a>Dynamic</a> with the value of the
--   <a>Event</a> each time it occurs.
--   
--   Note: `attachPromptlyDynWith f d` is not the same as `attachWith f
--   (current d)`. See <a>tagPromptlyDyn</a> for details.
attachPromptlyDynWith :: Reflex t => (a -> b -> c) -> Dynamic t a -> Event t b -> Event t c

-- | Create a new <a>Event</a> by combining the value at each occurence
--   with the current value of the <a>Dynamic</a> value and possibly
--   filtering if the combining function returns <a>Nothing</a>.
--   
--   Note: `attachPromptlyDynWithMaybe f d` is not the same as
--   `attachWithMaybe f (current d)`. See <a>tagPromptlyDyn</a> for
--   details.
attachPromptlyDynWithMaybe :: Reflex t => (a -> b -> Maybe c) -> Dynamic t a -> Event t b -> Event t c

-- | Factor a <tt>Dynamic t (Maybe a)</tt> into a <tt>Dynamic t (Maybe
--   (Dynamic t a))</tt>, such that the outer <a>Dynamic</a> is updated
--   only when the <tt>Maybe'</tt>s constructor chages from <a>Nothing</a>
--   to <a>Just</a> or vice-versa. Whenever the constructor becomes
--   <a>Just</a>, an inner <a>Dynamic</a> will be provided, whose value
--   will track the <tt>a</tt> inside the <a>Just</a>; when the constructor
--   becomes <a>Nothing</a>, the existing inner <a>Dynamic</a> will become
--   constant, and will not change when the outer constructor changes back
--   to <a>Nothing</a>.
maybeDyn :: forall t a m. (Reflex t, MonadFix m, MonadHold t m) => Dynamic t (Maybe a) -> m (Dynamic t (Maybe (Dynamic t a)))
eitherDyn :: forall t a b m. (Reflex t, MonadFix m, MonadHold t m) => Dynamic t (Either a b) -> m (Dynamic t (Either (Dynamic t a) (Dynamic t b)))
factorDyn :: forall t m k v. (Reflex t, MonadFix m, MonadHold t m, GEq k) => Dynamic t (DSum k v) -> m (Dynamic t (DSum k (Compose (Dynamic t) v)))

-- | Create a <a>Dynamic</a> that accumulates values from another
--   <a>Dynamic</a>. This function does not force its input <a>Dynamic</a>
--   until the output <a>Dynamic</a> is forced.
scanDyn :: (Reflex t, MonadHold t m, MonadFix m) => (a -> b) -> (a -> b -> b) -> Dynamic t a -> m (Dynamic t b)

-- | Like <a>scanDyn</a>, but the the accumulator function may decline to
--   update the result <tt>Dynamic'</tt>s value.
scanDynMaybe :: (Reflex t, MonadHold t m, MonadFix m) => (a -> b) -> (a -> b -> Maybe b) -> Dynamic t a -> m (Dynamic t b)

-- | Create a new <a>Dynamic</a> that only signals changes if the values
--   actually changed.
holdUniqDyn :: (Reflex t, MonadHold t m, MonadFix m, Eq a) => Dynamic t a -> m (Dynamic t a)

-- | Create a new <a>Dynamic</a> that changes only when the underlying
--   <a>Dynamic</a> changes and the given function returns <a>False</a>
--   when given both the old and the new values.
holdUniqDynBy :: (Reflex t, MonadHold t m, MonadFix m) => (a -> a -> Bool) -> Dynamic t a -> m (Dynamic t a)

-- | Dynamic Maybe that can only update from Nothing to Just or Just to
--   Just (i.e., cannot revert to Nothing)
improvingMaybe :: (Reflex t, MonadHold t m, MonadFix m) => Dynamic t (Maybe a) -> m (Dynamic t (Maybe a))

-- | Create a <a>Dynamic</a> using the initial value and change it each
--   time the <a>Event</a> occurs using a folding function on the previous
--   value and the value of the <a>Event</a>.
foldDyn :: (Reflex t, MonadHold t m, MonadFix m) => (a -> b -> b) -> b -> Event t a -> m (Dynamic t b)

-- | Like <a>foldDyn</a>, but the combining function is a <a>PushM</a>
--   action, so it can <a>sample</a> existing <tt>Behaviors</tt> and
--   <a>hold</a> new ones.
foldDynM :: (Reflex t, MonadHold t m, MonadFix m) => (a -> b -> PushM t b) -> b -> Event t a -> m (Dynamic t b)

-- | Create a <a>Dynamic</a> using the provided initial value and change it
--   each time the provided <a>Event</a> occurs, using a function to
--   combine the old value with the <tt>Event'</tt>s value. If the function
--   returns <a>Nothing</a>, the value is not changed; this is distinct
--   from returning <a>Just</a> the old value, since the <tt>Dynamic'</tt>s
--   <a>updated</a> <a>Event</a> will fire in the <a>Just</a> case, and
--   will not fire in the <a>Nothing</a> case.
foldDynMaybe :: (Reflex t, MonadHold t m, MonadFix m) => (a -> b -> Maybe b) -> b -> Event t a -> m (Dynamic t b)

-- | Like <a>foldDynMaybe</a>, but the combining function is a <a>PushM</a>
--   action, so it can <a>sample</a> existing <tt>Behaviors</tt> and
--   <a>hold</a> new ones.
foldDynMaybeM :: (Reflex t, MonadHold t m, MonadFix m) => (a -> b -> PushM t (Maybe b)) -> b -> Event t a -> m (Dynamic t b)

-- | Combine a <a>Dynamic</a> of a <a>Map</a> of <a>Dynamic</a>s into a
--   <a>Dynamic</a> with the current values of the <a>Dynamic</a>s in a
--   map.
joinDynThroughMap :: forall t k a. (Reflex t, Ord k) => Dynamic t (Map k (Dynamic t a)) -> Dynamic t (Map k a)

-- | Print the value of the <a>Dynamic</a> when it is first read and on
--   each subsequent change that is observed (as traceEvent), prefixed with
--   the provided string. This should <i>only</i> be used for debugging.
--   
--   Note: Just like Debug.Trace.trace, the value will only be shown if
--   something else in the system is depending on it.
traceDyn :: (Reflex t, Show a) => String -> Dynamic t a -> Dynamic t a

-- | Print the result of applying the provided function to the value of the
--   <a>Dynamic</a> when it is first read and on each subsequent change
--   that is observed (as traceEvent). This should <i>only</i> be used for
--   debugging.
--   
--   Note: Just like Debug.Trace.trace, the value will only be shown if
--   something else in the system is depending on it.
traceDynWith :: Reflex t => (a -> String) -> Dynamic t a -> Dynamic t a

-- | Split a <a>Dynamic</a> pair into a pair of <a>Dynamic</a>s
splitDynPure :: Reflex t => Dynamic t (a, b) -> (Dynamic t a, Dynamic t b)

-- | Convert a <a>Map</a> with <a>Dynamic</a> elements into a
--   <a>Dynamic</a> of a <a>Map</a> with non-<a>Dynamic</a> elements.
distributeMapOverDynPure :: (Reflex t, Ord k) => Map k (Dynamic t v) -> Dynamic t (Map k v)

-- | This function converts a <a>DMap</a> whose elements are
--   <a>Dynamic</a>s into a <a>Dynamic</a> <a>DMap</a>. Its implementation
--   is more efficient than doing the same through the use of multiple uses
--   of <tt>zipWithDyn</tt> or <a>Applicative</a> operators.
distributeDMapOverDynPure :: forall t k. (Reflex t, GCompare k) => DMap k (Dynamic t) -> Dynamic t (DMap k Identity)

-- | Convert a list with <a>Dynamic</a> elements into a <a>Dynamic</a> of a
--   list with non-<a>Dynamic</a> elements, preserving the order of the
--   elements.
distributeListOverDynPure :: Reflex t => [Dynamic t v] -> Dynamic t [v]

-- | Represents a time changing value together with an <a>EventSelector</a>
--   that can efficiently detect when the underlying <a>Dynamic</a> has a
--   particular value. This is useful for representing data like the
--   current selection of a long list.
--   
--   Semantically,
--   
--   <pre>
--   demuxed (demux d) k === fmap (== k) d
--   </pre>
--   
--   However, the when getDemuxed is used multiple times, the complexity is
--   only <i>O(log(n))</i>, rather than <i>O(n)</i> for fmap.
data Demux t k

-- | Demultiplex an input value to a <a>Demux</a> with many outputs. At any
--   given time, whichever output is indicated by the given <a>Dynamic</a>
--   will be <a>True</a>.
demux :: (Reflex t, Ord k) => Dynamic t k -> Demux t k

-- | Select a particular output of the <a>Demux</a>; this is equivalent to
--   (but much faster than) mapping over the original <a>Dynamic</a> and
--   checking whether it is equal to the given key.
demuxed :: (Reflex t, Eq k) => Demux t k -> k -> Dynamic t Bool

-- | A heterogeneous list whose type and length are fixed statically. This
--   is reproduced from the <a>HList</a> package due to integration issues,
--   and because very little other functionality from that library is
--   needed.
data HList (l :: [*])
[HNil] :: HList '[]
[HCons] :: e -> HList l -> HList (e : l)

-- | Like <a>HList</a>, but with a functor wrapping each element.
data FHList f l
[FHNil] :: FHList f '[]
[FHCons] :: f e -> FHList f l -> FHList f (e : l)

-- | Convert a datastructure whose constituent parts are all
--   <a>Dynamic</a>s into a single <a>Dynamic</a> whose value represents
--   all the current values of the input's consitutent <a>Dynamic</a>s.
collectDynPure :: (RebuildSortedHList (HListElems b), IsHList a, IsHList b, AllAreFunctors (Dynamic t) (HListElems b), Reflex t, HListElems a ~ FunctorList (Dynamic t) (HListElems b)) => a -> Dynamic t b

-- | This class allows <a>HList</a>s and <tt>FHlist</tt>s to be built from
--   regular lists; they must be contiguous and sorted.
class RebuildSortedHList l
rebuildSortedFHList :: RebuildSortedHList l => [DSum (HListPtr l) f] -> FHList f l
rebuildSortedHList :: RebuildSortedHList l => [DSum (HListPtr l) Identity] -> HList l

-- | Poor man's <tt>Generic</tt>s for product types only.
class IsHList a where type HListElems a :: [*] where {
    type family HListElems a :: [*];
}
toHList :: IsHList a => a -> HList (HListElems a)
fromHList :: IsHList a => HList (HListElems a) -> a

-- | Indicates that all elements in a type-level list are applications of
--   the same functor.
class AllAreFunctors (f :: a -> *) (l :: [a]) where type FunctorList f l :: [*] where {
    type family FunctorList f l :: [*];
}
toFHList :: AllAreFunctors f l => HList (FunctorList f l) -> FHList f l
fromFHList :: AllAreFunctors f l => FHList f l -> HList (FunctorList f l)

-- | A typed index into a typed heterogeneous list.
data HListPtr l a
[HHeadPtr] :: HListPtr (h : t) h
[HTailPtr] :: HListPtr t a -> HListPtr (h : t) a

-- | Collect a hetereogeneous list whose elements are all <a>Dynamic</a>s
--   into a single <a>Dynamic</a> whose value represents the current values
--   of all of the input <a>Dynamic</a>s.
distributeFHListOverDynPure :: (Reflex t, RebuildSortedHList l) => FHList (Dynamic t) l -> Dynamic t (HList l)

-- | Construct a <a>Dynamic</a> from a <a>Behavior</a> and an <a>Event</a>.
--   The <a>Behavior</a> _must_ change when and only when the <a>Event</a>
--   fires, such that the <tt>Behavior'</tt>s value is always equal to the
--   most recent firing of the <a>Event</a>; if this is not the case, the
--   resulting <a>Dynamic</a> will behave nondeterministically.
unsafeDynamic :: Reflex t => Behavior t a -> Event t a -> Dynamic t a

-- | A psuedo applicative version of ap for <a>Dynamic</a>. Example useage:
--   
--   <pre>
--   do
--      person &lt;- Person `mapDyn` dynFirstName
--                       `apDyn` dynListName
--                       `apDyn` dynAge
--                       `apDyn` dynAddress
--   </pre>

-- | <i>Deprecated: Use 'ffor m (<a>*</a> a)' instead of 'apDyn m a';
--   consider eliminating monadic style, since Dynamics are now Applicative
--   and can be used with applicative style directly</i>
apDyn :: forall t m a b. (Reflex t, Monad m) => m (Dynamic t (a -> b)) -> Dynamic t a -> m (Dynamic t b)

-- | This function has been renamed to <a>attachPromptlyDyn</a> to clarify
--   its semantics.

-- | <i>Deprecated: Use <a>attachPromptlyDyn</a> instead</i>
attachDyn :: Reflex t => Dynamic t a -> Event t b -> Event t (a, b)

-- | This function has been renamed to <a>attachPromptlyDynWith</a> to
--   clarify its semantics.

-- | <i>Deprecated: Use <a>attachPromptlyDynWith</a> instead</i>
attachDynWith :: Reflex t => (a -> b -> c) -> Dynamic t a -> Event t b -> Event t c

-- | This function has been renamed to <a>attachPromptlyDynWithMaybe</a> to
--   clarify its semantics.

-- | <i>Deprecated: Use <a>attachPromptlyDynWithMaybe</a> instead</i>
attachDynWithMaybe :: Reflex t => (a -> b -> Maybe c) -> Dynamic t a -> Event t b -> Event t c

-- | This function no longer needs to be monadic, so it has been replaced
--   by <a>collectDynPure</a>, which is pure.

-- | <i>Deprecated: Use 'return . collectDynPure' instead; consider
--   eliminating monadic style</i>
collectDyn :: (RebuildSortedHList (HListElems b), IsHList a, IsHList b, AllAreFunctors (Dynamic t) (HListElems b), Reflex t, Monad m, HListElems a ~ FunctorList (Dynamic t) (HListElems b)) => a -> m (Dynamic t b)

-- | Merge two <a>Dynamic</a>s into a new one using the provided function.
--   The new <a>Dynamic</a> changes its value each time one of the original
--   <a>Dynamic</a>s changes its value.

-- | <i>Deprecated: Use 'return (zipDynWith f a b)' instead of 'combineDyn
--   f a b'; consider eliminating monadic style</i>
combineDyn :: forall t m a b c. (Reflex t, Monad m) => (a -> b -> c) -> Dynamic t a -> Dynamic t b -> m (Dynamic t c)

-- | This function no longer needs to be monadic; see
--   <a>distributeMapOverDynPure</a>.

-- | <i>Deprecated: Use 'return . distributeDMapOverDynPure' instead;
--   consider eliminating monadic style</i>
distributeDMapOverDyn :: (Reflex t, Monad m, GCompare k) => DMap k (Dynamic t) -> m (Dynamic t (DMap k Identity))

-- | This function no longer needs to be monadic, so it has been replaced
--   by <a>distributeFHListOverDynPure</a>, which is pure.

-- | <i>Deprecated: Use 'return . distributeFHListOverDynPure' instead;
--   consider eliminating monadic style</i>
distributeFHListOverDyn :: forall t m l. (Reflex t, Monad m, RebuildSortedHList l) => FHList (Dynamic t) l -> m (Dynamic t (HList l))

-- | Flipped version of <a>mapDyn</a>.

-- | <i>Deprecated: Use 'return . ffor a' instead of 'forDyn a'; consider
--   eliminating monadic style</i>
forDyn :: (Reflex t, Monad m) => Dynamic t a -> (a -> b) -> m (Dynamic t b)

-- | This function no longer needs to be monadic, so it has been replaced
--   by <a>demuxed</a>, which is pure.

-- | <i>Deprecated: Use 'return . demuxed d' instead of 'getDemuxed d';
--   consider eliminating monadic style</i>
getDemuxed :: (Reflex t, Monad m, Eq k) => Demux t k -> k -> m (Dynamic t Bool)

-- | Combine an inner and outer <a>Dynamic</a> such that the resulting
--   <tt>Dynamic'</tt>s current value will always be equal to the current
--   value's current value, and will change whenever either the inner or
--   the outer (or both) values change.

-- | <i>Deprecated: Use <a>join</a> instead</i>
joinDyn :: Reflex t => Dynamic t (Dynamic t a) -> Dynamic t a

-- | Map a function over a <a>Dynamic</a>.

-- | <i>Deprecated: Use 'return . fmap f' instead of 'mapDyn f'; consider
--   eliminating monadic style</i>
mapDyn :: (Reflex t, Monad m) => (a -> b) -> Dynamic t a -> m (Dynamic t b)

-- | Merge the <a>Dynamic</a> values using their <a>Monoid</a> instance.

-- | <i>Deprecated: Use 'return . mconcat' instead; consider eliminating
--   monadic style</i>
mconcatDyn :: forall t m a. (Reflex t, Monad m, Monoid a) => [Dynamic t a] -> m (Dynamic t a)

-- | WARNING: This function is only pure if <tt>a</tt>'s <a>Eq</a> instance
--   tests representational equality. Use <a>holdUniqDyn</a> instead, which
--   is pure in all circumstances. Also, note that, unlike <tt>nub</tt>,
--   this function does not prevent all recurrences of a value, only
--   consecutive recurrences.

-- | <i>Deprecated: Use <a>holdUniqDyn</a> instead; note that it returns a
--   MonadHold action rather than a pure Dynamic</i>
nubDyn :: (Reflex t, Eq a) => Dynamic t a -> Dynamic t a

-- | Split the <a>Dynamic</a> into two <a>Dynamic</a>s, each taking the
--   respective value of the tuple.

-- | <i>Deprecated: Use 'return . splitDynPure' instead; consider
--   eliminating monadic style</i>
splitDyn :: (Reflex t, Monad m) => Dynamic t (a, b) -> m (Dynamic t a, Dynamic t b)

-- | This function has been renamed to <a>tagPromptlyDyn</a> to clarify its
--   semantics.

-- | <i>Deprecated: Use <a>tagPromptlyDyn</a> instead</i>
tagDyn :: Reflex t => Dynamic t a -> Event t b -> Event t a

-- | WARNING: This function is only pure if <tt>a</tt>'s <a>Eq</a> instance
--   tests representational equality. Use <a>holdUniqDyn</a> instead, which
--   is pure in all circumstances.

-- | <i>Deprecated: Use <a>holdUniqDyn</a> instead; note that it returns a
--   MonadHold action rather than a pure Dynamic</i>
uniqDyn :: (Reflex t, Eq a) => Dynamic t a -> Dynamic t a

-- | WARNING: This function is impure. Use <a>holdUniqDynBy</a> instead.

-- | <i>Deprecated: Use <a>holdUniqDynBy</a> instead; note that it returns
--   a MonadHold action rather than a pure Dynamic</i>
uniqDynBy :: Reflex t => (a -> a -> Bool) -> Dynamic t a -> Dynamic t a
instance forall a (l :: [a]) (a1 :: a). GHC.Classes.Eq (Reflex.Dynamic.HListPtr l a1)
instance forall a (l :: [a]) (a1 :: a). GHC.Classes.Ord (Reflex.Dynamic.HListPtr l a1)
instance l' ~ Reflex.Dynamic.HRevApp l '[] => Reflex.Dynamic.HBuild' l (Reflex.Dynamic.HList l')
instance Reflex.Dynamic.HBuild' (a : l) r => Reflex.Dynamic.HBuild' l (a -> r)
instance forall k (l :: [k]). Data.GADT.Compare.GEq (Reflex.Dynamic.HListPtr l)
instance forall k (l :: [k]). Data.GADT.Compare.GCompare (Reflex.Dynamic.HListPtr l)
instance Reflex.Dynamic.RebuildSortedHList '[]
instance Reflex.Dynamic.RebuildSortedHList t => Reflex.Dynamic.RebuildSortedHList (h : t)
instance forall a (f :: a -> GHC.Types.*). Reflex.Dynamic.AllAreFunctors f '[]
instance forall a (f :: a -> GHC.Types.*) (t :: [a]) (h :: a). Reflex.Dynamic.AllAreFunctors f t => Reflex.Dynamic.AllAreFunctors f (h : t)
instance Reflex.Dynamic.IsHList (a, b)
instance Reflex.Dynamic.IsHList (a, b, c, d)
instance Reflex.Dynamic.IsHList (a, b, c, d, e, f)


-- | Template Haskell helper functions for building complex <a>Dynamic</a>
--   values.
module Reflex.Dynamic.TH

-- | Quote a <a>Dynamic</a> expression. Within the quoted expression, you
--   can use <tt>$(unqDyn [| x |])</tt> to refer to any expression
--   <tt>x</tt> of type <tt>Dynamic t a</tt>; the unquoted result will be
--   of type <tt>a</tt>
qDynPure :: Q Exp -> Q Exp

-- | Antiquote a <a>Dynamic</a> expression. This can <i>only</i> be used
--   inside of a <a>qDyn</a> quotation.
unqDyn :: Q Exp -> Q Exp

-- | Create a <a>Dynamic</a> value using other <a>Dynamic</a>s as inputs.
--   The result is sometimes more concise and readable than the equivalent
--   <a>Applicative</a>-based expression. For example:
--   
--   <pre>
--   [mkDyn| $x + $v * $t + 1/2 * $a * $t ^ 2 |]
--   </pre>
--   
--   would have a very cumbersome <a>Applicative</a> encoding.
mkDynPure :: QuasiQuoter

-- | Like <a>qDynPure</a>, but wraps its result monadically using
--   <a>return</a>. This is no longer necessary, due to <a>Dynamic</a>
--   being an instance of <a>Functor</a>.

-- | <i>Deprecated: Instead of $(qDyn x), use return $(qDynPure x)</i>
qDyn :: Q Exp -> Q Exp

-- | Like <a>mkDynPure</a>, but wraps its result monadically using
--   <a>return</a>. This is no longer necessary, due to <a>Dynamic</a>
--   being an instance of <a>Functor</a>.

-- | <i>Deprecated: Instead of [mkDyn| x |], use return [mkDynPure| x
--   |]</i>
mkDyn :: QuasiQuoter


-- | This module provides a variation of <a>Dynamic</a> values that uses
--   cheap pointer equality checks to reduce the amount of signal
--   propagation needed.
module Reflex.Dynamic.Uniq

-- | A <a>Dynamic</a> whose <a>updated</a> <a>Event</a> will never fire
--   with the same value as the <a>current</a> <tt>Behavior'</tt>s
--   contents. In order to maintain this constraint, the value inside a
--   <a>UniqDynamic</a> is always evaluated to <a>weak head normal
--   form</a>.
--   
--   Internally, <a>UniqDynamic</a> uses pointer equality as a heuristic to
--   avoid unnecessary update propagation; this is much more efficient than
--   performing full comparisons. However, when the <a>UniqDynamic</a> is
--   converted back into a regular <a>Dynamic</a>, a full comparison is
--   performed.
data UniqDynamic t a

-- | Construct a <a>UniqDynamic</a> by eliminating redundant updates from a
--   <a>Dynamic</a>.
uniqDynamic :: Reflex t => Dynamic t a -> UniqDynamic t a

-- | Retrieve a normal <a>Dynamic</a> from a <a>UniqDynamic</a>. This will
--   perform a final check using the output type's <a>Eq</a> instance to
--   ensure deterministic behavior.
--   
--   WARNING: If used with a type whose <a>Eq</a> instance is not
--   law-abiding - specifically, if there are cases where <tt>x /= x</tt>,
--   <a>fromUniqDynamic</a> may eliminate more <a>updated</a> occurrences
--   than it should. For example, NaN values of <a>Double</a> and
--   <a>Float</a> are considered unequal to themselves by the <a>Eq</a>
--   instance, but can be equal by pointer equality. This may cause
--   <a>UniqDynamic</a> to lose changes from NaN to NaN.
fromUniqDynamic :: (Reflex t, Eq a) => UniqDynamic t a -> Dynamic t a

-- | Create a UniqDynamic without uniqing it on creation. This will be
--   slightly faster than uniqDynamic when used with a Dynamic whose values
--   are always (or nearly always) different from its previous values; if
--   used with a Dynamic whose values do not change frequently, it may be
--   much slower than uniqDynamic
alreadyUniqDynamic :: Dynamic t a -> UniqDynamic t a
instance Reflex.Class.Reflex t => Reflex.Class.Accumulator t (Reflex.Dynamic.Uniq.UniqDynamic t)
instance Reflex.Class.Reflex t => GHC.Base.Functor (Reflex.Dynamic.Uniq.UniqDynamic t)
instance Reflex.Class.Reflex t => GHC.Base.Applicative (Reflex.Dynamic.Uniq.UniqDynamic t)
instance Reflex.Class.Reflex t => GHC.Base.Monad (Reflex.Dynamic.Uniq.UniqDynamic t)


-- | This module provides the interface for hosting <a>Reflex</a> engines.
--   This should only be necessary if you're writing a binding or some
--   other library that provides a core event loop.
module Reflex.Host.Class

-- | Framework implementation support class for the reflex implementation
--   represented by <tt>t</tt>.
class (Reflex t, MonadReflexCreateTrigger t (HostFrame t), MonadSample t (HostFrame t), MonadHold t (HostFrame t), MonadFix (HostFrame t), MonadSubscribeEvent t (HostFrame t)) => ReflexHost t where type EventTrigger t :: * -> * type EventHandle t :: * -> * type HostFrame t :: * -> * where {
    type family EventTrigger t :: * -> *;
    type family EventHandle t :: * -> *;
    type family HostFrame t :: * -> *;
}

-- | Monad in which Events can be <tt>subscribed</tt>. This forces all
--   underlying event sources to be initialized, so that the event will
--   fire whenever it ought to. Events must be subscribed before they are
--   read using readEvent
class (Reflex t, Monad m) => MonadSubscribeEvent t m | m -> t

-- | Subscribe to an event and set it up if needed.
--   
--   This function will create a new <a>EventHandle</a> from an
--   <a>Event</a>. This handle may then be used via <a>readEvent</a> in the
--   read callback of <a>fireEventsAndRead</a>.
--   
--   If the event wasn't subscribed to before (either manually or through a
--   dependent event or behavior) then this function will cause the event
--   and all dependencies of this event to be set up. For example, if the
--   event was created by <a>newEventWithTrigger</a>, then it's callback
--   will be executed.
--   
--   It's safe to call this function multiple times.
subscribeEvent :: MonadSubscribeEvent t m => Event t a -> m (EventHandle t a)

-- | Monad that allows to read events' values.
class (ReflexHost t, Applicative m, Monad m) => MonadReadEvent t m | m -> t

-- | Read the value of an <a>Event</a> from an <a>EventHandle</a> (created
--   by calling <a>subscribeEvent</a>).
--   
--   After event propagation is done, all events can be in two states:
--   either they are firing with some value or they are not firing. In the
--   former case, this function returns <tt>Just act</tt>, where
--   <tt>act</tt> in an action to read the current value of the event. In
--   the latter case, the function returns <tt>Nothing</tt>.
--   
--   This function is normally used in the calllback for
--   <a>fireEventsAndRead</a>.
readEvent :: MonadReadEvent t m => EventHandle t a -> m (Maybe (m a))

-- | A monad where new events feed from external sources can be created.
class (Applicative m, Monad m) => MonadReflexCreateTrigger t m | m -> t

-- | Creates a root <a>Event</a> (one that is not based on any other
--   event).
--   
--   When a subscriber first subscribes to an event (building another event
--   that depends on the subscription) the given callback function is run
--   and passed a trigger. The callback function can then set up the event
--   source in IO. After this is done, the callback function must return an
--   accompanying teardown action.
--   
--   Any time between setup and teardown the trigger can be used to fire
--   the event, by passing it to <a>fireEventsAndRead</a>.
--   
--   Note: An event may be set up multiple times. So after the teardown
--   action is executed, the event may still be set up again in the future.
newEventWithTrigger :: MonadReflexCreateTrigger t m => (EventTrigger t a -> IO (IO ())) -> m (Event t a)
newFanEventWithTrigger :: (MonadReflexCreateTrigger t m, GCompare k) => (forall a. k a -> EventTrigger t a -> IO (IO ())) -> m (EventSelector t k)

-- | <a>MonadReflexHost</a> designates monads that can run reflex frames.
class (ReflexHost t, MonadReflexCreateTrigger t m, MonadSubscribeEvent t m, MonadReadEvent t (ReadPhase m), MonadSample t (ReadPhase m), MonadHold t (ReadPhase m)) => MonadReflexHost t m | m -> t where type ReadPhase m :: * -> * where {
    type family ReadPhase m :: * -> *;
}

-- | Propagate some events firings and read the values of events
--   afterwards.
--   
--   This function will create a new frame to fire the given events. It
--   will then update all dependent events and behaviors. After that is
--   done, the given callback is executed which allows to read the final
--   values of events and check whether they have fired in this frame or
--   not.
--   
--   All events that are given are fired at the same time.
--   
--   This function is typically used in the main loop of a reflex framework
--   implementation. The main loop waits for external events to happen
--   (such as keyboard input or a mouse click) and then fires the
--   corresponding events using this function. The read callback can be
--   used to read output events and perform a corresponding response action
--   to the external event.
fireEventsAndRead :: MonadReflexHost t m => [DSum (EventTrigger t) Identity] -> ReadPhase m a -> m a

-- | Run a frame without any events firing.
--   
--   This function should be used when you want to use <a>sample</a> and
--   <a>hold</a> when no events are currently firing. Using this function
--   in that case can improve performance, since the implementation can
--   assume that no events are firing when <a>sample</a> or <a>hold</a> are
--   called.
--   
--   This function is commonly used to set up the basic event network when
--   the application starts up.
runHostFrame :: MonadReflexHost t m => HostFrame t a -> m a

-- | Like <a>fireEventsAndRead</a>, but without reading any events.
fireEvents :: MonadReflexHost t m => [DSum (EventTrigger t) Identity] -> m ()

-- | Create a new event and store its trigger in an <tt>IORef</tt> while
--   it's active.
--   
--   An event is only active between the set up (when it's first subscribed
--   to) and the teardown phases (when noboby is subscribing the event
--   anymore). This function returns an Event and an <tt>IORef</tt>. As
--   long as the event is active, the <tt>IORef</tt> will contain
--   <a>Just</a> the event trigger to trigger this event. When the event is
--   not active, the <tt>IORef</tt> will contain <a>Nothing</a>. This
--   allows event sources to be more efficient, since they don't need to
--   produce events when nobody is listening.
newEventWithTriggerRef :: (MonadReflexCreateTrigger t m, MonadRef m, Ref m ~ Ref IO) => m (Event t a, Ref m (Maybe (EventTrigger t a)))

-- | Fire the given trigger if it is not <a>Nothing</a>.
fireEventRef :: (MonadReflexHost t m, MonadRef m, Ref m ~ Ref IO) => Ref m (Maybe (EventTrigger t a)) -> a -> m ()

-- | Fire the given trigger if it is not <a>Nothing</a>, and read from the
--   given <a>EventHandle</a>.
fireEventRefAndRead :: (MonadReflexHost t m, MonadRef m, Ref m ~ Ref IO) => Ref m (Maybe (EventTrigger t a)) -> a -> EventHandle t b -> m (Maybe b)
instance Reflex.Host.Class.MonadReflexCreateTrigger t m => Reflex.Host.Class.MonadReflexCreateTrigger t (Control.Monad.Trans.Reader.ReaderT r m)
instance Reflex.Host.Class.MonadSubscribeEvent t m => Reflex.Host.Class.MonadSubscribeEvent t (Control.Monad.Trans.Reader.ReaderT r m)
instance Reflex.Host.Class.MonadReflexHost t m => Reflex.Host.Class.MonadReflexHost t (Control.Monad.Trans.Reader.ReaderT r m)
instance (Reflex.Host.Class.MonadReflexCreateTrigger t m, GHC.Base.Monoid w) => Reflex.Host.Class.MonadReflexCreateTrigger t (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (Reflex.Host.Class.MonadSubscribeEvent t m, GHC.Base.Monoid w) => Reflex.Host.Class.MonadSubscribeEvent t (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (Reflex.Host.Class.MonadReflexHost t m, GHC.Base.Monoid w) => Reflex.Host.Class.MonadReflexHost t (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance Reflex.Host.Class.MonadReflexCreateTrigger t m => Reflex.Host.Class.MonadReflexCreateTrigger t (Control.Monad.Trans.State.Lazy.StateT s m)
instance Reflex.Host.Class.MonadSubscribeEvent t m => Reflex.Host.Class.MonadSubscribeEvent t (Control.Monad.Trans.State.Lazy.StateT r m)
instance Reflex.Host.Class.MonadReflexHost t m => Reflex.Host.Class.MonadReflexHost t (Control.Monad.Trans.State.Lazy.StateT s m)
instance Reflex.Host.Class.MonadReflexCreateTrigger t m => Reflex.Host.Class.MonadReflexCreateTrigger t (Control.Monad.Trans.State.Strict.StateT s m)
instance Reflex.Host.Class.MonadSubscribeEvent t m => Reflex.Host.Class.MonadSubscribeEvent t (Control.Monad.Trans.State.Strict.StateT r m)
instance Reflex.Host.Class.MonadReflexHost t m => Reflex.Host.Class.MonadReflexHost t (Control.Monad.Trans.State.Strict.StateT s m)
instance Reflex.Host.Class.MonadReflexCreateTrigger t m => Reflex.Host.Class.MonadReflexCreateTrigger t (Control.Monad.Trans.Cont.ContT r m)
instance Reflex.Host.Class.MonadSubscribeEvent t m => Reflex.Host.Class.MonadSubscribeEvent t (Control.Monad.Trans.Cont.ContT r m)
instance Reflex.Host.Class.MonadReflexHost t m => Reflex.Host.Class.MonadReflexHost t (Control.Monad.Trans.Cont.ContT r m)
instance Reflex.Host.Class.MonadReflexCreateTrigger t m => Reflex.Host.Class.MonadReflexCreateTrigger t (Control.Monad.Trans.Except.ExceptT e m)
instance Reflex.Host.Class.MonadSubscribeEvent t m => Reflex.Host.Class.MonadSubscribeEvent t (Control.Monad.Trans.Except.ExceptT r m)
instance Reflex.Host.Class.MonadReflexHost t m => Reflex.Host.Class.MonadReflexHost t (Control.Monad.Trans.Except.ExceptT e m)
instance (Reflex.Host.Class.MonadReflexCreateTrigger t m, GHC.Base.Monoid w) => Reflex.Host.Class.MonadReflexCreateTrigger t (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (Reflex.Host.Class.MonadSubscribeEvent t m, GHC.Base.Monoid w) => Reflex.Host.Class.MonadSubscribeEvent t (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (Reflex.Host.Class.MonadReflexHost t m, GHC.Base.Monoid w) => Reflex.Host.Class.MonadReflexHost t (Control.Monad.Trans.RWS.Lazy.RWST r w s m)


-- | This module defines <a>PostBuild</a>, which indicates that an action
--   will be notified when it, and any action it's a part of, has finished
--   executing.
module Reflex.PostBuild.Class

-- | <a>PostBuild</a> represents an action that is notified via an
--   <a>Event</a> when it has finished executing. Note that the specific
--   definition of "finished" is determined by the instance of
--   <a>PostBuild</a>, but the intent is to allow <a>Behavior</a>s and
--   <a>Dynamic</a>s to be safely sampled, regardless of where they were
--   created, when the post-build <a>Event</a> fires. The post-build
--   <a>Event</a> will fire exactly once for an given action.
class (Reflex t, Monad m) => PostBuild t m | m -> t

-- | Retrieve the post-build <a>Event</a> for this action.
getPostBuild :: PostBuild t m => m (Event t ())
instance Reflex.PostBuild.Class.PostBuild t m => Reflex.PostBuild.Class.PostBuild t (Control.Monad.Trans.Reader.ReaderT r m)
instance Reflex.PostBuild.Class.PostBuild t m => Reflex.PostBuild.Class.PostBuild t (Control.Monad.Trans.State.Lazy.StateT s m)
instance Reflex.PostBuild.Class.PostBuild t m => Reflex.PostBuild.Class.PostBuild t (Control.Monad.Trans.State.Strict.StateT s m)

module Reflex.Collection
listHoldWithKey :: forall t m k v a. (Ord k, Adjustable t m, MonadHold t m) => Map k v -> Event t (Map k (Maybe v)) -> (k -> v -> m a) -> m (Dynamic t (Map k a))
listWithKey :: forall t k v m a. (Ord k, Adjustable t m, PostBuild t m, MonadFix m, MonadHold t m) => Dynamic t (Map k v) -> (k -> Dynamic t v -> m a) -> m (Dynamic t (Map k a))

-- | <i>Deprecated: listWithKey' has been renamed to
--   listWithKeyShallowDiff; also, its behavior has changed to fix a bug
--   where children were always rebuilt (never updated)</i>
listWithKey' :: (Ord k, Adjustable t m, MonadFix m, MonadHold t m) => Map k v -> Event t (Map k (Maybe v)) -> (k -> v -> Event t v -> m a) -> m (Dynamic t (Map k a))

-- | Display the given map of items (in key order) using the builder
--   function provided, and update it with the given event. <a>Nothing</a>
--   update entries will delete the corresponding children, and <a>Just</a>
--   entries will create them if they do not exist or send an update event
--   to them if they do.
listWithKeyShallowDiff :: (Ord k, Adjustable t m, MonadFix m, MonadHold t m) => Map k v -> Event t (Map k (Maybe v)) -> (k -> v -> Event t v -> m a) -> m (Dynamic t (Map k a))

-- | Create a dynamically-changing set of Event-valued widgets. This is
--   like listWithKey, specialized for widgets returning (Event t a).
--   listWithKey would return 'Dynamic t (Map k (Event t a))' in this
--   scenario, but listViewWithKey flattens this to 'Event t (Map k a)' via
--   <a>switch</a>.
listViewWithKey :: (Ord k, Adjustable t m, PostBuild t m, MonadHold t m, MonadFix m) => Dynamic t (Map k v) -> (k -> Dynamic t v -> m (Event t a)) -> m (Event t (Map k a))

-- | Create a dynamically-changing set of widgets, one of which is selected
--   at any time.
selectViewListWithKey :: forall t m k v a. (Adjustable t m, Ord k, PostBuild t m, MonadHold t m, MonadFix m) => Dynamic t k -> Dynamic t (Map k v) -> (k -> Dynamic t v -> Dynamic t Bool -> m (Event t a)) -> m (Event t (k, a))
selectViewListWithKey_ :: forall t m k v a. (Adjustable t m, Ord k, PostBuild t m, MonadHold t m, MonadFix m) => Dynamic t k -> Dynamic t (Map k v) -> (k -> Dynamic t v -> Dynamic t Bool -> m (Event t a)) -> m (Event t k)

-- | Create a dynamically-changing set of widgets from a Dynamic key/value
--   map. Unlike the <tt>withKey</tt> variants, the child widgets are
--   insensitive to which key they're associated with.
list :: (Ord k, Adjustable t m, MonadHold t m, PostBuild t m, MonadFix m) => Dynamic t (Map k v) -> (Dynamic t v -> m a) -> m (Dynamic t (Map k a))

-- | Create a dynamically-changing set of widgets from a Dynamic list.
simpleList :: (Adjustable t m, MonadHold t m, PostBuild t m, MonadFix m) => Dynamic t [v] -> (Dynamic t v -> m a) -> m (Dynamic t [a])


-- | This module provides a pure implementation of Reflex, which is
--   intended to serve as a reference for the semantics of the Reflex
--   class. All implementations of Reflex should produce the same results
--   as this implementation, although performance and laziness/strictness
--   may differ.
module Reflex.Pure

-- | A completely pure-functional <a>Reflex</a> timeline, identifying
--   moments in time with the type <tt>t</tt>.
data Pure t
instance (GHC.Enum.Enum t, Data.MemoTrie.HasTrie t, GHC.Classes.Ord t) => Reflex.Class.Reflex (Reflex.Pure.Pure t)
instance GHC.Base.Functor (Reflex.Class.Dynamic (Reflex.Pure.Pure t))
instance GHC.Base.Applicative (Reflex.Class.Dynamic (Reflex.Pure.Pure t))
instance GHC.Base.Monad (Reflex.Class.Dynamic (Reflex.Pure.Pure t))
instance Reflex.Class.MonadSample (Reflex.Pure.Pure t) ((->) t)
instance (GHC.Enum.Enum t, Data.MemoTrie.HasTrie t, GHC.Classes.Ord t) => Reflex.Class.MonadHold (Reflex.Pure.Pure t) ((->) t)

module Reflex.Query.Class
class (Monoid (QueryResult a), Semigroup (QueryResult a)) => Query a where type QueryResult a :: * where {
    type family QueryResult a :: *;
}
crop :: Query a => a -> QueryResult a -> QueryResult a

-- | NB: QueryMorphism's must be group homomorphisms when acting on the
--   query type and compatible with the query relationship when acting on
--   the query result
data QueryMorphism q q'
QueryMorphism :: (q -> q') -> (QueryResult q' -> QueryResult q) -> QueryMorphism q q'
[_queryMorphism_mapQuery] :: QueryMorphism q q' -> q -> q'
[_queryMorphism_mapQueryResult] :: QueryMorphism q q' -> QueryResult q' -> QueryResult q

-- | This type keeps track of the multiplicity of elements of the view
--   selector that are being used by the app
newtype SelectedCount
SelectedCount :: Int -> SelectedCount
[unSelectedCount] :: SelectedCount -> Int

-- | The Semigroup<i>Monoid</i>Group instances for a ViewSelector should
--   use this function which returns Nothing if the result is 0. This
--   allows the pruning of leaves that are no longer wanted.
combineSelectedCounts :: SelectedCount -> SelectedCount -> Maybe SelectedCount
class (Group q, Additive q, Query q) => MonadQuery t q m | m -> q t
tellQueryIncremental :: MonadQuery t q m => Incremental t (AdditivePatch q) -> m ()
askQueryResult :: MonadQuery t q m => m (Dynamic t (QueryResult q))
queryIncremental :: MonadQuery t q m => Incremental t (AdditivePatch q) -> m (Dynamic t (QueryResult q))
tellQueryDyn :: (Reflex t, MonadQuery t q m) => Dynamic t q -> m ()
queryDyn :: (Reflex t, Monad m, MonadQuery t q m) => Dynamic t q -> m (Dynamic t (QueryResult q))
instance Data.Data.Data Reflex.Query.Class.SelectedCount
instance Foreign.Storable.Storable Reflex.Query.Class.SelectedCount
instance Data.Bits.FiniteBits Reflex.Query.Class.SelectedCount
instance Data.Bits.Bits Reflex.Query.Class.SelectedCount
instance GHC.Arr.Ix Reflex.Query.Class.SelectedCount
instance GHC.Real.Real Reflex.Query.Class.SelectedCount
instance GHC.Enum.Enum Reflex.Query.Class.SelectedCount
instance GHC.Enum.Bounded Reflex.Query.Class.SelectedCount
instance GHC.Num.Num Reflex.Query.Class.SelectedCount
instance GHC.Real.Integral Reflex.Query.Class.SelectedCount
instance GHC.Read.Read Reflex.Query.Class.SelectedCount
instance GHC.Show.Show Reflex.Query.Class.SelectedCount
instance GHC.Classes.Ord Reflex.Query.Class.SelectedCount
instance GHC.Classes.Eq Reflex.Query.Class.SelectedCount
instance Data.Semigroup.Semigroup Reflex.Query.Class.SelectedCount
instance GHC.Base.Monoid Reflex.Query.Class.SelectedCount
instance Reflex.Patch.Group Reflex.Query.Class.SelectedCount
instance Reflex.Patch.Additive Reflex.Query.Class.SelectedCount
instance (GHC.Base.Monad m, Reflex.Query.Class.MonadQuery t q m) => Reflex.Query.Class.MonadQuery t q (Control.Monad.Trans.Reader.ReaderT r m)


-- | This module defines <a>Requester</a>, which indicates that an action
--   can make requests and receive responses to them. Typically, this is
--   used for things like a WebSocket, where it's desirable to collect many
--   potential sources of events and send them over a single channel, then
--   distribute the results back out efficiently to their original request
--   sites.
module Reflex.Requester.Class

-- | A <a>Requester</a> action can trigger requests of type <tt>Request m
--   a</tt> based on <a>Event</a>s, and receive responses of type
--   <tt>Response m a</tt> in return. Note that the <tt>a</tt> type can
--   vary within the <a>Requester</a> action, but will be linked for a
--   given request. For example, if <tt>Request m</tt> is <a>IO</a> and
--   <tt>Response m</tt> is <a>Identity</a>, then <a>requestingIdentity</a>
--   has the same type as <a>performEvent</a>.
class (Reflex t, Monad m) => Requester t m | m -> t where type Request m :: * -> * type Response m :: * -> * where {
    type family Request m :: * -> *;
    type family Response m :: * -> *;
}

-- | Emit a request whenever the given <a>Event</a> fires, and return
--   responses in the resulting <a>Event</a>.
requesting :: Requester t m => Event t (Request m a) -> m (Event t (Response m a))

-- | Emit a request whenever the given <a>Event</a> fires, and ignore all
--   responses.
requesting_ :: Requester t m => Event t (Request m a) -> m ()
withRequesting :: (Requester t m, MonadFix m) => (Event t (Response m a) -> m (Event t (Request m a), r)) -> m r

-- | Emit a request whenever the given <a>Event</a> fires, and unwrap the
--   responses before returning them. <tt>Response m</tt> must be
--   <a>Identity</a>.
requestingIdentity :: (Requester t m, Response m ~ Identity) => Event t (Request m a) -> m (Event t a)
instance Reflex.Requester.Class.Requester t m => Reflex.Requester.Class.Requester t (Control.Monad.Trans.Reader.ReaderT r m)
instance Reflex.Requester.Class.Requester t m => Reflex.Requester.Class.Requester t (Control.Monad.Trans.State.Strict.StateT s m)
instance Reflex.Requester.Class.Requester t m => Reflex.Requester.Class.Requester t (Control.Monad.Trans.State.Lazy.StateT s m)


-- | This module defines <a>TriggerEvent</a>, which describes actions that
--   may create new <a>Event</a>s that can be triggered from <a>IO</a>.
module Reflex.TriggerEvent.Class

-- | <a>TriggerEvent</a> represents actions that can create <a>Event</a>s
--   that can be triggered by <a>IO</a> actions.
class Monad m => TriggerEvent t m | m -> t

-- | Create a triggerable <a>Event</a>. Whenever the resulting function is
--   called, the resulting <a>Event</a> will fire at some point in the
--   future. Note that this may not be synchronous.
newTriggerEvent :: TriggerEvent t m => m (Event t a, a -> IO ())

-- | Like <a>newTriggerEvent</a>, but the callback itself takes another
--   callback, to be invoked once the requested <a>Event</a> occurrence has
--   finished firing. This allows synchronous operation.
newTriggerEventWithOnComplete :: TriggerEvent t m => m (Event t a, a -> IO () -> IO ())

-- | Like <a>newTriggerEventWithOnComplete</a>, but with setup and
--   teardown. This relatively complex type signature allows any external
--   listeners to be subscribed lazily and then removed whenever the
--   returned <a>Event</a> is no longer being listened to. Note that the
--   setup/teardown may happen multiple times, and there is no guarantee
--   that the teardown will be executed promptly, or even at all, in the
--   case of program termination.
newEventWithLazyTriggerWithOnComplete :: TriggerEvent t m => ((a -> IO () -> IO ()) -> IO (IO ())) -> m (Event t a)
instance Reflex.TriggerEvent.Class.TriggerEvent t m => Reflex.TriggerEvent.Class.TriggerEvent t (Control.Monad.Trans.Reader.ReaderT r m)
instance Reflex.TriggerEvent.Class.TriggerEvent t m => Reflex.TriggerEvent.Class.TriggerEvent t (Control.Monad.Trans.State.Lazy.StateT s m)
instance Reflex.TriggerEvent.Class.TriggerEvent t m => Reflex.TriggerEvent.Class.TriggerEvent t (Control.Monad.Trans.State.Strict.StateT s m)


-- | This module defines <a>PerformEvent</a> and <a>TriggerEvent</a>, which
--   mediate the interaction between a <a>Reflex</a>-based program and the
--   external side-effecting actions such as <a>IO</a>.
module Reflex.PerformEvent.Class

-- | <a>PerformEvent</a> represents actions that can trigger other actions
--   based on <a>Event</a>s.
class (Reflex t, Monad (Performable m), Monad m) => PerformEvent t m | m -> t where type Performable m :: * -> * where {
    type family Performable m :: * -> *;
}

-- | Perform the action contained in the given <a>Event</a> whenever the
--   <a>Event</a> fires. Return the result in another <a>Event</a>. Note
--   that the output <a>Event</a> will generally occur later than the input
--   <a>Event</a>, since most <a>Performable</a> actions cannot be
--   performed during <a>Event</a> propagation.
performEvent :: PerformEvent t m => Event t (Performable m a) -> m (Event t a)

-- | Like <a>performEvent</a>, but do not return the result. May have
--   slightly better performance.
performEvent_ :: PerformEvent t m => Event t (Performable m ()) -> m ()

-- | Like <a>performEvent</a>, but the resulting <a>Event</a> occurs only
--   when the callback (<tt>a -&gt; IO ()</tt>) is called, not when the
--   included action finishes.
--   
--   NOTE: Despite the name, <a>performEventAsync</a> does not run its
--   action in a separate thread - although the action is free to invoke
--   forkIO and then call the callback whenever it is ready. This will work
--   properly, even in GHCJS (which fully implements concurrency even
--   though JavaScript does not have built in concurrency).
performEventAsync :: (TriggerEvent t m, PerformEvent t m) => Event t ((a -> IO ()) -> Performable m ()) -> m (Event t a)
instance Reflex.PerformEvent.Class.PerformEvent t m => Reflex.PerformEvent.Class.PerformEvent t (Control.Monad.Trans.Reader.ReaderT r m)


-- | This module provides <a>EventWriterT</a>, the standard implementation
--   of <a>EventWriter</a>.
module Reflex.EventWriter

-- | A basic implementation of <a>EventWriter</a>.
newtype EventWriterT t w m a
EventWriterT :: StateT (EventWriterState t w) m a -> EventWriterT t w m a
[unEventWriterT] :: EventWriterT t w m a -> StateT (EventWriterState t w) m a

-- | Run a <a>EventWriterT</a> action.
runEventWriterT :: forall t m w a. (Reflex t, Monad m, Semigroup w) => EventWriterT t w m a -> m (a, Event t w)

-- | <a>EventWriter</a> efficiently collects <a>Event</a> values using
--   <a>tellEvent</a> and combines them monoidally to provide an
--   <a>Event</a> result.
class (Monad m, Semigroup w) => EventWriter t w m | m -> t w
tellEvent :: EventWriter t w m => Event t w -> m ()

-- | Given a function like <a>runWithReplace</a> for the underlying monad,
--   implement <a>runWithReplace</a> for <a>EventWriterT</a>. This is
--   necessary when the underlying monad doesn't have a <a>Adjustable</a>
--   instance or to override the default <a>Adjustable</a> behavior.
runWithReplaceEventWriterTWith :: forall m t w a b. (Reflex t, MonadHold t m, Semigroup w) => (forall a' b'. m a' -> Event t (m b') -> EventWriterT t w m (a', Event t b')) -> EventWriterT t w m a -> Event t (EventWriterT t w m b) -> EventWriterT t w m (a, Event t b)

-- | Like <a>runWithReplaceEventWriterTWith</a>, but for
--   <a>sequenceDMapWithAdjust</a>.
sequenceDMapWithAdjustEventWriterTWith :: forall t m p p' w k v v'. (Reflex t, MonadHold t m, Semigroup w, Patch (p' (Some k) (Event t w)), PatchTarget (p' (Some k) (Event t w)) ~ Map (Some k) (Event t w)) => ((forall a. k a -> v a -> m (Compose ((,) (Event t w)) v' a)) -> DMap k v -> Event t (p k v) -> EventWriterT t w m (DMap k (Compose ((,) (Event t w)) v'), Event t (p k (Compose ((,) (Event t w)) v')))) -> ((forall a. Compose ((,) (Event t w)) v' a -> v' a) -> p k (Compose ((,) (Event t w)) v') -> p k v') -> ((forall a. Compose ((,) (Event t w)) v' a -> Event t w) -> p k (Compose ((,) (Event t w)) v') -> p' (Some k) (Event t w)) -> (p' (Some k) (Event t w) -> [Event t w]) -> (Incremental t (p' (Some k) (Event t w)) -> Event t (Map (Some k) w)) -> (forall a. k a -> v a -> EventWriterT t w m (v' a)) -> DMap k v -> Event t (p k v) -> EventWriterT t w m (DMap k v', Event t (p k v'))

-- | Map a function over the output of a <a>EventWriterT</a>.
withEventWriterT :: (Semigroup w, Semigroup w', Reflex t, MonadHold t m, MonadFix m) => (w -> w') -> EventWriterT t w m a -> EventWriterT t w' m a
instance Control.Monad.Exception.MonadAsyncException m => Control.Monad.Exception.MonadAsyncException (Reflex.EventWriter.EventWriterT t w m)
instance Control.Monad.Exception.MonadException m => Control.Monad.Exception.MonadException (Reflex.EventWriter.EventWriterT t w m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Reflex.EventWriter.EventWriterT t w m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Reflex.EventWriter.EventWriterT t w m)
instance GHC.Base.Monad m => GHC.Base.Monad (Reflex.EventWriter.EventWriterT t w m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Reflex.EventWriter.EventWriterT t w m)
instance GHC.Base.Functor m => GHC.Base.Functor (Reflex.EventWriter.EventWriterT t w m)
instance GHC.Enum.Enum (Reflex.EventWriter.TellId w x)
instance GHC.Classes.Ord (Reflex.EventWriter.TellId w x)
instance GHC.Classes.Eq (Reflex.EventWriter.TellId w x)
instance GHC.Show.Show (Reflex.EventWriter.TellId w x)
instance Data.GADT.Compare.GEq (Reflex.EventWriter.TellId w)
instance Data.GADT.Compare.GCompare (Reflex.EventWriter.TellId w)
instance (Reflex.Class.Reflex t, GHC.Base.Monad m, Data.Semigroup.Semigroup w) => Reflex.EventWriter.EventWriter t w (Reflex.EventWriter.EventWriterT t w m)
instance Reflex.EventWriter.EventWriter t w m => Reflex.EventWriter.EventWriter t w (Control.Monad.Trans.Reader.ReaderT r m)
instance Control.Monad.Trans.Class.MonadTrans (Reflex.EventWriter.EventWriterT t w)
instance Reflex.Class.MonadSample t m => Reflex.Class.MonadSample t (Reflex.EventWriter.EventWriterT t w m)
instance Reflex.Class.MonadHold t m => Reflex.Class.MonadHold t (Reflex.EventWriter.EventWriterT t w m)
instance (Reflex.Class.Reflex t, Reflex.Class.Adjustable t m, Reflex.Class.MonadHold t m, Data.Semigroup.Semigroup w) => Reflex.Class.Adjustable t (Reflex.EventWriter.EventWriterT t w m)
instance Reflex.Requester.Class.Requester t m => Reflex.Requester.Class.Requester t (Reflex.EventWriter.EventWriterT t w m)
instance Reflex.PerformEvent.Class.PerformEvent t m => Reflex.PerformEvent.Class.PerformEvent t (Reflex.EventWriter.EventWriterT t w m)
instance Reflex.PostBuild.Class.PostBuild t m => Reflex.PostBuild.Class.PostBuild t (Reflex.EventWriter.EventWriterT t w m)
instance Reflex.TriggerEvent.Class.TriggerEvent t m => Reflex.TriggerEvent.Class.TriggerEvent t (Reflex.EventWriter.EventWriterT t w m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Reflex.EventWriter.EventWriterT t w m)
instance Control.Monad.Ref.MonadRef m => Control.Monad.Ref.MonadRef (Reflex.EventWriter.EventWriterT t w m)
instance Control.Monad.Ref.MonadAtomicRef m => Control.Monad.Ref.MonadAtomicRef (Reflex.EventWriter.EventWriterT t w m)
instance Reflex.Host.Class.MonadReflexCreateTrigger t m => Reflex.Host.Class.MonadReflexCreateTrigger t (Reflex.EventWriter.EventWriterT t w m)
instance (Reflex.Query.Class.MonadQuery t q m, GHC.Base.Monad m) => Reflex.Query.Class.MonadQuery t q (Reflex.EventWriter.EventWriterT t w m)


-- | This module defines <a>PostBuildT</a>, the standard implementation of
--   <a>PostBuild</a>.
module Reflex.PostBuild.Base

-- | Provides a basic implementation of <a>PostBuild</a>.
newtype PostBuildT t m a
PostBuildT :: ReaderT (Event t ()) m a -> PostBuildT t m a
[unPostBuildT] :: PostBuildT t m a -> ReaderT (Event t ()) m a

-- | Run a <a>PostBuildT</a> action. An <a>Event</a> should be provided
--   that fires immediately after the action is finished running; no other
--   <a>Event</a>s should fire first.
runPostBuildT :: PostBuildT t m a -> Event t () -> m a
mapIntMapWithAdjustImpl :: forall t m v v' p. (Reflex t, MonadFix m, MonadHold t m, Functor p) => ((Key -> (Event t (), v) -> m v') -> IntMap (Event t (), v) -> Event t (p (Event t (), v)) -> m (IntMap v', Event t (p v'))) -> (Key -> v -> PostBuildT t m v') -> IntMap v -> Event t (p v) -> PostBuildT t m (IntMap v', Event t (p v'))
mapDMapWithAdjustImpl :: forall t m k v v' p. (Reflex t, MonadFix m, MonadHold t m) => ((forall a. k a -> Compose ((,) (Bool, Event t ())) v a -> m (v' a)) -> DMap k (Compose ((,) (Bool, Event t ())) v) -> Event t (p k (Compose ((,) (Bool, Event t ())) v)) -> m (DMap k v', Event t (p k v'))) -> ((forall a. v a -> Compose ((,) (Bool, Event t ())) v a) -> p k v -> p k (Compose ((,) (Bool, Event t ())) v)) -> (forall a. k a -> v a -> PostBuildT t m (v' a)) -> DMap k v -> Event t (p k v) -> PostBuildT t m (DMap k v', Event t (p k v'))
instance Control.Monad.Exception.MonadAsyncException m => Control.Monad.Exception.MonadAsyncException (Reflex.PostBuild.Base.PostBuildT t m)
instance Control.Monad.Exception.MonadException m => Control.Monad.Exception.MonadException (Reflex.PostBuild.Base.PostBuildT t m)
instance Control.Monad.Trans.Class.MonadTrans (Reflex.PostBuild.Base.PostBuildT t)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Reflex.PostBuild.Base.PostBuildT t m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Reflex.PostBuild.Base.PostBuildT t m)
instance GHC.Base.Monad m => GHC.Base.Monad (Reflex.PostBuild.Base.PostBuildT t m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Reflex.PostBuild.Base.PostBuildT t m)
instance GHC.Base.Functor m => GHC.Base.Functor (Reflex.PostBuild.Base.PostBuildT t m)
instance (GHC.Base.Monoid a, GHC.Base.Applicative m) => GHC.Base.Monoid (Reflex.PostBuild.Base.PostBuildT t m a)
instance (Data.Semigroup.Semigroup a, GHC.Base.Applicative m) => Data.Semigroup.Semigroup (Reflex.PostBuild.Base.PostBuildT t m a)
instance Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Reflex.PostBuild.Base.PostBuildT x m)
instance (Reflex.Class.Reflex t, GHC.Base.Monad m) => Reflex.PostBuild.Class.PostBuild t (Reflex.PostBuild.Base.PostBuildT t m)
instance Reflex.Class.MonadSample t m => Reflex.Class.MonadSample t (Reflex.PostBuild.Base.PostBuildT t m)
instance Reflex.Class.MonadHold t m => Reflex.Class.MonadHold t (Reflex.PostBuild.Base.PostBuildT t m)
instance Reflex.PerformEvent.Class.PerformEvent t m => Reflex.PerformEvent.Class.PerformEvent t (Reflex.PostBuild.Base.PostBuildT t m)
instance (Reflex.Host.Class.ReflexHost t, Reflex.Host.Class.MonadReflexCreateTrigger t m) => Reflex.Host.Class.MonadReflexCreateTrigger t (Reflex.PostBuild.Base.PostBuildT t m)
instance Reflex.TriggerEvent.Class.TriggerEvent t m => Reflex.TriggerEvent.Class.TriggerEvent t (Reflex.PostBuild.Base.PostBuildT t m)
instance Control.Monad.Ref.MonadRef m => Control.Monad.Ref.MonadRef (Reflex.PostBuild.Base.PostBuildT t m)
instance Control.Monad.Ref.MonadAtomicRef m => Control.Monad.Ref.MonadAtomicRef (Reflex.PostBuild.Base.PostBuildT t m)
instance (Reflex.Class.Reflex t, Reflex.Class.MonadHold t m, Control.Monad.Fix.MonadFix m, Reflex.Class.Adjustable t m, Reflex.PerformEvent.Class.PerformEvent t m) => Reflex.Class.Adjustable t (Reflex.PostBuild.Base.PostBuildT t m)
instance Control.Monad.Trans.Control.MonadTransControl (Reflex.PostBuild.Base.PostBuildT t)

module Reflex.Query.Base
newtype QueryT t q m a
QueryT :: StateT [Behavior t q] (EventWriterT t q (ReaderT (Dynamic t (QueryResult q)) m)) a -> QueryT t q m a
[unQueryT] :: QueryT t q m a -> StateT [Behavior t q] (EventWriterT t q (ReaderT (Dynamic t (QueryResult q)) m)) a
runQueryT :: (MonadFix m, Additive q, Group q, Reflex t) => QueryT t q m a -> Dynamic t (QueryResult q) -> m (a, Incremental t (AdditivePatch q))
mapQuery :: QueryMorphism q q' -> q -> q'
mapQueryResult :: QueryMorphism q q' -> QueryResult q' -> QueryResult q

-- | dynWithQueryT's (Dynamic t QueryMorphism) argument needs to be a group
--   homomorphism at all times in order to behave correctly
dynWithQueryT :: (MonadFix m, PostBuild t m, Group q, Additive q, Group q', Additive q', Query q') => Dynamic t (QueryMorphism q q') -> QueryT t q m a -> QueryT t q' m a

-- | withQueryT's QueryMorphism argument needs to be a group homomorphism
--   in order to behave correctly
withQueryT :: (MonadFix m, PostBuild t m, Group q, Group q', Additive q, Additive q', Query q') => QueryMorphism q q' -> QueryT t q m a -> QueryT t q' m a
instance Control.Monad.Ref.MonadAtomicRef m => Control.Monad.Ref.MonadAtomicRef (Reflex.Query.Base.QueryT t q m)
instance Reflex.Class.MonadSample t m => Reflex.Class.MonadSample t (Reflex.Query.Base.QueryT t q m)
instance Reflex.Class.MonadHold t m => Reflex.Class.MonadHold t (Reflex.Query.Base.QueryT t q m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Reflex.Query.Base.QueryT t q m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Reflex.Query.Base.QueryT t q m)
instance Control.Monad.Exception.MonadException m => Control.Monad.Exception.MonadException (Reflex.Query.Base.QueryT t q m)
instance GHC.Base.Monad m => GHC.Base.Monad (Reflex.Query.Base.QueryT t q m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Reflex.Query.Base.QueryT t q m)
instance GHC.Base.Functor m => GHC.Base.Functor (Reflex.Query.Base.QueryT t q m)
instance (Reflex.Class.Reflex t, Control.Monad.Fix.MonadFix m, Reflex.Patch.Group q, Reflex.Patch.Additive q, Reflex.Query.Class.Query q, Reflex.Class.MonadHold t m, Reflex.Class.Adjustable t m) => Reflex.Class.Adjustable t (Reflex.Query.Base.QueryT t q m)
instance Control.Monad.Trans.Class.MonadTrans (Reflex.Query.Base.QueryT t q)
instance Reflex.PostBuild.Class.PostBuild t m => Reflex.PostBuild.Class.PostBuild t (Reflex.Query.Base.QueryT t q m)
instance Control.Monad.Exception.MonadAsyncException m => Control.Monad.Exception.MonadAsyncException (Reflex.Query.Base.QueryT t q m)
instance Reflex.TriggerEvent.Class.TriggerEvent t m => Reflex.TriggerEvent.Class.TriggerEvent t (Reflex.Query.Base.QueryT t q m)
instance Reflex.PerformEvent.Class.PerformEvent t m => Reflex.PerformEvent.Class.PerformEvent t (Reflex.Query.Base.QueryT t q m)
instance Control.Monad.Ref.MonadRef m => Control.Monad.Ref.MonadRef (Reflex.Query.Base.QueryT t q m)
instance Reflex.Host.Class.MonadReflexCreateTrigger t m => Reflex.Host.Class.MonadReflexCreateTrigger t (Reflex.Query.Base.QueryT t q m)
instance (GHC.Base.Monoid a, GHC.Base.Monad m) => GHC.Base.Monoid (Reflex.Query.Base.QueryT t q m a)
instance (Data.Semigroup.Semigroup a, GHC.Base.Monad m) => Data.Semigroup.Semigroup (Reflex.Query.Base.QueryT t q m a)
instance (GHC.Base.Monad m, Reflex.Patch.Group q, Reflex.Patch.Additive q, Reflex.Query.Class.Query q, Reflex.Class.Reflex t) => Reflex.Query.Class.MonadQuery t q (Reflex.Query.Base.QueryT t q m)
instance Reflex.Requester.Class.Requester t m => Reflex.Requester.Class.Requester t (Reflex.Query.Base.QueryT t q m)
instance Reflex.EventWriter.EventWriter t w m => Reflex.EventWriter.EventWriter t w (Reflex.Query.Base.QueryT t q m)


-- | This module provides <a>RequesterT</a>, the standard implementation of
--   <a>Requester</a>.
module Reflex.Requester.Base

-- | A basic implementation of <a>Requester</a>.
newtype RequesterT t request (response :: * -> *) m a
RequesterT :: StateT (RequesterState t request) (ReaderT (EventSelectorInt t Any) m) a -> RequesterT t request m a
[unRequesterT] :: RequesterT t request m a -> StateT (RequesterState t request) (ReaderT (EventSelectorInt t Any) m) a

-- | Run a <a>RequesterT</a> action. The resulting <a>Event</a> will fire
--   whenever requests are made, and responses should be provided in the
--   input <a>Event</a>. The <a>Tag</a> keys will be used to return the
--   responses to the same place the requests were issued.
runRequesterT :: (Reflex t, Monad m) => RequesterT t request response m a -> Event t (RequesterData response) -> m (a, Event t (RequesterData request))
runWithReplaceRequesterTWith :: forall m t request response a b. (Reflex t, MonadHold t m, MonadFix m) => (forall a' b'. m a' -> Event t (m b') -> RequesterT t request response m (a', Event t b')) -> RequesterT t request response m a -> Event t (RequesterT t request response m b) -> RequesterT t request response m (a, Event t b)
traverseIntMapWithKeyWithAdjustRequesterTWith :: forall t request response m v v' p. (Reflex t, MonadHold t m, PatchTarget (p (Event t (IntMap (RequesterData request)))) ~ IntMap (Event t (IntMap (RequesterData request))), Patch (p (Event t (IntMap (RequesterData request)))), Functor p, MonadFix m) => ((Key -> (Key, v) -> m (Event t (IntMap (RequesterData request)), v')) -> IntMap (Key, v) -> Event t (p (Key, v)) -> RequesterT t request response m (IntMap (Event t (IntMap (RequesterData request)), v'), Event t (p (Event t (IntMap (RequesterData request)), v')))) -> (p (Event t (IntMap (RequesterData request))) -> IntMap (Event t (IntMap (RequesterData request)))) -> (Incremental t (p (Event t (IntMap (RequesterData request)))) -> Event t (IntMap (IntMap (RequesterData request)))) -> (Key -> v -> RequesterT t request response m v') -> IntMap v -> Event t (p v) -> RequesterT t request response m (IntMap v', Event t (p v'))
traverseDMapWithKeyWithAdjustRequesterTWith :: forall k t request response m v v' p p'. (GCompare k, Reflex t, MonadHold t m, PatchTarget (p' (Some k) (Event t (IntMap (RequesterData request)))) ~ Map (Some k) (Event t (IntMap (RequesterData request))), Patch (p' (Some k) (Event t (IntMap (RequesterData request)))), MonadFix m) => (forall k' v1 v2. GCompare k' => (forall a. k' a -> v1 a -> m (v2 a)) -> DMap k' v1 -> Event t (p k' v1) -> RequesterT t request response m (DMap k' v2, Event t (p k' v2))) -> (forall v1 v2. (forall a. v1 a -> v2 a) -> p k v1 -> p k v2) -> (forall v1 v2. (forall a. v1 a -> v2) -> p k v1 -> p' (Some k) v2) -> (forall v2. p' (Some k) v2 -> Map (Some k) v2) -> (forall a. Incremental t (p' (Some k) (Event t a)) -> Event t (Map (Some k) a)) -> (forall a. k a -> v a -> RequesterT t request response m (v' a)) -> DMap k v -> Event t (p k v) -> RequesterT t request response m (DMap k v', Event t (p k v'))
data RequesterData f
data RequesterDataKey a

-- | Runs in reverse to accommodate for the fact that we accumulate it in
--   reverse
traverseRequesterData :: forall m request response. Applicative m => (forall a. request a -> m (response a)) -> RequesterData request -> m (RequesterData response)
requesterDataToList :: RequesterData f -> [DSum RequesterDataKey f]
singletonRequesterData :: RequesterDataKey a -> f a -> RequesterData f
instance Control.Monad.Exception.MonadAsyncException m => Control.Monad.Exception.MonadAsyncException (Reflex.Requester.Base.RequesterT t request response m)
instance Control.Monad.Exception.MonadException m => Control.Monad.Exception.MonadException (Reflex.Requester.Base.RequesterT t request response m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Reflex.Requester.Base.RequesterT t request response m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Reflex.Requester.Base.RequesterT t request response m)
instance GHC.Base.Monad m => GHC.Base.Monad (Reflex.Requester.Base.RequesterT t request response m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Reflex.Requester.Base.RequesterT t request response m)
instance GHC.Base.Functor m => GHC.Base.Functor (Reflex.Requester.Base.RequesterT t request response m)
instance GHC.Enum.Enum (Reflex.Requester.Base.MyTagWrap f x)
instance GHC.Classes.Ord (Reflex.Requester.Base.MyTagWrap f x)
instance GHC.Classes.Eq (Reflex.Requester.Base.MyTagWrap f x)
instance GHC.Show.Show (Reflex.Requester.Base.MyTagWrap f x)
instance GHC.Enum.Enum (Reflex.Requester.Base.MyTag x)
instance GHC.Classes.Ord (Reflex.Requester.Base.MyTag x)
instance GHC.Classes.Eq (Reflex.Requester.Base.MyTag x)
instance GHC.Show.Show (Reflex.Requester.Base.MyTag x)
instance Reflex.Class.MonadSample t m => Reflex.Class.MonadSample t (Reflex.Requester.Base.RequesterT t request response m)
instance Reflex.Class.MonadHold t m => Reflex.Class.MonadHold t (Reflex.Requester.Base.RequesterT t request response m)
instance Reflex.PostBuild.Class.PostBuild t m => Reflex.PostBuild.Class.PostBuild t (Reflex.Requester.Base.RequesterT t request response m)
instance Reflex.TriggerEvent.Class.TriggerEvent t m => Reflex.TriggerEvent.Class.TriggerEvent t (Reflex.Requester.Base.RequesterT t request response m)
instance Reflex.Requester.Base.MyTagTypeOffset (Reflex.Requester.Base.Single a)
instance Reflex.Requester.Base.MyTagTypeOffset Reflex.Requester.Base.Multi
instance Reflex.Requester.Base.MyTagTypeOffset (Reflex.Requester.Base.Multi2 k)
instance Reflex.Requester.Base.MyTagTypeOffset Reflex.Requester.Base.Multi3
instance Data.GADT.Compare.GEq Reflex.Requester.Base.MyTag
instance Data.GADT.Compare.GCompare Reflex.Requester.Base.MyTag
instance Data.GADT.Compare.GEq (Reflex.Requester.Base.MyTagWrap f)
instance Data.GADT.Compare.GCompare (Reflex.Requester.Base.MyTagWrap f)
instance (GHC.Base.Monoid a, GHC.Base.Monad m) => GHC.Base.Monoid (Reflex.Requester.Base.RequesterT t request response m a)
instance (Data.Semigroup.Semigroup a, GHC.Base.Monad m) => Data.Semigroup.Semigroup (Reflex.Requester.Base.RequesterT t request response m a)
instance (Reflex.Class.Reflex t, GHC.Base.Monad m) => Reflex.Requester.Class.Requester t (Reflex.Requester.Base.RequesterT t request response m)
instance Control.Monad.Trans.Class.MonadTrans (Reflex.Requester.Base.RequesterT t request response)
instance Reflex.PerformEvent.Class.PerformEvent t m => Reflex.PerformEvent.Class.PerformEvent t (Reflex.Requester.Base.RequesterT t request response m)
instance Control.Monad.Ref.MonadRef m => Control.Monad.Ref.MonadRef (Reflex.Requester.Base.RequesterT t request response m)
instance Reflex.Host.Class.MonadReflexCreateTrigger t m => Reflex.Host.Class.MonadReflexCreateTrigger t (Reflex.Requester.Base.RequesterT t request response m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Reflex.Requester.Base.RequesterT t request response m)
instance (Reflex.Class.Reflex t, Reflex.Class.Adjustable t m, Reflex.Class.MonadHold t m, Control.Monad.Fix.MonadFix m) => Reflex.Class.Adjustable t (Reflex.Requester.Base.RequesterT t request response m)


-- | This module provides <a>PerformEventT</a>, the standard implementation
--   of <a>PerformEvent</a>.
module Reflex.PerformEvent.Base

-- | Provides a basic implementation of <a>PerformEvent</a>. Note that,
--   despite the name, <a>PerformEventT</a> is not an instance of
--   <a>MonadTrans</a>.
newtype PerformEventT t m a
PerformEventT :: RequesterT t (HostFrame t) Identity (HostFrame t) a -> PerformEventT t m a
[unPerformEventT] :: PerformEventT t m a -> RequesterT t (HostFrame t) Identity (HostFrame t) a

-- | A function that fires events for the given <a>EventTrigger</a>s and
--   then runs any followup actions provided via <a>PerformEvent</a>. The
--   given <a>ReadPhase</a> action will be run once for the initial trigger
--   execution as well as once for each followup.
newtype FireCommand t m
FireCommand :: (forall a. [DSum (EventTrigger t) Identity] -> ReadPhase m a -> m [a]) -> FireCommand t m
[runFireCommand] :: FireCommand t m -> forall a. [DSum (EventTrigger t) Identity] -> ReadPhase m a -> m [a]

-- | Run a <a>PerformEventT</a> action, returning a <a>FireCommand</a> that
--   allows the caller to trigger <a>Event</a>s while ensuring that
--   <a>performEvent</a> actions are run at the appropriate time.
hostPerformEventT :: forall t m a. (Monad m, MonadSubscribeEvent t m, MonadReflexHost t m, MonadRef m, Ref m ~ Ref IO) => PerformEventT t m a -> m (a, FireCommand t m)
instance forall t k (m :: k). Reflex.Host.Class.ReflexHost t => GHC.Base.Functor (Reflex.PerformEvent.Base.PerformEventT t m)
instance forall t k (m :: k). Reflex.Host.Class.ReflexHost t => GHC.Base.Applicative (Reflex.PerformEvent.Base.PerformEventT t m)
instance forall t k (m :: k). Reflex.Host.Class.ReflexHost t => GHC.Base.Monad (Reflex.PerformEvent.Base.PerformEventT t m)
instance forall t k (m :: k). Reflex.Host.Class.ReflexHost t => Control.Monad.Fix.MonadFix (Reflex.PerformEvent.Base.PerformEventT t m)
instance forall t k (m :: k). (Reflex.Host.Class.ReflexHost t, Control.Monad.IO.Class.MonadIO (Reflex.Host.Class.HostFrame t)) => Control.Monad.IO.Class.MonadIO (Reflex.PerformEvent.Base.PerformEventT t m)
instance forall t k (m :: k). (Reflex.Host.Class.ReflexHost t, Control.Monad.Exception.MonadException (Reflex.Host.Class.HostFrame t)) => Control.Monad.Exception.MonadException (Reflex.PerformEvent.Base.PerformEventT t m)
instance (Reflex.Host.Class.ReflexHost t, GHC.Base.Applicative m, GHC.Base.Monoid a) => GHC.Base.Monoid (Reflex.PerformEvent.Base.PerformEventT t m a)
instance (Reflex.Host.Class.ReflexHost t, GHC.Base.Applicative m, Data.Semigroup.Semigroup a) => Data.Semigroup.Semigroup (Reflex.PerformEvent.Base.PerformEventT t m a)
instance forall k t (m :: k). (Control.Monad.Primitive.PrimMonad (Reflex.Host.Class.HostFrame t), Reflex.Host.Class.ReflexHost t) => Control.Monad.Primitive.PrimMonad (Reflex.PerformEvent.Base.PerformEventT t m)
instance (Reflex.Host.Class.ReflexHost t, Control.Monad.Ref.Ref m ~ Control.Monad.Ref.Ref GHC.Types.IO, Control.Monad.Primitive.PrimMonad (Reflex.Host.Class.HostFrame t)) => Reflex.PerformEvent.Class.PerformEvent t (Reflex.PerformEvent.Base.PerformEventT t m)
instance forall k t (m :: k). (Reflex.Host.Class.ReflexHost t, Control.Monad.Primitive.PrimMonad (Reflex.Host.Class.HostFrame t)) => Reflex.Class.Adjustable t (Reflex.PerformEvent.Base.PerformEventT t m)
instance forall k t (m :: k). Reflex.Host.Class.ReflexHost t => Reflex.Host.Class.MonadReflexCreateTrigger t (Reflex.PerformEvent.Base.PerformEventT t m)
instance forall k t (m :: k). Reflex.Host.Class.ReflexHost t => Reflex.Class.MonadSample t (Reflex.PerformEvent.Base.PerformEventT t m)
instance (Reflex.Host.Class.ReflexHost t, Reflex.Class.MonadHold t m) => Reflex.Class.MonadHold t (Reflex.PerformEvent.Base.PerformEventT t m)
instance forall k t (m :: k). (Control.Monad.Ref.MonadRef (Reflex.Host.Class.HostFrame t), Reflex.Host.Class.ReflexHost t) => Control.Monad.Ref.MonadRef (Reflex.PerformEvent.Base.PerformEventT t m)
instance forall k t (m :: k). (Control.Monad.Ref.MonadAtomicRef (Reflex.Host.Class.HostFrame t), Reflex.Host.Class.ReflexHost t) => Control.Monad.Ref.MonadAtomicRef (Reflex.PerformEvent.Base.PerformEventT t m)

module Reflex.Time
data TickInfo
TickInfo :: UTCTime -> Integer -> NominalDiffTime -> TickInfo

-- | UTC time immediately after the last tick.
[_tickInfo_lastUTC] :: TickInfo -> UTCTime

-- | Number of time periods since t0
[_tickInfo_n] :: TickInfo -> Integer

-- | Amount of time already elapsed in the current tick period.
[_tickInfo_alreadyElapsed] :: TickInfo -> NominalDiffTime

-- | Special case of tickLossyFrom that uses the post-build event to start
--   the tick thread.
tickLossy :: (PostBuild t m, PerformEvent t m, TriggerEvent t m, MonadIO (Performable m), MonadFix m) => NominalDiffTime -> UTCTime -> m (Event t TickInfo)

-- | Send events over time with the given basis time and interval If the
--   system starts running behind, occurrences will be dropped rather than
--   buffered Each occurrence of the resulting event will contain the index
--   of the current interval, with 0 representing the basis time
tickLossyFrom :: (PerformEvent t m, TriggerEvent t m, MonadIO (Performable m), MonadFix m) => NominalDiffTime -> UTCTime -> Event t a -> m (Event t TickInfo)

-- | Generalization of tickLossyFrom that takes dt and t0 in the event.
tickLossyFrom' :: (PerformEvent t m, TriggerEvent t m, MonadIO (Performable m), MonadFix m) => Event t (NominalDiffTime, UTCTime) -> m (Event t TickInfo)
clockLossy :: (MonadIO m, PerformEvent t m, TriggerEvent t m, MonadIO (Performable m), PostBuild t m, MonadHold t m, MonadFix m) => NominalDiffTime -> UTCTime -> m (Dynamic t TickInfo)
getCurrentTick :: NominalDiffTime -> UTCTime -> IO TickInfo

-- | Delay an Event's occurrences by a given amount in seconds.
delay :: (PerformEvent t m, TriggerEvent t m, MonadIO (Performable m)) => NominalDiffTime -> Event t a -> m (Event t a)

-- | Send events with Poisson timing with the given basis and rate Each
--   occurence of the resulting event will contain the index of the current
--   interval, with 0 representing the basis time
poissonLossyFrom :: (RandomGen g, MonadIO (Performable m), PerformEvent t m, TriggerEvent t m) => g -> Double -> UTCTime -> Event t a -> m (Event t TickInfo)

-- | Send events with Poisson timing with the given basis and rate Each
--   occurence of the resulting event will contain the index of the current
--   interval, with 0 representing the basis time. Automatically begin
--   sending events when the DOM is built
poissonLossy :: (RandomGen g, MonadIO (Performable m), PerformEvent t m, TriggerEvent t m, PostBuild t m) => g -> Double -> UTCTime -> m (Event t TickInfo)

-- | Send events with inhomogeneous Poisson timing with the given basis and
--   variable rate. Provide a maxRate that you expect to support.
inhomogeneousPoissonFrom :: (RandomGen g, MonadIO (Performable m), PerformEvent t m, TriggerEvent t m) => g -> Behavior t Double -> Double -> UTCTime -> Event t a -> m (Event t TickInfo)

-- | Send events with inhomogeneous Poisson timing with the given basis and
--   variable rate. Provide a maxRate that you expect to support
inhomogeneousPoisson :: (RandomGen g, MonadIO (Performable m), PerformEvent t m, TriggerEvent t m, PostBuild t m) => g -> Behavior t Double -> Double -> UTCTime -> m (Event t TickInfo)

-- | Block occurrences of an Event until the given number of seconds
--   elapses without the Event firing, at which point the last occurrence
--   of the Event will fire.
debounce :: (MonadFix m, MonadHold t m, PerformEvent t m, TriggerEvent t m, MonadIO (Performable m)) => NominalDiffTime -> Event t a -> m (Event t a)

-- | When the given <a>Event</a> occurs, wait the given amount of time and
--   collect all occurrences during that time. Then, fire the output
--   <a>Event</a> with the collected output.
batchOccurrences :: (MonadFix m, MonadHold t m, PerformEvent t m, TriggerEvent t m, MonadIO (Performable m)) => NominalDiffTime -> Event t a -> m (Event t (Seq a))
tickInfo_n :: Lens' TickInfo Integer
tickInfo_lastUTC :: Lens' TickInfo UTCTime
tickInfo_alreadyElapsed :: Lens' TickInfo NominalDiffTime
instance GHC.Show.Show Reflex.Time.TickInfo
instance GHC.Classes.Ord Reflex.Time.TickInfo
instance GHC.Classes.Eq Reflex.Time.TickInfo


-- | This module defines <a>TriggerEventT</a>, the standard implementation
--   of <a>TriggerEvent</a>.
module Reflex.TriggerEvent.Base

-- | A basic implementation of <a>TriggerEvent</a>.
newtype TriggerEventT t m a
TriggerEventT :: ReaderT (Chan [DSum (EventTriggerRef t) TriggerInvocation]) m a -> TriggerEventT t m a
[unTriggerEventT] :: TriggerEventT t m a -> ReaderT (Chan [DSum (EventTriggerRef t) TriggerInvocation]) m a

-- | Run a <a>TriggerEventT</a> action. The argument should be a
--   <a>Chan</a> into which <a>TriggerInvocation</a>s can be passed; it is
--   expected that some other thread will be responsible for popping values
--   out of the <a>Chan</a> and firing their <a>EventTrigger</a>s.
runTriggerEventT :: TriggerEventT t m a -> Chan [DSum (EventTriggerRef t) TriggerInvocation] -> m a

-- | Retrieve the current <a>Chan</a>; event trigger invocations pushed
--   into it will be fired.
askEvents :: Monad m => TriggerEventT t m (Chan [DSum (EventTriggerRef t) TriggerInvocation])

-- | A value with which to fire an <a>Event</a>, as well as a callback to
--   invoke after its propagation has completed.
data TriggerInvocation a
TriggerInvocation :: a -> (IO ()) -> TriggerInvocation a

-- | A reference to an <a>EventTrigger</a> suitable for firing with
--   <a>TriggerEventT</a>.
newtype EventTriggerRef t a
EventTriggerRef :: IORef (Maybe (EventTrigger t a)) -> EventTriggerRef t a
[unEventTriggerRef] :: EventTriggerRef t a -> IORef (Maybe (EventTrigger t a))
instance Control.Monad.Exception.MonadAsyncException m => Control.Monad.Exception.MonadAsyncException (Reflex.TriggerEvent.Base.TriggerEventT t m)
instance Control.Monad.Exception.MonadException m => Control.Monad.Exception.MonadException (Reflex.TriggerEvent.Base.TriggerEventT t m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Reflex.TriggerEvent.Base.TriggerEventT t m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Reflex.TriggerEvent.Base.TriggerEventT t m)
instance GHC.Base.Monad m => GHC.Base.Monad (Reflex.TriggerEvent.Base.TriggerEventT t m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Reflex.TriggerEvent.Base.TriggerEventT t m)
instance GHC.Base.Functor m => GHC.Base.Functor (Reflex.TriggerEvent.Base.TriggerEventT t m)
instance Control.Monad.Trans.Class.MonadTrans (Reflex.TriggerEvent.Base.TriggerEventT t)
instance Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Reflex.TriggerEvent.Base.TriggerEventT t m)
instance Reflex.PerformEvent.Class.PerformEvent t m => Reflex.PerformEvent.Class.PerformEvent t (Reflex.TriggerEvent.Base.TriggerEventT t m)
instance Reflex.PostBuild.Class.PostBuild t m => Reflex.PostBuild.Class.PostBuild t (Reflex.TriggerEvent.Base.TriggerEventT t m)
instance Reflex.Host.Class.MonadReflexCreateTrigger t m => Reflex.Host.Class.MonadReflexCreateTrigger t (Reflex.TriggerEvent.Base.TriggerEventT t m)
instance (GHC.Base.Monad m, Control.Monad.Ref.MonadRef m, Control.Monad.Ref.Ref m ~ Control.Monad.Ref.Ref GHC.Types.IO, Reflex.Host.Class.MonadReflexCreateTrigger t m) => Reflex.TriggerEvent.Class.TriggerEvent t (Reflex.TriggerEvent.Base.TriggerEventT t m)
instance Control.Monad.Ref.MonadRef m => Control.Monad.Ref.MonadRef (Reflex.TriggerEvent.Base.TriggerEventT t m)
instance Control.Monad.Ref.MonadAtomicRef m => Control.Monad.Ref.MonadAtomicRef (Reflex.TriggerEvent.Base.TriggerEventT t m)
instance Reflex.Class.MonadSample t m => Reflex.Class.MonadSample t (Reflex.TriggerEvent.Base.TriggerEventT t m)
instance Reflex.Class.MonadHold t m => Reflex.Class.MonadHold t (Reflex.TriggerEvent.Base.TriggerEventT t m)
instance Reflex.Class.Adjustable t m => Reflex.Class.Adjustable t (Reflex.TriggerEvent.Base.TriggerEventT t m)
instance (GHC.Base.Monoid a, GHC.Base.Applicative m) => GHC.Base.Monoid (Reflex.TriggerEvent.Base.TriggerEventT t m a)
instance (Data.Semigroup.Semigroup a, GHC.Base.Applicative m) => Data.Semigroup.Semigroup (Reflex.TriggerEvent.Base.TriggerEventT t m a)

module Reflex.Widget.Basic

-- | Build sortable content in such a way that re-sorting it can cause
--   minimal disruption to an existing context.
--   
--   Naively re-sorting a list of images would destroy every image and add
--   them back in the new order. This framework is able to avoid that by
--   preserving the identity of each image and simply moving it to the new
--   location.
--   
--   Example:
--   
--   <pre>
--   let sortByFst = buttonA $&gt; comparing fst
--       sortBySnd = buttonB $&gt; comparing snd
--       sortEvent = leftmost [sortByFst, sortBySnd]
--   sortableList
--     (\k v -&gt; text $ "\n" ++ show k ++ " " ++ v)  -- show each element on a new line
--     (Map.fromList $ zip [0..] [(3, "a"), (2, "b"), (1, "c")])
--     sortEvent
--   </pre>
sortableList :: forall t m k v a. (MonadHold t m, MonadFix m, Adjustable t m, Ord k) => (k -> v -> m a) -> Map k v -> Event t (v -> v -> Ordering) -> m (Map k a)


-- | This module defines <a>MonadDynamicWriter</a> and
--   <a>DynamicWriterT</a>, its standard implementation.
module Reflex.DynamicWriter

-- | <a>MonadDynamicWriter</a> efficiently collects <a>Dynamic</a> values
--   using <a>tellDyn</a> and combines them monoidally to provide a
--   <a>Dynamic</a> result.
class (Monad m, Monoid w) => MonadDynamicWriter t w m | m -> t w
tellDyn :: MonadDynamicWriter t w m => Dynamic t w -> m ()

-- | A basic implementation of <a>MonadDynamicWriter</a>.
newtype DynamicWriterT t w m a
DynamicWriterT :: StateT [Dynamic t w] m a -> DynamicWriterT t w m a
[unDynamicWriterT] :: DynamicWriterT t w m a -> StateT [Dynamic t w] m a

-- | Run a <a>DynamicWriterT</a> action. The dynamic writer output will be
--   provided along with the result of the action.
runDynamicWriterT :: (MonadFix m, Reflex t, Monoid w) => DynamicWriterT t w m a -> m (a, Dynamic t w)

-- | Map a function over the output of a <a>DynamicWriterT</a>.
withDynamicWriterT :: (Monoid w, Monoid w', Reflex t, MonadHold t m, MonadFix m) => (w -> w') -> DynamicWriterT t w m a -> DynamicWriterT t w' m a
instance Control.Monad.Exception.MonadException m => Control.Monad.Exception.MonadException (Reflex.DynamicWriter.DynamicWriterT t w m)
instance Control.Monad.Exception.MonadAsyncException m => Control.Monad.Exception.MonadAsyncException (Reflex.DynamicWriter.DynamicWriterT t w m)
instance Reflex.Class.MonadSample t m => Reflex.Class.MonadSample t (Reflex.DynamicWriter.DynamicWriterT t w m)
instance Reflex.Class.MonadHold t m => Reflex.Class.MonadHold t (Reflex.DynamicWriter.DynamicWriterT t w m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Reflex.DynamicWriter.DynamicWriterT t w m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Reflex.DynamicWriter.DynamicWriterT t w m)
instance GHC.Base.Monad m => GHC.Base.Monad (Reflex.DynamicWriter.DynamicWriterT t w m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Reflex.DynamicWriter.DynamicWriterT t w m)
instance GHC.Base.Functor m => GHC.Base.Functor (Reflex.DynamicWriter.DynamicWriterT t w m)
instance Control.Monad.Trans.Class.MonadTrans (Reflex.DynamicWriter.DynamicWriterT t w)
instance Control.Monad.Ref.MonadRef m => Control.Monad.Ref.MonadRef (Reflex.DynamicWriter.DynamicWriterT t w m)
instance Control.Monad.Ref.MonadAtomicRef m => Control.Monad.Ref.MonadAtomicRef (Reflex.DynamicWriter.DynamicWriterT t w m)
instance Reflex.Host.Class.MonadReflexCreateTrigger t m => Reflex.Host.Class.MonadReflexCreateTrigger t (Reflex.DynamicWriter.DynamicWriterT t w m)
instance (GHC.Base.Monad m, GHC.Base.Monoid w, Reflex.Class.Reflex t) => Reflex.DynamicWriter.MonadDynamicWriter t w (Reflex.DynamicWriter.DynamicWriterT t w m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Reflex.DynamicWriter.DynamicWriterT t w m)
instance Reflex.PerformEvent.Class.PerformEvent t m => Reflex.PerformEvent.Class.PerformEvent t (Reflex.DynamicWriter.DynamicWriterT t w m)
instance Reflex.TriggerEvent.Class.TriggerEvent t m => Reflex.TriggerEvent.Class.TriggerEvent t (Reflex.DynamicWriter.DynamicWriterT t w m)
instance Reflex.PostBuild.Class.PostBuild t m => Reflex.PostBuild.Class.PostBuild t (Reflex.DynamicWriter.DynamicWriterT t w m)
instance Reflex.DynamicWriter.MonadDynamicWriter t w m => Reflex.DynamicWriter.MonadDynamicWriter t w (Control.Monad.Trans.Reader.ReaderT r m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Reflex.DynamicWriter.DynamicWriterT t w m)
instance (Reflex.Class.Adjustable t m, Control.Monad.Fix.MonadFix m, GHC.Base.Monoid w, Reflex.Class.MonadHold t m, Reflex.Class.Reflex t) => Reflex.Class.Adjustable t (Reflex.DynamicWriter.DynamicWriterT t w m)
instance Reflex.Requester.Class.Requester t m => Reflex.Requester.Class.Requester t (Reflex.DynamicWriter.DynamicWriterT t w m)

module Reflex.NotReady.Class
class Monad m => NotReady t m | m -> t where notReadyUntil = lift . notReadyUntil notReady = lift notReady
notReadyUntil :: NotReady t m => Event t a -> m ()
notReadyUntil :: (NotReady t m, MonadTrans f, m ~ f m', NotReady t m') => Event t a -> m ()
notReady :: NotReady t m => m ()
notReady :: (NotReady t m, MonadTrans f, m ~ f m', NotReady t m') => m ()
instance Reflex.NotReady.Class.NotReady t m => Reflex.NotReady.Class.NotReady t (Control.Monad.Trans.Reader.ReaderT r m)
instance Reflex.NotReady.Class.NotReady t m => Reflex.NotReady.Class.NotReady t (Reflex.PostBuild.Base.PostBuildT t m)
instance Reflex.NotReady.Class.NotReady t m => Reflex.NotReady.Class.NotReady t (Reflex.EventWriter.EventWriterT t w m)
instance Reflex.NotReady.Class.NotReady t m => Reflex.NotReady.Class.NotReady t (Reflex.DynamicWriter.DynamicWriterT t w m)
instance Reflex.NotReady.Class.NotReady t m => Reflex.NotReady.Class.NotReady t (Reflex.Query.Base.QueryT t q m)
instance (Reflex.Host.Class.ReflexHost t, Reflex.NotReady.Class.NotReady t (Reflex.Host.Class.HostFrame t)) => Reflex.NotReady.Class.NotReady t (Reflex.PerformEvent.Base.PerformEventT t m)
instance Reflex.NotReady.Class.NotReady t m => Reflex.NotReady.Class.NotReady t (Reflex.Requester.Base.RequesterT t request response m)
instance Reflex.NotReady.Class.NotReady t m => Reflex.NotReady.Class.NotReady t (Reflex.TriggerEvent.Base.TriggerEventT t m)

module Reflex.Network

-- | Given a Dynamic of network-creating actions, create a network that is
--   recreated whenever the Dynamic updates. The returned Event of network
--   results occurs when the Dynamic does. Note: Often, the type <tt>a</tt>
--   is an Event, in which case the return value is an Event-of-Events that
--   would typically be flattened (via <a>switchPromptly</a>).
networkView :: (Reflex t, NotReady t m, Adjustable t m, PostBuild t m) => Dynamic t (m a) -> m (Event t a)

-- | Given an initial network and an Event of network-creating actions,
--   create a network that is recreated whenever the Event fires. The
--   returned Dynamic of network results occurs when the Event does. Note:
--   Often, the type <tt>a</tt> is an Event, in which case the return value
--   is a Dynamic-of-Events that would typically be flattened.
networkHold :: (Reflex t, Adjustable t m, MonadHold t m) => m a -> Event t (m a) -> m (Dynamic t a)

-- | Render a placeholder network to be shown while another network is not
--   yet done building
untilReady :: (Reflex t, Adjustable t m, PostBuild t m) => m a -> m b -> m (a, Event t b)

module Reflex.Workflow
newtype Workflow t m a
Workflow :: m (a, Event t (Workflow t m a)) -> Workflow t m a
[unWorkflow] :: Workflow t m a -> m (a, Event t (Workflow t m a))
workflow :: forall t m a. (Reflex t, Adjustable t m, MonadFix m, MonadHold t m) => Workflow t m a -> m (Dynamic t a)
workflowView :: forall t m a. (Reflex t, NotReady t m, Adjustable t m, MonadFix m, MonadHold t m, PostBuild t m) => Workflow t m a -> m (Event t a)
mapWorkflow :: (Reflex t, Functor m) => (a -> b) -> Workflow t m a -> Workflow t m b
mapWorkflowCheap :: (Reflex t, Functor m) => (a -> b) -> Workflow t m a -> Workflow t m b

module Reflex.Profiled
data ProfiledTimeline t
profilingData :: IORef (Map (Ptr CostCentreStack) Int)
data CostCentreTree
CostCentreTree :: !Int -> !Int -> !(Map (Ptr CostCentre) CostCentreTree) -> CostCentreTree
[_costCentreTree_ownEntries] :: CostCentreTree -> !Int
[_costCentreTree_cumulativeEntries] :: CostCentreTree -> !Int
[_costCentreTree_children] :: CostCentreTree -> !(Map (Ptr CostCentre) CostCentreTree)
getCostCentreStack :: Ptr CostCentreStack -> IO [Ptr CostCentre]
toCostCentreTree :: Ptr CostCentreStack -> Int -> IO CostCentreTree
getCostCentreTree :: IO CostCentreTree
formatCostCentreTree :: CostCentreTree -> IO String
showProfilingData :: IO ()
writeProfilingData :: FilePath -> IO ()
newtype ProfiledM m a
ProfiledM :: m a -> ProfiledM m a
[runProfiledM] :: ProfiledM m a -> m a
profileEvent :: Reflex t => Event t a -> Event t a
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Reflex.Profiled.ProfiledM m)
instance GHC.Base.Monad m => GHC.Base.Monad (Reflex.Profiled.ProfiledM m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Reflex.Profiled.ProfiledM m)
instance GHC.Base.Functor m => GHC.Base.Functor (Reflex.Profiled.ProfiledM m)
instance GHC.Classes.Ord Reflex.Profiled.CostCentreTree
instance GHC.Classes.Eq Reflex.Profiled.CostCentreTree
instance GHC.Show.Show Reflex.Profiled.CostCentreTree
instance GHC.Base.Functor (Reflex.Class.Dynamic t) => GHC.Base.Functor (Reflex.Class.Dynamic (Reflex.Profiled.ProfiledTimeline t))
instance GHC.Base.Applicative (Reflex.Class.Dynamic t) => GHC.Base.Applicative (Reflex.Class.Dynamic (Reflex.Profiled.ProfiledTimeline t))
instance GHC.Base.Monad (Reflex.Class.Dynamic t) => GHC.Base.Monad (Reflex.Class.Dynamic (Reflex.Profiled.ProfiledTimeline t))
instance GHC.Base.Monoid Reflex.Profiled.CostCentreTree
instance Reflex.Class.Reflex t => Reflex.Class.Reflex (Reflex.Profiled.ProfiledTimeline t)
instance Reflex.Class.MonadHold t m => Reflex.Class.MonadHold (Reflex.Profiled.ProfiledTimeline t) (Reflex.Profiled.ProfiledM m)
instance Reflex.Class.MonadSample t m => Reflex.Class.MonadSample (Reflex.Profiled.ProfiledTimeline t) (Reflex.Profiled.ProfiledM m)
instance Control.Monad.Trans.Class.MonadTrans Reflex.Profiled.ProfiledM
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Reflex.Profiled.ProfiledM m)
instance Reflex.PerformEvent.Class.PerformEvent t m => Reflex.PerformEvent.Class.PerformEvent (Reflex.Profiled.ProfiledTimeline t) (Reflex.Profiled.ProfiledM m)
instance Control.Monad.Ref.MonadRef m => Control.Monad.Ref.MonadRef (Reflex.Profiled.ProfiledM m)
instance Reflex.Host.Class.MonadReflexCreateTrigger t m => Reflex.Host.Class.MonadReflexCreateTrigger (Reflex.Profiled.ProfiledTimeline t) (Reflex.Profiled.ProfiledM m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Reflex.Profiled.ProfiledM m)
instance Reflex.Host.Class.ReflexHost t => Reflex.Host.Class.ReflexHost (Reflex.Profiled.ProfiledTimeline t)
instance Reflex.Host.Class.MonadSubscribeEvent t m => Reflex.Host.Class.MonadSubscribeEvent (Reflex.Profiled.ProfiledTimeline t) (Reflex.Profiled.ProfiledM m)
instance Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Reflex.Profiled.ProfiledM m)
instance Reflex.Host.Class.MonadReflexHost t m => Reflex.Host.Class.MonadReflexHost (Reflex.Profiled.ProfiledTimeline t) (Reflex.Profiled.ProfiledM m)
instance Reflex.Host.Class.MonadReadEvent t m => Reflex.Host.Class.MonadReadEvent (Reflex.Profiled.ProfiledTimeline t) (Reflex.Profiled.ProfiledM m)


-- | This module is the implementation of the <a>Spider</a> <tt>Reflex</tt>
--   engine. It uses a graph traversal algorithm to propagate <a>Event</a>s
--   and <a>Behavior</a>s.
module Reflex.Spider.Internal
debugPropagate :: Bool
debugInvalidateHeight :: Bool
debugInvalidate :: Bool
showNodeId :: a -> String
data EventSubscription x
EventSubscription :: !(IO ()) -> {-# UNPACK #-} !(EventSubscribed x) -> EventSubscription x
[_eventSubscription_unsubscribe] :: EventSubscription x -> !(IO ())
[_eventSubscription_subscribed] :: EventSubscription x -> {-# UNPACK #-} !(EventSubscribed x)
unsubscribe :: EventSubscription x -> IO ()
newtype Event x a
Event :: (Subscriber x a -> EventM x (EventSubscription x, Maybe a)) -> Event x a
[unEvent] :: Event x a -> Subscriber x a -> EventM x (EventSubscription x, Maybe a)
subscribeAndRead :: Event x a -> Subscriber x a -> EventM x (EventSubscription x, Maybe a)

-- | Construct an <a>Event</a> equivalent to that constructed by
--   <a>push</a>, but with no caching; if the computation function is very
--   cheap, this is (much) more efficient than <a>push</a>
pushCheap :: HasSpiderTimeline x => (a -> ComputeM x (Maybe b)) -> Event x a -> Event x b

-- | A subscriber that never triggers other <a>Event</a>s
terminalSubscriber :: (a -> EventM x ()) -> Subscriber x a

-- | Subscribe to an Event only for the duration of one occurrence
subscribeAndReadHead :: Event x a -> Subscriber x a -> EventM x (EventSubscription x, Maybe a)
headE :: (MonadIO m, Defer (SomeMergeInit x) m) => Event x a -> m (Event x a)
data CacheSubscribed x a
CacheSubscribed :: {-# UNPACK #-} !(FastWeakBag (Subscriber x a)) -> {-# UNPACK #-} !(EventSubscription x) -> {-# UNPACK #-} !(IORef (Maybe a)) -> CacheSubscribed x a
[_cacheSubscribed_subscribers] :: CacheSubscribed x a -> {-# UNPACK #-} !(FastWeakBag (Subscriber x a))
[_cacheSubscribed_parent] :: CacheSubscribed x a -> {-# UNPACK #-} !(EventSubscription x)
[_cacheSubscribed_occurrence] :: CacheSubscribed x a -> {-# UNPACK #-} !(IORef (Maybe a))

-- | Construct an <a>Event</a> whose value is guaranteed not to be
--   recomputed repeatedly
--   
--   TODO: Try a caching strategy where we subscribe directly to the parent
--   when there's only one subscriber, and then build our own FastWeakBag
--   only when a second subscriber joins
cacheEvent :: forall x a. HasSpiderTimeline x => Event x a -> Event x a
subscribe :: Event x a -> Subscriber x a -> EventM x (EventSubscription x)
wrap :: MonadIO m => (t -> EventSubscribed x) -> (Subscriber x a -> m (WeakBagTicket, t, Maybe a)) -> Subscriber x a -> m (EventSubscription x, Maybe a)
eventRoot :: GCompare k => k a -> Root x k -> Event x a
eventNever :: Event x a
eventFan :: (GCompare k, HasSpiderTimeline x) => k a -> Fan x k -> Event x a
eventSwitch :: HasSpiderTimeline x => Switch x a -> Event x a
eventCoincidence :: HasSpiderTimeline x => Coincidence x a -> Event x a
eventHold :: HasSpiderTimeline x => Hold x p -> Event x p
eventDyn :: (HasSpiderTimeline x, Patch p) => Dyn x p -> Event x p
subscribeCoincidenceInner :: HasSpiderTimeline x => Event x a -> Height -> CoincidenceSubscribed x a -> EventM x (Maybe a, Height, EventSubscribed x)
data Subscriber x a
Subscriber :: !(a -> EventM x ()) -> !(Height -> IO ()) -> !(Height -> IO ()) -> Subscriber x a
[subscriberPropagate] :: Subscriber x a -> !(a -> EventM x ())
[subscriberInvalidateHeight] :: Subscriber x a -> !(Height -> IO ())
[subscriberRecalculateHeight] :: Subscriber x a -> !(Height -> IO ())
newSubscriberHold :: (HasSpiderTimeline x, Patch p) => Hold x p -> IO (Subscriber x p)
newSubscriberFan :: forall x k. (HasSpiderTimeline x, GCompare k) => FanSubscribed x k -> IO (Subscriber x (DMap k Identity))
newSubscriberSwitch :: forall x a. HasSpiderTimeline x => SwitchSubscribed x a -> IO (Subscriber x a)
newSubscriberCoincidenceOuter :: forall x b. HasSpiderTimeline x => CoincidenceSubscribed x b -> IO (Subscriber x (Event x b))
newSubscriberCoincidenceInner :: forall x a. HasSpiderTimeline x => CoincidenceSubscribed x a -> IO (Subscriber x a)
invalidateSubscriberHeight :: Height -> Subscriber x a -> IO ()
recalculateSubscriberHeight :: Height -> Subscriber x a -> IO ()

-- | Propagate everything at the current height
propagate :: a -> WeakBag (Subscriber x a) -> EventM x ()

-- | Propagate everything at the current height
propagateFast :: a -> FastWeakBag (Subscriber x a) -> EventM x ()
toAny :: a -> Any
data EventSubscribed x
EventSubscribed :: {-# UNPACK #-} !(IORef Height) -> {-# NOUNPACK #-} !Any -> EventSubscribed x
[eventSubscribedHeightRef] :: EventSubscribed x -> {-# UNPACK #-} !(IORef Height)
[eventSubscribedRetained] :: EventSubscribed x -> {-# NOUNPACK #-} !Any
eventSubscribedRoot :: RootSubscribed x a -> EventSubscribed x
eventSubscribedNever :: EventSubscribed x
eventSubscribedFan :: FanSubscribed x k -> EventSubscribed x
eventSubscribedSwitch :: SwitchSubscribed x a -> EventSubscribed x
eventSubscribedCoincidence :: CoincidenceSubscribed x a -> EventSubscribed x
getEventSubscribedHeight :: EventSubscribed x -> IO Height
subscribeHoldEvent :: HasSpiderTimeline x => Hold x p -> Subscriber x p -> EventM x (EventSubscription x, Maybe p)
newtype Behavior x a
Behavior :: BehaviorM x a -> Behavior x a
[readBehaviorTracked] :: Behavior x a -> BehaviorM x a
behaviorHold :: Hold x p -> Behavior x (PatchTarget p)
behaviorHoldIdentity :: Hold x (Identity a) -> Behavior x a
behaviorConst :: a -> Behavior x a
behaviorPull :: Pull x a -> Behavior x a
behaviorDyn :: Patch p => Dyn x p -> Behavior x (PatchTarget p)
readHoldTracked :: Hold x p -> BehaviorM x (PatchTarget p)
readBehaviorUntracked :: Defer (SomeHoldInit x) m => Behavior x a -> m a
data Dynamic x p
Dynamic :: !(Behavior x (PatchTarget p)) -> !(Event x p) -> Dynamic x p
[dynamicCurrent] :: Dynamic x p -> !(Behavior x (PatchTarget p))
[dynamicUpdated] :: Dynamic x p -> !(Event x p)
dynamicHold :: HasSpiderTimeline x => Hold x p -> Dynamic x p
dynamicHoldIdentity :: HasSpiderTimeline x => Hold x (Identity a) -> Dynamic x (Identity a)
dynamicConst :: PatchTarget p -> Dynamic x p
dynamicDyn :: (HasSpiderTimeline x, Patch p) => Dyn x p -> Dynamic x p
dynamicDynIdentity :: HasSpiderTimeline x => Dyn x (Identity a) -> Dynamic x (Identity a)
data Hold x p
Hold :: !(IORef (PatchTarget p)) -> !(IORef [Weak (Invalidator x)]) -> Event x p -> !(IORef (Maybe (EventSubscription x))) -> Hold x p
[holdValue] :: Hold x p -> !(IORef (PatchTarget p))
[holdInvalidators] :: Hold x p -> !(IORef [Weak (Invalidator x)])
[holdEvent] :: Hold x p -> Event x p
[holdParent] :: Hold x p -> !(IORef (Maybe (EventSubscription x)))

-- | A statically allocated <a>SpiderTimeline</a>; this is the only
--   instance of <a>SpiderTimeline</a> that can used when using
--   -fspecialize-to-spidertimeline-global.
data Global
globalSpiderTimelineEnv :: SpiderTimelineEnv Global

-- | Stores all global data relevant to a particular Spider timeline; only
--   one value should exist for each type <tt>x</tt>
data SpiderTimelineEnv x
SpiderTimelineEnv :: {-# UNPACK #-} !(MVar ()) -> {-# UNPACK #-} !(EventEnv x) -> SpiderTimelineEnv x
[_spiderTimeline_lock] :: SpiderTimelineEnv x -> {-# UNPACK #-} !(MVar ())
[_spiderTimeline_eventEnv] :: SpiderTimelineEnv x -> {-# UNPACK #-} !(EventEnv x)
data EventEnv x
EventEnv :: !(IORef [SomeAssignment x]) -> !(IORef [SomeHoldInit x]) -> !(IORef [SomeDynInit x]) -> !(IORef [SomeMergeUpdate x]) -> !(IORef [SomeMergeInit x]) -> !(IORef [SomeClear]) -> !(IORef [SomeIntClear]) -> !(IORef [SomeRootClear]) -> !(IORef Height) -> !(IORef [SomeResetCoincidence x]) -> !(IORef (IntMap [EventM x ()])) -> EventEnv x
[eventEnvAssignments] :: EventEnv x -> !(IORef [SomeAssignment x])
[eventEnvHoldInits] :: EventEnv x -> !(IORef [SomeHoldInit x])
[eventEnvDynInits] :: EventEnv x -> !(IORef [SomeDynInit x])
[eventEnvMergeUpdates] :: EventEnv x -> !(IORef [SomeMergeUpdate x])
[eventEnvMergeInits] :: EventEnv x -> !(IORef [SomeMergeInit x])
[eventEnvClears] :: EventEnv x -> !(IORef [SomeClear])
[eventEnvIntClears] :: EventEnv x -> !(IORef [SomeIntClear])
[eventEnvRootClears] :: EventEnv x -> !(IORef [SomeRootClear])
[eventEnvCurrentHeight] :: EventEnv x -> !(IORef Height)
[eventEnvResetCoincidences] :: EventEnv x -> !(IORef [SomeResetCoincidence x])
[eventEnvDelayedMerges] :: EventEnv x -> !(IORef (IntMap [EventM x ()]))
runEventM :: EventM x a -> IO a
asksEventEnv :: forall x a. HasSpiderTimeline x => (EventEnv x -> a) -> EventM x a
class MonadIO m => Defer a m
getDeferralQueue :: Defer a m => m (IORef [a])
defer :: Defer a m => a -> m ()
class HasSpiderTimeline x => HasCurrentHeight x m | m -> x
getCurrentHeight :: HasCurrentHeight x m => m Height
scheduleMerge :: HasCurrentHeight x m => Height -> EventM x () -> m ()
class HasSpiderTimeline x

-- | Retrieve the current SpiderTimelineEnv
spiderTimeline :: HasSpiderTimeline x => SpiderTimelineEnv x
putCurrentHeight :: HasSpiderTimeline x => Height -> EventM x ()
scheduleClear :: Defer SomeClear m => IORef (Maybe a) -> m ()
scheduleIntClear :: Defer SomeIntClear m => IORef (IntMap a) -> m ()
scheduleRootClear :: Defer SomeRootClear m => IORef (DMap k Identity) -> m ()
hold :: (Patch p, Defer (SomeHoldInit x) m) => PatchTarget p -> Event x p -> m (Hold x p)
getHoldEventSubscription :: forall p x. (HasSpiderTimeline x, Patch p) => Hold x p -> EventM x (EventSubscription x)
type BehaviorEnv x = (Maybe (Weak (Invalidator x), IORef [SomeBehaviorSubscribed x]), IORef [SomeHoldInit x])
newtype BehaviorM x a
BehaviorM :: ReaderT (BehaviorEnv x) IO a -> BehaviorM x a
[unBehaviorM] :: BehaviorM x a -> ReaderT (BehaviorEnv x) IO a
data BehaviorSubscribed x a
BehaviorSubscribedHold :: (Hold x p) -> BehaviorSubscribed x a
BehaviorSubscribedPull :: (PullSubscribed x a) -> BehaviorSubscribed x a
data SomeBehaviorSubscribed x
SomeBehaviorSubscribed :: (BehaviorSubscribed x a) -> SomeBehaviorSubscribed x
data PullSubscribed x a
PullSubscribed :: !a -> !(IORef [Weak (Invalidator x)]) -> !(Invalidator x) -> ![SomeBehaviorSubscribed x] -> PullSubscribed x a
[pullSubscribedValue] :: PullSubscribed x a -> !a
[pullSubscribedInvalidators] :: PullSubscribed x a -> !(IORef [Weak (Invalidator x)])
[pullSubscribedOwnInvalidator] :: PullSubscribed x a -> !(Invalidator x)
[pullSubscribedParents] :: PullSubscribed x a -> ![SomeBehaviorSubscribed x]
data Pull x a
Pull :: !(IORef (Maybe (PullSubscribed x a))) -> !(BehaviorM x a) -> Pull x a
[pullValue] :: Pull x a -> !(IORef (Maybe (PullSubscribed x a)))
[pullCompute] :: Pull x a -> !(BehaviorM x a)
data Invalidator x
InvalidatorPull :: (Pull x a) -> Invalidator x
InvalidatorSwitch :: (SwitchSubscribed x a) -> Invalidator x
data RootSubscribed x a
RootSubscribed :: !(k a) -> !(IORef (DMap k (RootSubscribed x))) -> !(WeakBag (Subscriber x a)) -> !(IO (Maybe a)) -> IO () -> !(IORef (Weak (RootSubscribed x a))) -> RootSubscribed x a
[rootSubscribedKey] :: RootSubscribed x a -> !(k a)
[rootSubscribedCachedSubscribed] :: RootSubscribed x a -> !(IORef (DMap k (RootSubscribed x)))
[rootSubscribedSubscribers] :: RootSubscribed x a -> !(WeakBag (Subscriber x a))
[rootSubscribedOccurrence] :: RootSubscribed x a -> !(IO (Maybe a))
[rootSubscribedUninit] :: RootSubscribed x a -> IO ()
[rootSubscribedWeakSelf] :: RootSubscribed x a -> !(IORef (Weak (RootSubscribed x a)))
data Root x (k :: * -> *)
Root :: !(IORef (DMap k Identity)) -> !(IORef (DMap k (RootSubscribed x))) -> !(forall a. k a -> RootTrigger x a -> IO (IO ())) -> Root x
[rootOccurrence] :: Root x -> !(IORef (DMap k Identity))
[rootSubscribed] :: Root x -> !(IORef (DMap k (RootSubscribed x)))
[rootInit] :: Root x -> !(forall a. k a -> RootTrigger x a -> IO (IO ()))
data SomeHoldInit x
SomeHoldInit :: !(Hold x p) -> SomeHoldInit x
data SomeDynInit x
SomeDynInit :: !(Dyn x p) -> SomeDynInit x
data SomeMergeUpdate x
SomeMergeUpdate :: !(EventM x [EventSubscription x]) -> !(IO ()) -> !(IO ()) -> SomeMergeUpdate x
[_someMergeUpdate_update] :: SomeMergeUpdate x -> !(EventM x [EventSubscription x])
[_someMergeUpdate_invalidateHeight] :: SomeMergeUpdate x -> !(IO ())
[_someMergeUpdate_recalculateHeight] :: SomeMergeUpdate x -> !(IO ())
newtype SomeMergeInit x
SomeMergeInit :: EventM x () -> SomeMergeInit x
[unSomeMergeInit] :: SomeMergeInit x -> EventM x ()
newtype EventM x a
EventM :: IO a -> EventM x a
[unEventM] :: EventM x a -> IO a
newtype MergeSubscribedParent x a
MergeSubscribedParent :: EventSubscription x -> MergeSubscribedParent x a
[unMergeSubscribedParent] :: MergeSubscribedParent x a -> EventSubscription x
data MergeSubscribedParentWithMove x k a
MergeSubscribedParentWithMove :: !(EventSubscription x) -> !(IORef (k a)) -> MergeSubscribedParentWithMove x k a
[_mergeSubscribedParentWithMove_subscription] :: MergeSubscribedParentWithMove x k a -> !(EventSubscription x)
[_mergeSubscribedParentWithMove_key] :: MergeSubscribedParentWithMove x k a -> !(IORef (k a))
data HeightBag
HeightBag :: {-# UNPACK #-} !Int -> !(IntMap Word) -> HeightBag
[_heightBag_size] :: HeightBag -> {-# UNPACK #-} !Int
[_heightBag_contents] :: HeightBag -> !(IntMap Word)
heightBagEmpty :: HeightBag
heightBagSize :: HeightBag -> Int
heightBagFromList :: [Height] -> HeightBag
heightBagAdd :: Height -> HeightBag -> HeightBag
heightBagRemove :: Height -> HeightBag -> HeightBag
heightBagMax :: HeightBag -> Height
heightBagVerify :: HeightBag -> HeightBag
data FanSubscribedChildren (x :: *) k a
FanSubscribedChildren :: !(WeakBag (Subscriber x a)) -> {-# NOUNPACK #-} !(k a, FanSubscribed x k) -> !(IORef (Weak (k a, FanSubscribed x k))) -> FanSubscribedChildren k a
[_fanSubscribedChildren_list] :: FanSubscribedChildren k a -> !(WeakBag (Subscriber x a))
[_fanSubscribedChildren_self] :: FanSubscribedChildren k a -> {-# NOUNPACK #-} !(k a, FanSubscribed x k)
[_fanSubscribedChildren_weakSelf] :: FanSubscribedChildren k a -> !(IORef (Weak (k a, FanSubscribed x k)))
data FanSubscribed (x :: *) k
FanSubscribed :: !(IORef (Maybe (FanSubscribed x k))) -> !(IORef (Maybe (DMap k Identity))) -> !(IORef (DMap k (FanSubscribedChildren x k))) -> !(EventSubscription x) -> FanSubscribed k
[fanSubscribedCachedSubscribed] :: FanSubscribed k -> !(IORef (Maybe (FanSubscribed x k)))
[fanSubscribedOccurrence] :: FanSubscribed k -> !(IORef (Maybe (DMap k Identity)))
[fanSubscribedSubscribers] :: FanSubscribed k -> !(IORef (DMap k (FanSubscribedChildren x k)))
[fanSubscribedParent] :: FanSubscribed k -> !(EventSubscription x)
data Fan x k
Fan :: !(Event x (DMap k Identity)) -> !(IORef (Maybe (FanSubscribed x k))) -> Fan x k
[fanParent] :: Fan x k -> !(Event x (DMap k Identity))
[fanSubscribed] :: Fan x k -> !(IORef (Maybe (FanSubscribed x k)))
data SwitchSubscribed x a
SwitchSubscribed :: !(IORef (Maybe (SwitchSubscribed x a))) -> !(IORef (Maybe a)) -> !(IORef Height) -> !(WeakBag (Subscriber x a)) -> {-# NOUNPACK #-} !(Invalidator x) -> !(IORef (Weak (Invalidator x))) -> !(IORef [SomeBehaviorSubscribed x]) -> !(Behavior x (Event x a)) -> !(IORef (EventSubscription x)) -> !(IORef (Weak (SwitchSubscribed x a))) -> SwitchSubscribed x a
[switchSubscribedCachedSubscribed] :: SwitchSubscribed x a -> !(IORef (Maybe (SwitchSubscribed x a)))
[switchSubscribedOccurrence] :: SwitchSubscribed x a -> !(IORef (Maybe a))
[switchSubscribedHeight] :: SwitchSubscribed x a -> !(IORef Height)
[switchSubscribedSubscribers] :: SwitchSubscribed x a -> !(WeakBag (Subscriber x a))
[switchSubscribedOwnInvalidator] :: SwitchSubscribed x a -> {-# NOUNPACK #-} !(Invalidator x)
[switchSubscribedOwnWeakInvalidator] :: SwitchSubscribed x a -> !(IORef (Weak (Invalidator x)))
[switchSubscribedBehaviorParents] :: SwitchSubscribed x a -> !(IORef [SomeBehaviorSubscribed x])
[switchSubscribedParent] :: SwitchSubscribed x a -> !(Behavior x (Event x a))
[switchSubscribedCurrentParent] :: SwitchSubscribed x a -> !(IORef (EventSubscription x))
[switchSubscribedWeakSelf] :: SwitchSubscribed x a -> !(IORef (Weak (SwitchSubscribed x a)))
data Switch x a
Switch :: !(Behavior x (Event x a)) -> !(IORef (Maybe (SwitchSubscribed x a))) -> Switch x a
[switchParent] :: Switch x a -> !(Behavior x (Event x a))
[switchSubscribed] :: Switch x a -> !(IORef (Maybe (SwitchSubscribed x a)))
data CoincidenceSubscribed x a
CoincidenceSubscribed :: !(IORef (Maybe (CoincidenceSubscribed x a))) -> !(IORef (Maybe a)) -> !(WeakBag (Subscriber x a)) -> !(IORef Height) -> {-# NOUNPACK #-}(Subscriber x (Event x a)) -> !(EventSubscription x) -> !(IORef (Maybe (EventSubscribed x))) -> !(IORef (Weak (CoincidenceSubscribed x a))) -> CoincidenceSubscribed x a
[coincidenceSubscribedCachedSubscribed] :: CoincidenceSubscribed x a -> !(IORef (Maybe (CoincidenceSubscribed x a)))
[coincidenceSubscribedOccurrence] :: CoincidenceSubscribed x a -> !(IORef (Maybe a))
[coincidenceSubscribedSubscribers] :: CoincidenceSubscribed x a -> !(WeakBag (Subscriber x a))
[coincidenceSubscribedHeight] :: CoincidenceSubscribed x a -> !(IORef Height)
[coincidenceSubscribedOuter] :: CoincidenceSubscribed x a -> {-# NOUNPACK #-}(Subscriber x (Event x a))
[coincidenceSubscribedOuterParent] :: CoincidenceSubscribed x a -> !(EventSubscription x)
[coincidenceSubscribedInnerParent] :: CoincidenceSubscribed x a -> !(IORef (Maybe (EventSubscribed x)))
[coincidenceSubscribedWeakSelf] :: CoincidenceSubscribed x a -> !(IORef (Weak (CoincidenceSubscribed x a)))
data Coincidence x a
Coincidence :: !(Event x (Event x a)) -> !(IORef (Maybe (CoincidenceSubscribed x a))) -> Coincidence x a
[coincidenceParent] :: Coincidence x a -> !(Event x (Event x a))
[coincidenceSubscribed] :: Coincidence x a -> !(IORef (Maybe (CoincidenceSubscribed x a)))
newInvalidatorSwitch :: SwitchSubscribed x a -> IO (Invalidator x)
newInvalidatorPull :: Pull x a -> IO (Invalidator x)
newtype Dyn x p
Dyn :: IORef (Either (BehaviorM x (PatchTarget p), Event x p) (Hold x p)) -> Dyn x p
[unDyn] :: Dyn x p -> IORef (Either (BehaviorM x (PatchTarget p), Event x p) (Hold x p))
newMapDyn :: HasSpiderTimeline x => (a -> b) -> Dynamic x (Identity a) -> Dynamic x (Identity b)
zipDynWith :: HasSpiderTimeline x => (a -> b -> c) -> Dynamic x (Identity a) -> Dynamic x (Identity b) -> Dynamic x (Identity c)
buildDynamic :: (Defer (SomeDynInit x) m, Patch p) => BehaviorM x (PatchTarget p) -> Event x p -> m (Dyn x p)
unsafeBuildDynamic :: BehaviorM x (PatchTarget p) -> Event x p -> Dyn x p
type ResultM = EventM
unsafeNewIORef :: a -> b -> IORef b
push :: HasSpiderTimeline x => (a -> ComputeM x (Maybe b)) -> Event x a -> Event x b
pull :: BehaviorM x a -> Behavior x a
switch :: HasSpiderTimeline x => Behavior x (Event x a) -> Event x a
coincidence :: HasSpiderTimeline x => Event x (Event x a) -> Event x a
run :: forall x b. HasSpiderTimeline x => [DSum (RootTrigger x) Identity] -> ResultM x b -> SpiderHost x b
scheduleMerge' :: HasSpiderTimeline x => Height -> IORef Height -> EventM x () -> EventM x ()
data SomeClear
SomeClear :: {-# UNPACK #-} !(IORef (Maybe a)) -> SomeClear
data SomeIntClear
SomeIntClear :: {-# UNPACK #-} !(IORef (IntMap a)) -> SomeIntClear
data SomeRootClear
SomeRootClear :: {-# UNPACK #-} !(IORef (DMap k Identity)) -> SomeRootClear
data SomeAssignment x
SomeAssignment :: {-# UNPACK #-} !(IORef a) -> {-# UNPACK #-} !(IORef [Weak (Invalidator x)]) -> a -> SomeAssignment x
debugFinalize :: Bool
mkWeakPtrWithDebug :: a -> String -> IO (Weak a)
type WeakList a = [Weak a]
withIncreasedDepth :: m a -> m a
type CanTrace x m = (HasSpiderTimeline x, MonadIO m)
tracePropagate :: (CanTrace x m) => proxy x -> String -> m ()
traceInvalidate :: String -> IO ()
traceWhen :: (CanTrace x m) => proxy x -> Bool -> String -> m ()
traceMWhen :: (CanTrace x m) => proxy x -> Bool -> m String -> m ()
whoCreatedIORef :: IORef a -> IO [String]
propagateSubscriberHold :: forall x p. (HasSpiderTimeline x, Patch p) => Hold x p -> p -> EventM x ()
data SomeResetCoincidence x
SomeResetCoincidence :: !(EventSubscription x) -> !(Maybe (CoincidenceSubscribed x a)) -> SomeResetCoincidence x
runBehaviorM :: BehaviorM x a -> Maybe (Weak (Invalidator x), IORef [SomeBehaviorSubscribed x]) -> IORef [SomeHoldInit x] -> IO a
askInvalidator :: BehaviorM x (Maybe (Weak (Invalidator x)))
askParentsRef :: BehaviorM x (Maybe (IORef [SomeBehaviorSubscribed x]))
askBehaviorHoldInits :: BehaviorM x (IORef [SomeHoldInit x])
getDynHold :: (Defer (SomeHoldInit x) m, Patch p) => Dyn x p -> m (Hold x p)
zeroRef :: IORef Height
getRootSubscribed :: GCompare k => k a -> Root x k -> Subscriber x a -> IO (WeakBagTicket, RootSubscribed x a, Maybe a)
cleanupRootSubscribed :: RootSubscribed x a -> IO ()
subscribeRootSubscribed :: RootSubscribed x a -> Subscriber x a -> IO WeakBagTicket
newtype EventSelectorInt x a
EventSelectorInt :: (Int -> Event x a) -> EventSelectorInt x a
[selectInt] :: EventSelectorInt x a -> Int -> Event x a
data FanInt x a
FanInt :: {-# UNPACK #-} !(FastMutableIntMap (FastWeakBag (Subscriber x a))) -> {-# UNPACK #-} !(IORef (EventSubscription x)) -> {-# UNPACK #-} !(IORef (IntMap a)) -> FanInt x a
[_fanInt_subscribers] :: FanInt x a -> {-# UNPACK #-} !(FastMutableIntMap (FastWeakBag (Subscriber x a)))
[_fanInt_subscriptionRef] :: FanInt x a -> {-# UNPACK #-} !(IORef (EventSubscription x))
[_fanInt_occRef] :: FanInt x a -> {-# UNPACK #-} !(IORef (IntMap a))
newFanInt :: IO (FanInt x a)
unsafeNewFanInt :: b -> FanInt x a
fanInt :: HasSpiderTimeline x => Event x (IntMap a) -> EventSelectorInt x a
getFanSubscribed :: (HasSpiderTimeline x, GCompare k) => k a -> Fan x k -> Subscriber x a -> EventM x (WeakBagTicket, FanSubscribed x k, Maybe a)
cleanupFanSubscribed :: GCompare k => (k a, FanSubscribed x k) -> IO ()
subscribeFanSubscribed :: GCompare k => k a -> FanSubscribed x k -> Subscriber x a -> IO WeakBagTicket
getSwitchSubscribed :: HasSpiderTimeline x => Switch x a -> Subscriber x a -> EventM x (WeakBagTicket, SwitchSubscribed x a, Maybe a)
cleanupSwitchSubscribed :: SwitchSubscribed x a -> IO ()
subscribeSwitchSubscribed :: SwitchSubscribed x a -> Subscriber x a -> IO WeakBagTicket
getCoincidenceSubscribed :: forall x a. HasSpiderTimeline x => Coincidence x a -> Subscriber x a -> EventM x (WeakBagTicket, CoincidenceSubscribed x a, Maybe a)
cleanupCoincidenceSubscribed :: CoincidenceSubscribed x a -> IO ()
subscribeCoincidenceSubscribed :: CoincidenceSubscribed x a -> Subscriber x a -> IO WeakBagTicket
merge :: forall k x. (HasSpiderTimeline x, GCompare k) => Dynamic x (PatchDMap k (Event x)) -> Event x (DMap k Identity)
mergeWithMove :: forall k x. (HasSpiderTimeline x, GCompare k) => Dynamic x (PatchDMapWithMove k (Event x)) -> Event x (DMap k Identity)
mergeCheap :: forall k x. (HasSpiderTimeline x, GCompare k) => Dynamic x (PatchDMap k (Event x)) -> Event x (DMap k Identity)
mergeCheapWithMove :: forall k x. (HasSpiderTimeline x, GCompare k) => Dynamic x (PatchDMapWithMove k (Event x)) -> Event x (DMap k Identity)
type MergeUpdateFunc k x p s = (forall a. EventM x (k a) -> Subscriber x a) -> IORef HeightBag -> DMap k s -> p -> EventM x ([EventSubscription x], DMap k s)
type MergeInitFunc k x s = DMap k (Event x) -> (forall a. EventM x (k a) -> Subscriber x a) -> EventM x (DMap k Identity, [Height], DMap k s)
type MergeDestroyFunc k s = DMap k s -> IO ()
data Merge x k s
Merge :: {-# UNPACK #-} !(IORef (DMap k s)) -> {-# UNPACK #-} !(IORef HeightBag) -> {-# UNPACK #-} !(IORef Height) -> {-# UNPACK #-} !(Subscriber x (DMap k Identity)) -> {-# UNPACK #-} !(IORef (DMap k Identity)) -> Merge x k s
[_merge_parentsRef] :: Merge x k s -> {-# UNPACK #-} !(IORef (DMap k s))
[_merge_heightBagRef] :: Merge x k s -> {-# UNPACK #-} !(IORef HeightBag)
[_merge_heightRef] :: Merge x k s -> {-# UNPACK #-} !(IORef Height)
[_merge_sub] :: Merge x k s -> {-# UNPACK #-} !(Subscriber x (DMap k Identity))
[_merge_accumRef] :: Merge x k s -> {-# UNPACK #-} !(IORef (DMap k Identity))
invalidateMergeHeight :: Merge x k s -> IO ()
invalidateMergeHeight' :: IORef Height -> Subscriber x a -> IO ()
revalidateMergeHeight :: Merge x k s -> IO ()
scheduleMergeSelf :: HasSpiderTimeline x => Merge x k s -> Height -> EventM x ()
mergeSubscriber :: forall x k s a. (HasSpiderTimeline x, GCompare k) => Merge x k s -> EventM x (k a) -> Subscriber x a
updateMerge :: (HasSpiderTimeline x, GCompare k) => Merge x k s -> MergeUpdateFunc k x p s -> p -> SomeMergeUpdate x
mergeCheap' :: forall k x p s. (HasSpiderTimeline x, GCompare k, PatchTarget p ~ DMap k (Event x)) => MergeInitFunc k x s -> MergeUpdateFunc k x p s -> MergeDestroyFunc k s -> Dynamic x p -> Event x (DMap k Identity)
mergeInt :: forall x a. (HasSpiderTimeline x) => Dynamic x (PatchIntMap (Event x a)) -> Event x (IntMap a)
mergeIntCheap :: forall x a. (HasSpiderTimeline x) => Dynamic x (PatchIntMap (Event x a)) -> Event x (IntMap a)
newtype EventSelector x k
EventSelector :: (forall a. k a -> Event x a) -> EventSelector x k
[select] :: EventSelector x k -> forall a. k a -> Event x a
fan :: (HasSpiderTimeline x, GCompare k) => Event x (DMap k Identity) -> EventSelector x k
runHoldInits :: HasSpiderTimeline x => IORef [SomeHoldInit x] -> IORef [SomeDynInit x] -> IORef [SomeMergeInit x] -> EventM x ()
initHold :: HasSpiderTimeline x => SomeHoldInit x -> EventM x ()
initDyn :: HasSpiderTimeline x => SomeDynInit x -> EventM x ()
newEventEnv :: IO (EventEnv x)
clearEventEnv :: EventEnv x -> IO ()

-- | Run an event action outside of a frame
runFrame :: forall x a. HasSpiderTimeline x => EventM x a -> SpiderHost x a
newtype Height
Height :: Int -> Height
[unHeight] :: Height -> Int
zeroHeight :: Height
invalidHeight :: Height
succHeight :: Height -> Height
invalidateCoincidenceHeight :: CoincidenceSubscribed x a -> IO ()
updateSwitchHeight :: Height -> SwitchSubscribed x a -> IO ()
recalculateCoincidenceHeight :: CoincidenceSubscribed x a -> IO ()
calculateSwitchHeight :: SwitchSubscribed x a -> IO Height
calculateCoincidenceHeight :: CoincidenceSubscribed x a -> IO Height
data SomeSwitchSubscribed x
SomeSwitchSubscribed :: {-# NOUNPACK #-}(SwitchSubscribed x a) -> SomeSwitchSubscribed x
invalidate :: IORef [SomeSwitchSubscribed x] -> WeakList (Invalidator x) -> IO (WeakList (Invalidator x))
unsafeNewSpiderTimelineEnv :: forall x. IO (SpiderTimelineEnv x)

-- | Create a new SpiderTimelineEnv
newSpiderTimeline :: IO (Some SpiderTimelineEnv)
data LocalSpiderTimeline x s
localSpiderTimeline :: Proxy s -> SpiderTimelineEnv x -> SpiderTimelineEnv (LocalSpiderTimeline x s)

-- | Pass a new timeline to the given function.
withSpiderTimeline :: (forall x. HasSpiderTimeline x => SpiderTimelineEnv x -> IO r) -> IO r
newtype SpiderPullM x a
SpiderPullM :: (BehaviorM x a) -> SpiderPullM x a
type ComputeM = EventM
newtype SpiderPushM x a
SpiderPushM :: (ComputeM x a) -> SpiderPushM x a
data RootTrigger x a
RootTrigger :: (WeakBag (Subscriber x a), IORef (DMap k Identity), k a) -> RootTrigger x a
data SpiderEventHandle x a
SpiderEventHandle :: EventSubscription x -> IORef (Maybe a) -> SpiderEventHandle x a
[spiderEventHandleSubscription] :: SpiderEventHandle x a -> EventSubscription x
[spiderEventHandleValue] :: SpiderEventHandle x a -> IORef (Maybe a)

-- | The monad for actions that manipulate a Spider timeline identified by
--   <tt>x</tt>
newtype SpiderHost x a
SpiderHost :: ReaderT (SpiderTimelineEnv x) IO a -> SpiderHost x a
[unSpiderHost] :: SpiderHost x a -> ReaderT (SpiderTimelineEnv x) IO a

-- | Run an action affecting the global Spider timeline; this will be
--   guarded by a mutex for that timeline
runSpiderHost :: SpiderHost Global a -> IO a

-- | Run an action affecting a given Spider timeline; this will be guarded
--   by a mutex for that timeline
runSpiderHostForTimeline :: SpiderHost x a -> SpiderTimelineEnv x -> IO a
newtype SpiderHostFrame x a
SpiderHostFrame :: EventM x a -> SpiderHostFrame x a
[runSpiderHostFrame] :: SpiderHostFrame x a -> EventM x a
newEventWithTriggerIO :: (RootTrigger x a -> IO (IO ())) -> IO (Event x a)
newFanEventWithTriggerIO :: GCompare k => (forall a. k a -> RootTrigger x a -> IO (IO ())) -> IO (EventSelector x k)
newtype ReadPhase x a
ReadPhase :: (ResultM x a) -> ReadPhase x a

-- | Designates the default, global Spider timeline
data SpiderTimeline x

-- | The default, global Spider environment
type Spider = SpiderTimeline Global
newJoinDyn :: HasSpiderTimeline x => Dynamic x (Identity (Dynamic x (Identity a))) -> Dyn x (Identity a)
holdSpiderEventM :: HasSpiderTimeline x => a -> Event (SpiderTimeline x) a -> EventM x (Behavior (SpiderTimeline x) a)
holdDynSpiderEventM :: HasSpiderTimeline x => a -> Event (SpiderTimeline x) a -> EventM x (Dynamic (SpiderTimeline x) a)
holdIncrementalSpiderEventM :: (HasSpiderTimeline x, Patch p) => PatchTarget p -> Event (SpiderTimeline x) p -> EventM x (Incremental (SpiderTimeline x) p)
buildDynamicSpiderEventM :: HasSpiderTimeline x => SpiderPullM x a -> Event (SpiderTimeline x) a -> EventM x (Dynamic (SpiderTimeline x) a)

-- | <a>SpiderEnv</a> is the old name for <a>SpiderTimeline</a>

-- | <i>Deprecated: Use <a>SpiderTimelineEnv</a> instead</i>
type SpiderEnv = SpiderTimeline
instance Control.Monad.Fix.MonadFix (Reflex.Spider.Internal.ReadPhase x)
instance GHC.Base.Monad (Reflex.Spider.Internal.ReadPhase x)
instance GHC.Base.Applicative (Reflex.Spider.Internal.ReadPhase x)
instance GHC.Base.Functor (Reflex.Spider.Internal.ReadPhase x)
instance Control.Monad.Exception.MonadAsyncException (Reflex.Spider.Internal.SpiderHostFrame x)
instance Control.Monad.Exception.MonadException (Reflex.Spider.Internal.SpiderHostFrame x)
instance Control.Monad.IO.Class.MonadIO (Reflex.Spider.Internal.SpiderHostFrame x)
instance Control.Monad.Fix.MonadFix (Reflex.Spider.Internal.SpiderHostFrame x)
instance GHC.Base.Applicative (Reflex.Spider.Internal.SpiderHostFrame x)
instance GHC.Base.Functor (Reflex.Spider.Internal.SpiderHostFrame x)
instance Control.Monad.Exception.MonadAsyncException (Reflex.Spider.Internal.SpiderHost x)
instance Control.Monad.Exception.MonadException (Reflex.Spider.Internal.SpiderHost x)
instance Control.Monad.IO.Class.MonadIO (Reflex.Spider.Internal.SpiderHost x)
instance Control.Monad.Fix.MonadFix (Reflex.Spider.Internal.SpiderHost x)
instance GHC.Base.Applicative (Reflex.Spider.Internal.SpiderHost x)
instance GHC.Base.Functor (Reflex.Spider.Internal.SpiderHost x)
instance Control.Monad.Fix.MonadFix (Reflex.Spider.Internal.SpiderPushM x)
instance Control.Monad.IO.Class.MonadIO (Reflex.Spider.Internal.SpiderPushM x)
instance GHC.Base.Monad (Reflex.Spider.Internal.SpiderPushM x)
instance GHC.Base.Applicative (Reflex.Spider.Internal.SpiderPushM x)
instance GHC.Base.Functor (Reflex.Spider.Internal.SpiderPushM x)
instance Control.Monad.Fix.MonadFix (Reflex.Spider.Internal.SpiderPullM x)
instance Control.Monad.IO.Class.MonadIO (Reflex.Spider.Internal.SpiderPullM x)
instance GHC.Base.Monad (Reflex.Spider.Internal.SpiderPullM x)
instance GHC.Base.Applicative (Reflex.Spider.Internal.SpiderPullM x)
instance GHC.Base.Functor (Reflex.Spider.Internal.SpiderPullM x)
instance Control.Monad.Fix.MonadFix (Reflex.Spider.Internal.BehaviorM x)
instance Control.Monad.IO.Class.MonadIO (Reflex.Spider.Internal.BehaviorM x)
instance GHC.Base.Applicative (Reflex.Spider.Internal.BehaviorM x)
instance GHC.Base.Functor (Reflex.Spider.Internal.BehaviorM x)
instance GHC.Enum.Bounded Reflex.Spider.Internal.Height
instance GHC.Classes.Ord Reflex.Spider.Internal.Height
instance GHC.Classes.Eq Reflex.Spider.Internal.Height
instance GHC.Read.Read Reflex.Spider.Internal.Height
instance GHC.Show.Show Reflex.Spider.Internal.Height
instance GHC.Classes.Ord Reflex.Spider.Internal.HeightBag
instance GHC.Classes.Eq Reflex.Spider.Internal.HeightBag
instance GHC.Read.Read Reflex.Spider.Internal.HeightBag
instance GHC.Show.Show Reflex.Spider.Internal.HeightBag
instance Control.Monad.Exception.MonadAsyncException (Reflex.Spider.Internal.EventM x)
instance Control.Monad.Exception.MonadException (Reflex.Spider.Internal.EventM x)
instance Control.Monad.Fix.MonadFix (Reflex.Spider.Internal.EventM x)
instance Control.Monad.IO.Class.MonadIO (Reflex.Spider.Internal.EventM x)
instance GHC.Base.Monad (Reflex.Spider.Internal.EventM x)
instance GHC.Base.Applicative (Reflex.Spider.Internal.EventM x)
instance GHC.Base.Functor (Reflex.Spider.Internal.EventM x)
instance GHC.Classes.Eq (Reflex.Spider.Internal.SpiderTimelineEnv x)
instance Data.GADT.Compare.GEq Reflex.Spider.Internal.SpiderTimelineEnv
instance Reflex.Spider.Internal.HasSpiderTimeline x => Reflex.Spider.Internal.Defer (Reflex.Spider.Internal.SomeAssignment x) (Reflex.Spider.Internal.EventM x)
instance Reflex.Spider.Internal.HasSpiderTimeline x => Reflex.Spider.Internal.Defer (Reflex.Spider.Internal.SomeHoldInit x) (Reflex.Spider.Internal.EventM x)
instance Reflex.Spider.Internal.HasSpiderTimeline x => Reflex.Spider.Internal.Defer (Reflex.Spider.Internal.SomeDynInit x) (Reflex.Spider.Internal.EventM x)
instance Reflex.Spider.Internal.Defer (Reflex.Spider.Internal.SomeHoldInit x) (Reflex.Spider.Internal.BehaviorM x)
instance Reflex.Spider.Internal.HasSpiderTimeline x => Reflex.Spider.Internal.Defer (Reflex.Spider.Internal.SomeMergeUpdate x) (Reflex.Spider.Internal.EventM x)
instance Reflex.Spider.Internal.HasSpiderTimeline x => Reflex.Spider.Internal.Defer (Reflex.Spider.Internal.SomeMergeInit x) (Reflex.Spider.Internal.EventM x)
instance Reflex.Spider.Internal.HasSpiderTimeline x => Reflex.Spider.Internal.HasCurrentHeight x (Reflex.Spider.Internal.EventM x)
instance Reflex.Spider.Internal.HasSpiderTimeline Reflex.Spider.Internal.Global
instance Reflex.Spider.Internal.HasSpiderTimeline x => Reflex.Spider.Internal.Defer Reflex.Spider.Internal.SomeClear (Reflex.Spider.Internal.EventM x)
instance Reflex.Spider.Internal.HasSpiderTimeline x => Reflex.Spider.Internal.Defer Reflex.Spider.Internal.SomeIntClear (Reflex.Spider.Internal.EventM x)
instance Reflex.Spider.Internal.HasSpiderTimeline x => Reflex.Spider.Internal.Defer Reflex.Spider.Internal.SomeRootClear (Reflex.Spider.Internal.EventM x)
instance Reflex.Spider.Internal.HasSpiderTimeline x => Reflex.Spider.Internal.Defer (Reflex.Spider.Internal.SomeResetCoincidence x) (Reflex.Spider.Internal.EventM x)
instance GHC.Base.Monad (Reflex.Spider.Internal.BehaviorM x)
instance Reflex.Spider.Internal.HasSpiderTimeline x => Reflex.FunctorMaybe.FunctorMaybe (Reflex.Spider.Internal.Event x)
instance Reflex.Spider.Internal.HasSpiderTimeline x => Data.Align.Align (Reflex.Spider.Internal.Event x)
instance Reflex.Spider.Internal.HasSpiderTimeline x => GHC.Base.Functor (Reflex.Spider.Internal.Event x)
instance GHC.Base.Functor (Reflex.Spider.Internal.Behavior x)
instance Reflex.Spider.Internal.HasSpiderTimeline x => Reflex.Class.MonadSample (Reflex.Spider.Internal.SpiderTimeline x) (Reflex.Spider.Internal.EventM x)
instance Reflex.Spider.Internal.HasSpiderTimeline x => Reflex.Class.MonadHold (Reflex.Spider.Internal.SpiderTimeline x) (Reflex.Spider.Internal.EventM x)
instance Reflex.Class.MonadSample (Reflex.Spider.Internal.SpiderTimeline x) (Reflex.Spider.Internal.SpiderPullM x)
instance Reflex.Spider.Internal.HasSpiderTimeline x => Reflex.Class.MonadSample (Reflex.Spider.Internal.SpiderTimeline x) (Reflex.Spider.Internal.SpiderPushM x)
instance Reflex.Spider.Internal.HasSpiderTimeline x => Reflex.Class.MonadHold (Reflex.Spider.Internal.SpiderTimeline x) (Reflex.Spider.Internal.SpiderPushM x)
instance Reflex.Spider.Internal.HasSpiderTimeline x => GHC.Base.Monad (Reflex.Class.Dynamic (Reflex.Spider.Internal.SpiderTimeline x))
instance Reflex.Spider.Internal.HasSpiderTimeline x => GHC.Base.Functor (Reflex.Class.Dynamic (Reflex.Spider.Internal.SpiderTimeline x))
instance Reflex.Spider.Internal.HasSpiderTimeline x => GHC.Base.Applicative (Reflex.Class.Dynamic (Reflex.Spider.Internal.SpiderTimeline x))
instance Reflex.Spider.Internal.HasSpiderTimeline x => Reflex.Class.MonadHold (Reflex.Spider.Internal.SpiderTimeline x) (Reflex.Spider.Internal.SpiderHost x)
instance Reflex.Spider.Internal.HasSpiderTimeline x => Reflex.Class.MonadSample (Reflex.Spider.Internal.SpiderTimeline x) (Reflex.Spider.Internal.SpiderHostFrame x)
instance Reflex.Spider.Internal.HasSpiderTimeline x => Reflex.Class.MonadHold (Reflex.Spider.Internal.SpiderTimeline x) (Reflex.Spider.Internal.SpiderHostFrame x)
instance Reflex.Spider.Internal.HasSpiderTimeline x => Reflex.Class.MonadSample (Reflex.Spider.Internal.SpiderTimeline x) (Reflex.Spider.Internal.SpiderHost x)
instance Reflex.Spider.Internal.HasSpiderTimeline x => Reflex.Class.MonadSample (Reflex.Spider.Internal.SpiderTimeline x) (Reflex.Spider.Internal.ReadPhase x)
instance Reflex.Spider.Internal.HasSpiderTimeline x => Reflex.Class.MonadHold (Reflex.Spider.Internal.SpiderTimeline x) (Reflex.Spider.Internal.ReadPhase x)
instance Reflex.Spider.Internal.HasSpiderTimeline x => Reflex.Host.Class.MonadSubscribeEvent (Reflex.Spider.Internal.SpiderTimeline x) (Reflex.Spider.Internal.SpiderHostFrame x)
instance Reflex.Spider.Internal.HasSpiderTimeline x => Reflex.Host.Class.ReflexHost (Reflex.Spider.Internal.SpiderTimeline x)
instance Reflex.Spider.Internal.HasSpiderTimeline x => Reflex.Host.Class.MonadReadEvent (Reflex.Spider.Internal.SpiderTimeline x) (Reflex.Spider.Internal.ReadPhase x)
instance Reflex.Host.Class.MonadReflexCreateTrigger (Reflex.Spider.Internal.SpiderTimeline x) (Reflex.Spider.Internal.SpiderHost x)
instance Reflex.Host.Class.MonadReflexCreateTrigger (Reflex.Spider.Internal.SpiderTimeline x) (Reflex.Spider.Internal.SpiderHostFrame x)
instance Reflex.Spider.Internal.HasSpiderTimeline x => Reflex.Host.Class.MonadSubscribeEvent (Reflex.Spider.Internal.SpiderTimeline x) (Reflex.Spider.Internal.SpiderHost x)
instance Reflex.Spider.Internal.HasSpiderTimeline x => Reflex.Host.Class.MonadReflexHost (Reflex.Spider.Internal.SpiderTimeline x) (Reflex.Spider.Internal.SpiderHost x)
instance Data.Reflection.Reifies s (Reflex.Spider.Internal.SpiderTimelineEnv x) => Reflex.Spider.Internal.HasSpiderTimeline (Reflex.Spider.Internal.LocalSpiderTimeline x s)
instance Reflex.Spider.Internal.HasSpiderTimeline x => Reflex.Class.Reflex (Reflex.Spider.Internal.SpiderTimeline x)
instance Control.Monad.Ref.MonadRef (Reflex.Spider.Internal.EventM x)
instance Control.Monad.Ref.MonadAtomicRef (Reflex.Spider.Internal.EventM x)
instance GHC.Base.Monad (Reflex.Spider.Internal.SpiderHost x)
instance GHC.Base.Monad (Reflex.Spider.Internal.SpiderHostFrame x)
instance Reflex.NotReady.Class.NotReady x (Reflex.Spider.Internal.SpiderHostFrame x)
instance Control.Monad.Ref.MonadRef (Reflex.Spider.Internal.SpiderHost x)
instance Control.Monad.Ref.MonadAtomicRef (Reflex.Spider.Internal.SpiderHost x)
instance Control.Monad.Ref.MonadRef (Reflex.Spider.Internal.SpiderHostFrame x)
instance Control.Monad.Ref.MonadAtomicRef (Reflex.Spider.Internal.SpiderHostFrame x)
instance Control.Monad.Primitive.PrimMonad (Reflex.Spider.Internal.SpiderHostFrame x)


-- | This module exports all of the user-facing functionality of the
--   <a>Spider</a> <tt>Reflex</tt> engine
module Reflex.Spider

-- | The default, global Spider environment
type Spider = SpiderTimeline Global

-- | Designates the default, global Spider timeline
data SpiderTimeline x

-- | A statically allocated <a>SpiderTimeline</a>; this is the only
--   instance of <a>SpiderTimeline</a> that can used when using
--   -fspecialize-to-spidertimeline-global.
data Global

-- | The monad for actions that manipulate a Spider timeline identified by
--   <tt>x</tt>
data SpiderHost x a

-- | Run an action affecting the global Spider timeline; this will be
--   guarded by a mutex for that timeline
runSpiderHost :: SpiderHost Global a -> IO a

-- | Run an action affecting a given Spider timeline; this will be guarded
--   by a mutex for that timeline
runSpiderHostForTimeline :: SpiderHost x a -> SpiderTimelineEnv x -> IO a

-- | Create a new SpiderTimelineEnv
newSpiderTimeline :: IO (Some SpiderTimelineEnv)

-- | Pass a new timeline to the given function.
withSpiderTimeline :: (forall x. HasSpiderTimeline x => SpiderTimelineEnv x -> IO r) -> IO r

-- | <a>SpiderEnv</a> is the old name for <a>SpiderTimeline</a>

-- | <i>Deprecated: Use <a>SpiderTimelineEnv</a> instead</i>
type SpiderEnv = SpiderTimeline


-- | This module exports all of the commonly-used functionality of Reflex;
--   if you are just getting started with Reflex, this is probably what you
--   want.
module Reflex


-- | <a>Map</a> with a better <a>Monoid</a> instance
--   
--   <a>Map</a> has <tt>mappend = union</tt>, which is left-biased.
--   AppendMap has <tt>mappend = unionWith mappend</tt> instead.
module Data.AppendMap
newtype AppendMap k m
AppendMap :: Map k m -> AppendMap k m
[_unAppendMap] :: AppendMap k m -> Map k m

-- | Deletes a key, returning <a>Nothing</a> if the result is empty.
nonEmptyDelete :: Ord k => k -> AppendMap k a -> Maybe (AppendMap k a)
mapMaybeNoNull :: (a -> Maybe b) -> AppendMap token a -> Maybe (AppendMap token b)
(!) :: forall k a. Ord k => AppendMap k a -> k -> a
infixl 9 !
(\\) :: forall k a b. Ord k => AppendMap k a -> AppendMap k b -> AppendMap k a
infixl 9 \\
null :: forall k a. AppendMap k a -> Bool
size :: forall k a. AppendMap k a -> Int
member :: forall k a. Ord k => k -> AppendMap k a -> Bool
notMember :: forall k a. Ord k => k -> AppendMap k a -> Bool
lookup :: forall k a. Ord k => k -> AppendMap k a -> Maybe a
findWithDefault :: forall k a. Ord k => a -> k -> AppendMap k a -> a
lookupLT :: forall k a. Ord k => k -> AppendMap k a -> Maybe (k, a)
lookupGT :: forall k a. Ord k => k -> AppendMap k a -> Maybe (k, a)
lookupLE :: forall k a. Ord k => k -> AppendMap k a -> Maybe (k, a)
lookupGE :: forall k a. Ord k => k -> AppendMap k a -> Maybe (k, a)
empty :: forall k a. AppendMap k a
singleton :: forall k a. k -> a -> AppendMap k a
insert :: forall k a. Ord k => k -> a -> AppendMap k a -> AppendMap k a
insertWith :: forall k a. Ord k => (a -> a -> a) -> k -> a -> AppendMap k a -> AppendMap k a
insertWithKey :: forall k a. Ord k => (k -> a -> a -> a) -> k -> a -> AppendMap k a -> AppendMap k a
insertLookupWithKey :: forall k a. Ord k => (k -> a -> a -> a) -> k -> a -> AppendMap k a -> (Maybe a, AppendMap k a)
delete :: forall k a. Ord k => k -> AppendMap k a -> AppendMap k a
adjust :: forall k a. Ord k => (a -> a) -> k -> AppendMap k a -> AppendMap k a
adjustWithKey :: forall k a. Ord k => (k -> a -> a) -> k -> AppendMap k a -> AppendMap k a
update :: forall k a. Ord k => (a -> Maybe a) -> k -> AppendMap k a -> AppendMap k a
updateWithKey :: forall k a. Ord k => (k -> a -> Maybe a) -> k -> AppendMap k a -> AppendMap k a
updateLookupWithKey :: forall k a. Ord k => (k -> a -> Maybe a) -> k -> AppendMap k a -> (Maybe a, AppendMap k a)
alter :: forall k a. Ord k => (Maybe a -> Maybe a) -> k -> AppendMap k a -> AppendMap k a
unionWith :: forall k a. Ord k => (a -> a -> a) -> AppendMap k a -> AppendMap k a -> AppendMap k a
unionWithKey :: forall k a. Ord k => (k -> a -> a -> a) -> AppendMap k a -> AppendMap k a -> AppendMap k a
unionsWith :: forall k a. Ord k => (a -> a -> a) -> [AppendMap k a] -> AppendMap k a
difference :: forall k a b. Ord k => AppendMap k a -> AppendMap k b -> AppendMap k a
differenceWith :: forall k a b. Ord k => (a -> b -> Maybe a) -> AppendMap k a -> AppendMap k b -> AppendMap k a
differenceWithKey :: forall k a b. Ord k => (k -> a -> b -> Maybe a) -> AppendMap k a -> AppendMap k b -> AppendMap k a
intersectionWith :: forall k a b c. Ord k => (a -> b -> c) -> AppendMap k a -> AppendMap k b -> AppendMap k c
intersectionWithKey :: forall k a b c. Ord k => (k -> a -> b -> c) -> AppendMap k a -> AppendMap k b -> AppendMap k c
mergeWithKey :: forall k a b c. Ord k => (k -> a -> b -> Maybe c) -> (AppendMap k a -> AppendMap k c) -> (AppendMap k b -> AppendMap k c) -> AppendMap k a -> AppendMap k b -> AppendMap k c
map :: (a -> b) -> AppendMap k a -> AppendMap k b
mapWithKey :: (k -> a -> b) -> AppendMap k a -> AppendMap k b
traverseWithKey :: Applicative t => (k -> a -> t b) -> AppendMap k a -> t (AppendMap k b)
mapAccum :: forall k a b c. (a -> b -> (a, c)) -> a -> AppendMap k b -> (a, AppendMap k c)
mapAccumWithKey :: forall k a b c. (a -> k -> b -> (a, c)) -> a -> AppendMap k b -> (a, AppendMap k c)
mapAccumRWithKey :: forall k a b c. (a -> k -> b -> (a, c)) -> a -> AppendMap k b -> (a, AppendMap k c)
mapKeys :: forall k1 k2 a. Ord k2 => (k1 -> k2) -> AppendMap k1 a -> AppendMap k2 a
mapKeysWith :: forall k1 k2 a. Ord k2 => (a -> a -> a) -> (k1 -> k2) -> AppendMap k1 a -> AppendMap k2 a
mapKeysMonotonic :: forall k1 k2 a. (k1 -> k2) -> AppendMap k1 a -> AppendMap k2 a
foldr :: forall k a b. (a -> b -> b) -> b -> AppendMap k a -> b
foldl :: forall k a b. (a -> b -> a) -> a -> AppendMap k b -> a
foldrWithKey :: forall k a b. (k -> a -> b -> b) -> b -> AppendMap k a -> b
foldlWithKey :: forall k a b. (a -> k -> b -> a) -> a -> AppendMap k b -> a
foldMapWithKey :: forall k a m. Monoid m => (k -> a -> m) -> AppendMap k a -> m
foldr' :: forall k a b. (a -> b -> b) -> b -> AppendMap k a -> b
foldl' :: forall k a b. (a -> b -> a) -> a -> AppendMap k b -> a
foldrWithKey' :: forall k a b. (k -> a -> b -> b) -> b -> AppendMap k a -> b
foldlWithKey' :: forall k a b. (a -> k -> b -> a) -> a -> AppendMap k b -> a
elems :: forall k a. AppendMap k a -> [a]
keys :: forall k a. AppendMap k a -> [k]
assocs :: forall k a. AppendMap k a -> [(k, a)]
keysSet :: forall k a. AppendMap k a -> Set k
fromSet :: forall k a. (k -> a) -> Set k -> AppendMap k a
toList :: forall k a. AppendMap k a -> [(k, a)]
fromList :: forall k a. Ord k => [(k, a)] -> AppendMap k a
fromListWith :: forall k a. Ord k => (a -> a -> a) -> [(k, a)] -> AppendMap k a
fromListWithKey :: forall k a. Ord k => (k -> a -> a -> a) -> [(k, a)] -> AppendMap k a
toAscList :: forall k a. AppendMap k a -> [(k, a)]
toDescList :: forall k a. AppendMap k a -> [(k, a)]
fromAscList :: forall k a. Eq k => [(k, a)] -> AppendMap k a
fromAscListWith :: forall k a. Eq k => (a -> a -> a) -> [(k, a)] -> AppendMap k a
fromAscListWithKey :: forall k a. Eq k => (k -> a -> a -> a) -> [(k, a)] -> AppendMap k a
fromDistinctAscList :: forall k a. [(k, a)] -> AppendMap k a
filter :: forall k a. (a -> Bool) -> AppendMap k a -> AppendMap k a
filterWithKey :: forall k a. (k -> a -> Bool) -> AppendMap k a -> AppendMap k a
partition :: forall k a. (a -> Bool) -> AppendMap k a -> (AppendMap k a, AppendMap k a)
partitionWithKey :: forall k a. (k -> a -> Bool) -> AppendMap k a -> (AppendMap k a, AppendMap k a)
mapMaybe :: forall k a b. (a -> Maybe b) -> AppendMap k a -> AppendMap k b
mapMaybeWithKey :: forall k a b. (k -> a -> Maybe b) -> AppendMap k a -> AppendMap k b
mapEither :: forall k a b c. (a -> Either b c) -> AppendMap k a -> (AppendMap k b, AppendMap k c)
mapEitherWithKey :: forall k a b c. (k -> a -> Either b c) -> AppendMap k a -> (AppendMap k b, AppendMap k c)
split :: forall k a. Ord k => k -> AppendMap k a -> (AppendMap k a, AppendMap k a)
splitLookup :: forall k a. Ord k => k -> AppendMap k a -> (AppendMap k a, Maybe a, AppendMap k a)
splitRoot :: forall k a. AppendMap k a -> [AppendMap k a]
isSubmapOf :: forall k a. (Ord k, Eq a) => AppendMap k a -> AppendMap k a -> Bool
isSubmapOfBy :: forall k a b. Ord k => (a -> b -> Bool) -> AppendMap k a -> AppendMap k b -> Bool
isProperSubmapOf :: forall k a. (Ord k, Eq a) => AppendMap k a -> AppendMap k a -> Bool
isProperSubmapOfBy :: forall k a b. Ord k => (a -> b -> Bool) -> AppendMap k a -> AppendMap k b -> Bool
lookupIndex :: forall k a. Ord k => k -> AppendMap k a -> Maybe Int
findIndex :: forall k a. Ord k => k -> AppendMap k a -> Int
elemAt :: forall k a. Int -> AppendMap k a -> (k, a)
updateAt :: forall k a. (k -> a -> Maybe a) -> Int -> AppendMap k a -> AppendMap k a
deleteAt :: forall k a. Int -> AppendMap k a -> AppendMap k a
findMin :: forall k a. AppendMap k a -> (k, a)
findMax :: forall k a. AppendMap k a -> (k, a)
deleteMin :: forall k a. AppendMap k a -> AppendMap k a
deleteMax :: forall k a. AppendMap k a -> AppendMap k a
deleteFindMin :: forall k a. AppendMap k a -> ((k, a), AppendMap k a)
deleteFindMax :: forall k a. AppendMap k a -> ((k, a), AppendMap k a)
updateMin :: forall k a. (a -> Maybe a) -> AppendMap k a -> AppendMap k a
updateMax :: forall k a. (a -> Maybe a) -> AppendMap k a -> AppendMap k a
updateMinWithKey :: forall k a. (k -> a -> Maybe a) -> AppendMap k a -> AppendMap k a
updateMaxWithKey :: forall k a. (k -> a -> Maybe a) -> AppendMap k a -> AppendMap k a
minView :: forall k a. AppendMap k a -> Maybe (a, AppendMap k a)
maxView :: forall k a. AppendMap k a -> Maybe (a, AppendMap k a)
minViewWithKey :: forall k a. AppendMap k a -> Maybe ((k, a), AppendMap k a)
maxViewWithKey :: forall k a. AppendMap k a -> Maybe ((k, a), AppendMap k a)
showTree :: forall k a. (Show k, Show a) => AppendMap k a -> String
showTreeWith :: forall k a. (k -> a -> String) -> Bool -> Bool -> AppendMap k a -> String
valid :: forall k a. Ord k => AppendMap k a -> Bool
instance GHC.Classes.Ord k => Data.Align.Align (Data.AppendMap.AppendMap k)
instance Data.Traversable.Traversable (Data.AppendMap.AppendMap k)
instance Data.Foldable.Foldable (Data.AppendMap.AppendMap k)
instance GHC.Base.Functor (Data.AppendMap.AppendMap k)
instance GHC.Generics.Generic (Data.AppendMap.AppendMap k m)
instance (GHC.Read.Read m, GHC.Read.Read k, GHC.Classes.Ord k) => GHC.Read.Read (Data.AppendMap.AppendMap k m)
instance (GHC.Show.Show m, GHC.Show.Show k) => GHC.Show.Show (Data.AppendMap.AppendMap k m)
instance (GHC.Classes.Ord m, GHC.Classes.Ord k) => GHC.Classes.Ord (Data.AppendMap.AppendMap k m)
instance (GHC.Classes.Eq m, GHC.Classes.Eq k) => GHC.Classes.Eq (Data.AppendMap.AppendMap k m)
instance GHC.Classes.Ord k => Control.Lens.At.Ixed (Data.AppendMap.AppendMap k m)
instance GHC.Classes.Ord k => Control.Lens.At.At (Data.AppendMap.AppendMap k m)
instance Reflex.FunctorMaybe.FunctorMaybe (Data.AppendMap.AppendMap k)
instance Control.Lens.Indexed.FunctorWithIndex k (Data.AppendMap.AppendMap k)
instance Control.Lens.Indexed.FoldableWithIndex k (Data.AppendMap.AppendMap k)
instance Control.Lens.Indexed.TraversableWithIndex k (Data.AppendMap.AppendMap k)
instance (GHC.Classes.Ord k, Data.Semigroup.Semigroup m) => Data.Semigroup.Semigroup (Data.AppendMap.AppendMap k m)
instance (GHC.Classes.Ord k, Data.Semigroup.Semigroup m) => GHC.Base.Monoid (Data.AppendMap.AppendMap k m)
instance (GHC.Classes.Ord k, Reflex.Patch.Group q) => Reflex.Patch.Group (Data.AppendMap.AppendMap k q)
instance (GHC.Classes.Ord k, Reflex.Patch.Additive q) => Reflex.Patch.Additive (Data.AppendMap.AppendMap k q)
instance Data.Default.Class.Default (Data.AppendMap.AppendMap k a)
instance Data.AppendMap.AppendMap k' v' ~ t => Control.Lens.Wrapped.Rewrapped (Data.AppendMap.AppendMap k a) t
instance Control.Lens.Wrapped.Wrapped (Data.AppendMap.AppendMap k a)
