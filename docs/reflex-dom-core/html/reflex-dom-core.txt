-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Functional Reactive Web Apps with Reflex
--   
--   Reflex-DOM is a Functional Reactive web framework based on the Reflex
--   FRP engine
@url http://dfordivam.github.io/reflex-haddock/docs/reflex-dom-core/html/
@package reflex-dom-core
@version 0.4


-- | <i>Deprecated: Use Reflex.Time instead</i>
module Reflex.Dom.Time

module Reflex.Dom.Modals.Class
class ModalOpener t m
requestingModal :: ModalOpener t m => Event t (m (Event t a)) -> m (Event t (Maybe a))

module Reflex.Dom.Modals.Base

module Reflex.Dom.Builder.Class.Events
data EventTag
AbortTag :: EventTag
BlurTag :: EventTag
ChangeTag :: EventTag
ClickTag :: EventTag
ContextmenuTag :: EventTag
DblclickTag :: EventTag
DragTag :: EventTag
DragendTag :: EventTag
DragenterTag :: EventTag
DragleaveTag :: EventTag
DragoverTag :: EventTag
DragstartTag :: EventTag
DropTag :: EventTag
ErrorTag :: EventTag
FocusTag :: EventTag
InputTag :: EventTag
InvalidTag :: EventTag
KeydownTag :: EventTag
KeypressTag :: EventTag
KeyupTag :: EventTag
LoadTag :: EventTag
MousedownTag :: EventTag
MouseenterTag :: EventTag
MouseleaveTag :: EventTag
MousemoveTag :: EventTag
MouseoutTag :: EventTag
MouseoverTag :: EventTag
MouseupTag :: EventTag
MousewheelTag :: EventTag
ScrollTag :: EventTag
SelectTag :: EventTag
SubmitTag :: EventTag
WheelTag :: EventTag
BeforecutTag :: EventTag
CutTag :: EventTag
BeforecopyTag :: EventTag
CopyTag :: EventTag
BeforepasteTag :: EventTag
PasteTag :: EventTag
ResetTag :: EventTag
SearchTag :: EventTag
SelectstartTag :: EventTag
TouchstartTag :: EventTag
TouchmoveTag :: EventTag
TouchendTag :: EventTag
TouchcancelTag :: EventTag
data EventName :: EventTag -> *
[Abort] :: EventName AbortTag
[Blur] :: EventName BlurTag
[Change] :: EventName ChangeTag
[Click] :: EventName ClickTag
[Contextmenu] :: EventName ContextmenuTag
[Dblclick] :: EventName DblclickTag
[Drag] :: EventName DragTag
[Dragend] :: EventName DragendTag
[Dragenter] :: EventName DragenterTag
[Dragleave] :: EventName DragleaveTag
[Dragover] :: EventName DragoverTag
[Dragstart] :: EventName DragstartTag
[Drop] :: EventName DropTag
[Error] :: EventName ErrorTag
[Focus] :: EventName FocusTag
[Input] :: EventName InputTag
[Invalid] :: EventName InvalidTag
[Keydown] :: EventName KeydownTag
[Keypress] :: EventName KeypressTag
[Keyup] :: EventName KeyupTag
[Load] :: EventName LoadTag
[Mousedown] :: EventName MousedownTag
[Mouseenter] :: EventName MouseenterTag
[Mouseleave] :: EventName MouseleaveTag
[Mousemove] :: EventName MousemoveTag
[Mouseout] :: EventName MouseoutTag
[Mouseover] :: EventName MouseoverTag
[Mouseup] :: EventName MouseupTag
[Mousewheel] :: EventName MousewheelTag
[Scroll] :: EventName ScrollTag
[Select] :: EventName SelectTag
[Submit] :: EventName SubmitTag
[Wheel] :: EventName WheelTag
[Beforecut] :: EventName BeforecutTag
[Cut] :: EventName CutTag
[Beforecopy] :: EventName BeforecopyTag
[Copy] :: EventName CopyTag
[Beforepaste] :: EventName BeforepasteTag
[Paste] :: EventName PasteTag
[Reset] :: EventName ResetTag
[Search] :: EventName SearchTag
[Selectstart] :: EventName SelectstartTag
[Touchstart] :: EventName TouchstartTag
[Touchmove] :: EventName TouchmoveTag
[Touchend] :: EventName TouchendTag
[Touchcancel] :: EventName TouchcancelTag
newtype EventResult en
EventResult :: EventResultType en -> EventResult en
[unEventResult] :: EventResult en -> EventResultType en
data TouchEventResult
TouchEventResult :: Bool -> [TouchResult] -> Bool -> Bool -> Bool -> [TouchResult] -> [TouchResult] -> TouchEventResult
[_touchEventResult_altKey] :: TouchEventResult -> Bool
[_touchEventResult_changedTouches] :: TouchEventResult -> [TouchResult]
[_touchEventResult_ctrlKey] :: TouchEventResult -> Bool
[_touchEventResult_metaKey] :: TouchEventResult -> Bool
[_touchEventResult_shiftKey] :: TouchEventResult -> Bool
[_touchEventResult_targetTouches] :: TouchEventResult -> [TouchResult]
[_touchEventResult_touches] :: TouchEventResult -> [TouchResult]
data TouchResult
TouchResult :: Word -> Int -> Int -> Int -> Int -> Int -> Int -> TouchResult
[_touchResult_identifier] :: TouchResult -> Word
[_touchResult_screenX] :: TouchResult -> Int
[_touchResult_screenY] :: TouchResult -> Int
[_touchResult_clientX] :: TouchResult -> Int
[_touchResult_clientY] :: TouchResult -> Int
[_touchResult_pageX] :: TouchResult -> Int
[_touchResult_pageY] :: TouchResult -> Int
instance Data.GADT.Compare.GCompare Reflex.Dom.Builder.Class.Events.EventName
instance Data.GADT.Compare.GEq Reflex.Dom.Builder.Class.Events.EventName
instance GHC.Classes.Ord Reflex.Dom.Builder.Class.Events.TouchEventResult
instance GHC.Classes.Eq Reflex.Dom.Builder.Class.Events.TouchEventResult
instance GHC.Read.Read Reflex.Dom.Builder.Class.Events.TouchEventResult
instance GHC.Show.Show Reflex.Dom.Builder.Class.Events.TouchEventResult
instance GHC.Classes.Ord Reflex.Dom.Builder.Class.Events.TouchResult
instance GHC.Classes.Eq Reflex.Dom.Builder.Class.Events.TouchResult
instance GHC.Read.Read Reflex.Dom.Builder.Class.Events.TouchResult
instance GHC.Show.Show Reflex.Dom.Builder.Class.Events.TouchResult

module Reflex.Dom.Builder.Class
class Default (EventSpec d EventResult) => DomSpace d where type EventSpec d :: (EventTag -> *) -> * type RawTextNode d :: * type RawElement d :: * type RawFile d :: * type RawInputElement d :: * type RawTextAreaElement d :: * type RawSelectElement d :: * where {
    type family EventSpec d :: (EventTag -> *) -> *;
    type family RawTextNode d :: *;
    type family RawElement d :: *;
    type family RawFile d :: *;
    type family RawInputElement d :: *;
    type family RawTextAreaElement d :: *;
    type family RawSelectElement d :: *;
}
addEventSpecFlags :: DomSpace d => proxy d -> EventName en -> (Maybe (er en) -> EventFlags) -> EventSpec d er -> EventSpec d er

-- | <tt><a>DomBuilder</a> t m</tt> indicates that <tt>m</tt> is a
--   <a>Monad</a> capable of building dynamic DOM in the <a>Reflex</a>
--   timeline <tt>t</tt>
class (Monad m, Reflex t, DomSpace (DomBuilderSpace m), NotReady t m, Adjustable t m) => DomBuilder t m | m -> t where type DomBuilderSpace m :: * textNode = lift . textNode element t cfg child = liftWith $ \ run -> element t cfg $ run child inputElement = lift . inputElement textAreaElement = lift . textAreaElement selectElement cfg child = do { liftWith $ \ run -> selectElement cfg $ run child } placeRawElement = lift . placeRawElement wrapRawElement e cfg = lift $ wrapRawElement e $ cfg {_rawElementConfig_eventSpec = _rawElementConfig_eventSpec cfg} where {
    type family DomBuilderSpace m :: *;
}
textNode :: DomBuilder t m => TextNodeConfig t -> m (TextNode (DomBuilderSpace m) t)
textNode :: (DomBuilder t m, MonadTrans f, m ~ f m', DomBuilderSpace m' ~ DomBuilderSpace m, DomBuilder t m') => TextNodeConfig t -> m (TextNode (DomBuilderSpace m) t)
element :: DomBuilder t m => Text -> ElementConfig er t (DomBuilderSpace m) -> m a -> m (Element er (DomBuilderSpace m) t, a)
element :: (DomBuilder t m, MonadTransControl f, StT f a ~ a, m ~ f m', DomBuilderSpace m' ~ DomBuilderSpace m, DomBuilder t m') => Text -> ElementConfig er t (DomBuilderSpace m) -> m a -> m (Element er (DomBuilderSpace m) t, a)
inputElement :: DomBuilder t m => InputElementConfig er t (DomBuilderSpace m) -> m (InputElement er (DomBuilderSpace m) t)
inputElement :: (DomBuilder t m, MonadTransControl f, m ~ f m', DomBuilderSpace m' ~ DomBuilderSpace m, DomBuilder t m') => InputElementConfig er t (DomBuilderSpace m) -> m (InputElement er (DomBuilderSpace m) t)
textAreaElement :: DomBuilder t m => TextAreaElementConfig er t (DomBuilderSpace m) -> m (TextAreaElement er (DomBuilderSpace m) t)
textAreaElement :: (DomBuilder t m, MonadTransControl f, m ~ f m', DomBuilderSpace m' ~ DomBuilderSpace m, DomBuilder t m') => TextAreaElementConfig er t (DomBuilderSpace m) -> m (TextAreaElement er (DomBuilderSpace m) t)
selectElement :: DomBuilder t m => SelectElementConfig er t (DomBuilderSpace m) -> m a -> m (SelectElement er (DomBuilderSpace m) t, a)
selectElement :: (DomBuilder t m, MonadTransControl f, StT f a ~ a, m ~ f m', DomBuilderSpace m' ~ DomBuilderSpace m, DomBuilder t m') => SelectElementConfig er t (DomBuilderSpace m) -> m a -> m (SelectElement er (DomBuilderSpace m) t, a)
placeRawElement :: DomBuilder t m => RawElement (DomBuilderSpace m) -> m ()
placeRawElement :: (DomBuilder t m, MonadTrans f, m ~ f m', DomBuilderSpace m' ~ DomBuilderSpace m, DomBuilder t m') => RawElement (DomBuilderSpace m) -> m ()
wrapRawElement :: DomBuilder t m => RawElement (DomBuilderSpace m) -> RawElementConfig er t (DomBuilderSpace m) -> m (Element er (DomBuilderSpace m) t)
wrapRawElement :: (DomBuilder t m, MonadTrans f, m ~ f m', DomBuilderSpace m' ~ DomBuilderSpace m, DomBuilder t m') => RawElement (DomBuilderSpace m) -> RawElementConfig er t (DomBuilderSpace m) -> m (Element er (DomBuilderSpace m) t)
class DomBuilder t m => MountableDomBuilder t m where type DomFragment m :: * where {
    type family DomFragment m :: *;
}
buildDomFragment :: MountableDomBuilder t m => m a -> m (DomFragment m, a)
mountDomFragment :: MountableDomBuilder t m => DomFragment m -> Event t (DomFragment m) -> m ()
type Namespace = Text
data TextNodeConfig t
TextNodeConfig :: {-# UNPACK #-} !Text -> !(Maybe (Event t Text)) -> TextNodeConfig t
[_textNodeConfig_initialContents] :: TextNodeConfig t -> {-# UNPACK #-} !Text
[_textNodeConfig_setContents] :: TextNodeConfig t -> !(Maybe (Event t Text))
newtype TextNode d t
TextNode :: RawTextNode d -> TextNode d t
[_textNode_raw] :: TextNode d t -> RawTextNode d
data AttributeName
AttributeName :: !(Maybe Namespace) -> !Text -> AttributeName
mapKeysToAttributeName :: Map Text v -> Map AttributeName v

-- | By default, AttributeNames are unnamespaced
data Propagation
Propagation_Continue :: Propagation
Propagation_Stop :: Propagation
Propagation_StopImmediate :: Propagation
data EventFlags
EventFlags :: Propagation -> Bool -> EventFlags
[_eventFlags_propagation] :: EventFlags -> Propagation
[_eventFlags_preventDefault] :: EventFlags -> Bool
preventDefault :: EventFlags
stopPropagation :: EventFlags
data ElementConfig er t s
ElementConfig :: Maybe Namespace -> Map AttributeName Text -> Maybe (Event t (Map AttributeName (Maybe Text))) -> EventSpec s er -> ElementConfig er t s
[_elementConfig_namespace] :: ElementConfig er t s -> Maybe Namespace
[_elementConfig_initialAttributes] :: ElementConfig er t s -> Map AttributeName Text
[_elementConfig_modifyAttributes] :: ElementConfig er t s -> Maybe (Event t (Map AttributeName (Maybe Text)))
[_elementConfig_eventSpec] :: ElementConfig er t s -> EventSpec s er
data Element er d t
Element :: EventSelector t (WrapArg er EventName) -> RawElement d -> Element er d t
[_element_events] :: Element er d t -> EventSelector t (WrapArg er EventName)
[_element_raw] :: Element er d t -> RawElement d
data InputElementConfig er t s
InputElementConfig :: Text -> Maybe (Event t Text) -> Bool -> Maybe (Event t Bool) -> ElementConfig er t s -> InputElementConfig er t s
[_inputElementConfig_initialValue] :: InputElementConfig er t s -> Text
[_inputElementConfig_setValue] :: InputElementConfig er t s -> Maybe (Event t Text)
[_inputElementConfig_initialChecked] :: InputElementConfig er t s -> Bool
[_inputElementConfig_setChecked] :: InputElementConfig er t s -> Maybe (Event t Bool)
[_inputElementConfig_elementConfig] :: InputElementConfig er t s -> ElementConfig er t s
data InputElement er d t
InputElement :: Dynamic t Text -> Dynamic t Bool -> Event t Bool -> Event t Text -> Dynamic t Bool -> Element er d t -> RawInputElement d -> Dynamic t [RawFile d] -> InputElement er d t
[_inputElement_value] :: InputElement er d t -> Dynamic t Text
[_inputElement_checked] :: InputElement er d t -> Dynamic t Bool
[_inputElement_checkedChange] :: InputElement er d t -> Event t Bool
[_inputElement_input] :: InputElement er d t -> Event t Text
[_inputElement_hasFocus] :: InputElement er d t -> Dynamic t Bool
[_inputElement_element] :: InputElement er d t -> Element er d t
[_inputElement_raw] :: InputElement er d t -> RawInputElement d
[_inputElement_files] :: InputElement er d t -> Dynamic t [RawFile d]
data TextAreaElementConfig er t m
TextAreaElementConfig :: Text -> Maybe (Event t Text) -> ElementConfig er t m -> TextAreaElementConfig er t m
[_textAreaElementConfig_initialValue] :: TextAreaElementConfig er t m -> Text
[_textAreaElementConfig_setValue] :: TextAreaElementConfig er t m -> Maybe (Event t Text)
[_textAreaElementConfig_elementConfig] :: TextAreaElementConfig er t m -> ElementConfig er t m
data TextAreaElement er d t
TextAreaElement :: Dynamic t Text -> Event t Text -> Dynamic t Bool -> Element er d t -> RawTextAreaElement d -> TextAreaElement er d t
[_textAreaElement_value] :: TextAreaElement er d t -> Dynamic t Text
[_textAreaElement_input] :: TextAreaElement er d t -> Event t Text
[_textAreaElement_hasFocus] :: TextAreaElement er d t -> Dynamic t Bool
[_textAreaElement_element] :: TextAreaElement er d t -> Element er d t
[_textAreaElement_raw] :: TextAreaElement er d t -> RawTextAreaElement d
extractRawElementConfig :: ElementConfig er t m -> RawElementConfig er t m
data RawElementConfig er t s
RawElementConfig :: Maybe (Event t (Map AttributeName (Maybe Text))) -> EventSpec s er -> RawElementConfig er t s
[_rawElementConfig_modifyAttributes] :: RawElementConfig er t s -> Maybe (Event t (Map AttributeName (Maybe Text)))
[_rawElementConfig_eventSpec] :: RawElementConfig er t s -> EventSpec s er
data SelectElementConfig er t m
SelectElementConfig :: Text -> Maybe (Event t Text) -> ElementConfig er t m -> SelectElementConfig er t m
[_selectElementConfig_initialValue] :: SelectElementConfig er t m -> Text
[_selectElementConfig_setValue] :: SelectElementConfig er t m -> Maybe (Event t Text)
[_selectElementConfig_elementConfig] :: SelectElementConfig er t m -> ElementConfig er t m
data SelectElement er d t
SelectElement :: Element er d t -> Dynamic t Text -> Event t Text -> Dynamic t Bool -> RawSelectElement d -> SelectElement er d t
[_selectElement_element] :: SelectElement er d t -> Element er d t
[_selectElement_value] :: SelectElement er d t -> Dynamic t Text

-- | Fires when the value is changed by the user, but not when it is set by
--   setValue
[_selectElement_change] :: SelectElement er d t -> Event t Text
[_selectElement_hasFocus] :: SelectElement er d t -> Dynamic t Bool
[_selectElement_raw] :: SelectElement er d t -> RawSelectElement d
selectElementConfig_initialValue :: forall er_a11R6 t_a11R7 m_a11R8. Lens' (SelectElementConfig er_a11R6 t_a11R7 m_a11R8) Text
selectElementConfig_elementConfig :: forall er_a11R6 t_a11R7 m_a11R8 er_a14Br m_a14Bs. Lens (SelectElementConfig er_a11R6 t_a11R7 m_a11R8) (SelectElementConfig er_a14Br t_a11R7 m_a14Bs) (ElementConfig er_a11R6 t_a11R7 m_a11R8) (ElementConfig er_a14Br t_a11R7 m_a14Bs)
textAreaElementConfig_initialValue :: forall er_a11YF t_a11YG m_a11YH. Lens' (TextAreaElementConfig er_a11YF t_a11YG m_a11YH) Text
textAreaElementConfig_elementConfig :: forall er_a11YF t_a11YG m_a11YH er_a14Bf m_a14Bg. Lens (TextAreaElementConfig er_a11YF t_a11YG m_a11YH) (TextAreaElementConfig er_a14Bf t_a11YG m_a14Bg) (ElementConfig er_a11YF t_a11YG m_a11YH) (ElementConfig er_a14Bf t_a11YG m_a14Bg)
elementConfig_namespace :: forall er_a11YR t_a11YS s_a11YT. Lens' (ElementConfig er_a11YR t_a11YS s_a11YT) (Maybe Namespace)
elementConfig_initialAttributes :: forall er_a11YR t_a11YS s_a11YT. Lens' (ElementConfig er_a11YR t_a11YS s_a11YT) (Map AttributeName Text)
elementConfig_eventSpec :: forall er_a11YR t_a11YS s_a11YT er_a14AV s_a14AW. Lens (ElementConfig er_a11YR t_a11YS s_a11YT) (ElementConfig er_a14AV t_a11YS s_a14AW) (EventSpec s_a11YT er_a11YR) (EventSpec s_a14AW er_a14AV)
rawElementConfig_eventSpec :: forall er_a11R9 t_a11Ra s_a11Rb er_a14AP s_a14AQ. Lens (RawElementConfig er_a11R9 t_a11Ra s_a11Rb) (RawElementConfig er_a14AP t_a11Ra s_a14AQ) (EventSpec s_a11Rb er_a11R9) (EventSpec s_a14AQ er_a14AP)
inputElementConfig_initialValue :: forall er_a11YL t_a11YM s_a11YN. Lens' (InputElementConfig er_a11YL t_a11YM s_a11YN) Text
inputElementConfig_initialChecked :: forall er_a11YL t_a11YM s_a11YN. Lens' (InputElementConfig er_a11YL t_a11YM s_a11YN) Bool
inputElementConfig_elementConfig :: forall er_a11YL t_a11YM s_a11YN er_a14As s_a14At. Lens (InputElementConfig er_a11YL t_a11YM s_a11YN) (InputElementConfig er_a14As t_a11YM s_a14At) (ElementConfig er_a11YL t_a11YM s_a11YN) (ElementConfig er_a14As t_a11YM s_a14At)
textNodeConfig_initialContents :: forall t_a11YW. Lens' (TextNodeConfig t_a11YW) Text

-- | This lens is technically illegal. The implementation of
--   <a>TextNodeConfig</a> uses a <a>Maybe</a> under the hood for
--   efficiency reasons. However, always interacting with
--   <a>TextNodeConfig</a> via lenses will always behave correctly, and if
--   you pattern match on it, you should always treat <a>Nothing</a> as
--   <a>never</a>.
textNodeConfig_setContents :: Reflex t => Lens (TextNodeConfig t) (TextNodeConfig t) (Event t Text) (Event t Text)

-- | This lens is technically illegal. The implementation of
--   <a>InputElementConfig</a> uses a <a>Maybe</a> under the hood for
--   efficiency reasons. However, always interacting with
--   <a>InputElementConfig</a> via lenses will always behave correctly, and
--   if you pattern match on it, you should always treat <a>Nothing</a> as
--   <a>never</a>.
inputElementConfig_setValue :: Reflex t => Lens (InputElementConfig er t m) (InputElementConfig er t m) (Event t Text) (Event t Text)

-- | This lens is technically illegal. The implementation of
--   <a>InputElementConfig</a> uses a <a>Maybe</a> under the hood for
--   efficiency reasons. However, always interacting with
--   <a>InputElementConfig</a> via lenses will always behave correctly, and
--   if you pattern match on it, you should always treat <a>Nothing</a> as
--   <a>never</a>.
inputElementConfig_setChecked :: Reflex t => Lens (InputElementConfig er t m) (InputElementConfig er t m) (Event t Bool) (Event t Bool)

-- | This lens is technically illegal. The implementation of
--   <a>RawElementConfig</a> uses a <a>Maybe</a> under the hood for
--   efficiency reasons. However, always interacting with
--   <a>RawElementConfig</a> via lenses will always behave correctly, and
--   if you pattern match on it, you should always treat <a>Nothing</a> as
--   <a>never</a>.
rawElementConfig_modifyAttributes :: Reflex t => Lens (RawElementConfig er t m) (RawElementConfig er t m) (Event t (Map AttributeName (Maybe Text))) (Event t (Map AttributeName (Maybe Text)))

-- | This lens is technically illegal. The implementation of
--   <a>RawElementConfig</a> uses a <a>Maybe</a> under the hood for
--   efficiency reasons. However, always interacting with
--   <a>RawElementConfig</a> via lenses will always behave correctly, and
--   if you pattern match on it, you should always treat <a>Nothing</a> as
--   <a>never</a>.
elementConfig_modifyAttributes :: Reflex t => Lens (ElementConfig er t m) (ElementConfig er t m) (Event t (Map AttributeName (Maybe Text))) (Event t (Map AttributeName (Maybe Text)))

-- | This lens is technically illegal. The implementation of
--   <a>TextAreaElementConfig</a> uses a <a>Maybe</a> under the hood for
--   efficiency reasons. However, always interacting with
--   <a>TextAreaElementConfig</a> via lenses will always behave correctly,
--   and if you pattern match on it, you should always treat <a>Nothing</a>
--   as <a>never</a>.
textAreaElementConfig_setValue :: Reflex t => Lens (TextAreaElementConfig er t m) (TextAreaElementConfig er t m) (Event t Text) (Event t Text)

-- | This lens is technically illegal. The implementation of
--   <a>SelectElementConfig</a> uses a <a>Maybe</a> under the hood for
--   efficiency reasons. However, always interacting with
--   <a>SelectElementConfig</a> via lenses will always behave correctly,
--   and if you pattern match on it, you should always treat <a>Nothing</a>
--   as <a>never</a>.
selectElementConfig_setValue :: Reflex t => Lens (SelectElementConfig er t m) (SelectElementConfig er t m) (Event t Text) (Event t Text)
class InitialAttributes a
initialAttributes :: InitialAttributes a => Lens' a (Map AttributeName Text)
class ModifyAttributes t a | a -> t
modifyAttributes :: (ModifyAttributes t a, Reflex t) => Lens' a (Event t (Map AttributeName (Maybe Text)))
class HasNamespace a
namespace :: HasNamespace a => Lens' a (Maybe Namespace)
class HasDomEvent t target eventName where type DomEventType target eventName :: * where {
    type family DomEventType target eventName :: *;
}
domEvent :: HasDomEvent t target eventName => EventName eventName -> target -> Event t (DomEventType target eventName)
type LiftDomBuilder t f m = (Reflex t, MonadTransControlStateless f, Monad m, DomBuilder t m, DomBuilderSpace (f m) ~ DomBuilderSpace m)
class MonadTransControl t => MonadTransControlStateless t where stTCoercion _ = id
stTCoercion :: MonadTransControlStateless t => proxy t -> Coercion (StT t a) a
stTCoercion :: (MonadTransControlStateless t, a ~ StT t a) => proxy t -> Coercion (StT t a) a
toStT :: MonadTransControlStateless t => proxy t -> a -> StT t a
fromStT :: MonadTransControlStateless t => proxy t -> StT t a -> a
type RunStateless t = forall n b. Monad n => t n b -> n b
liftWithStateless :: forall m t a. (Monad m, MonadTransControlStateless t) => (RunStateless t -> m a) -> t m a
liftTextNode :: (MonadTrans f, DomBuilder t m) => TextNodeConfig t -> f m (TextNode (DomBuilderSpace m) t)
liftElement :: LiftDomBuilder t f m => Text -> ElementConfig er t (DomBuilderSpace m) -> f m a -> f m (Element er (DomBuilderSpace m) t, a)
class (Reflex t, Monad m) => DomRenderHook t m | m -> t
withRenderHook :: DomRenderHook t m => (forall x. JSM x -> JSM x) -> m a -> m a
requestDomAction :: DomRenderHook t m => Event t (JSM a) -> m (Event t a)
requestDomAction_ :: DomRenderHook t m => Event t (JSM a) -> m ()

-- | <i>Deprecated: Use <a>id</a> instead; this function is no longer
--   necessary</i>
liftElementConfig :: ElementConfig er t s -> ElementConfig er t s
instance Reflex.Dom.Builder.Class.DomRenderHook t m => Reflex.Dom.Builder.Class.DomRenderHook t (Reflex.EventWriter.EventWriterT t w m)
instance Reflex.Dom.Builder.Class.DomRenderHook t m => Reflex.Dom.Builder.Class.DomRenderHook t (Reflex.Requester.Base.RequesterT t req rsp m)
instance Reflex.Dom.Builder.Class.DomRenderHook t m => Reflex.Dom.Builder.Class.DomRenderHook t (Reflex.PostBuild.Base.PostBuildT t m)
instance Reflex.Dom.Builder.Class.DomRenderHook t m => Reflex.Dom.Builder.Class.DomRenderHook t (Reflex.Query.Base.QueryT t q m)
instance forall k (er :: Reflex.Dom.Builder.Class.Events.EventTag -> GHC.Types.*) t (m :: k). Reflex.Dom.Builder.Class.InitialAttributes (Reflex.Dom.Builder.Class.ElementConfig er t m)
instance forall k (er :: Reflex.Dom.Builder.Class.Events.EventTag -> GHC.Types.*) t (m :: k). Reflex.Dom.Builder.Class.InitialAttributes (Reflex.Dom.Builder.Class.InputElementConfig er t m)
instance forall k (er :: Reflex.Dom.Builder.Class.Events.EventTag -> GHC.Types.*) t (m :: k). Reflex.Dom.Builder.Class.InitialAttributes (Reflex.Dom.Builder.Class.TextAreaElementConfig er t m)
instance forall k (er :: Reflex.Dom.Builder.Class.Events.EventTag -> GHC.Types.*) t (m :: k). Reflex.Dom.Builder.Class.InitialAttributes (Reflex.Dom.Builder.Class.SelectElementConfig er t m)
instance forall k t (er :: Reflex.Dom.Builder.Class.Events.EventTag -> GHC.Types.*) (m :: k). Reflex.Dom.Builder.Class.ModifyAttributes t (Reflex.Dom.Builder.Class.ElementConfig er t m)
instance forall k t (er :: Reflex.Dom.Builder.Class.Events.EventTag -> GHC.Types.*) (m :: k). Reflex.Dom.Builder.Class.ModifyAttributes t (Reflex.Dom.Builder.Class.InputElementConfig er t m)
instance forall k t (er :: Reflex.Dom.Builder.Class.Events.EventTag -> GHC.Types.*) (m :: k). Reflex.Dom.Builder.Class.ModifyAttributes t (Reflex.Dom.Builder.Class.TextAreaElementConfig er t m)
instance forall k t (er :: Reflex.Dom.Builder.Class.Events.EventTag -> GHC.Types.*) (m :: k). Reflex.Dom.Builder.Class.ModifyAttributes t (Reflex.Dom.Builder.Class.SelectElementConfig er t m)
instance forall k t (er :: Reflex.Dom.Builder.Class.Events.EventTag -> GHC.Types.*) (m :: k). Reflex.Dom.Builder.Class.ModifyAttributes t (Reflex.Dom.Builder.Class.RawElementConfig er t m)
instance forall k (er :: Reflex.Dom.Builder.Class.Events.EventTag -> GHC.Types.*) t (m :: k). Reflex.Dom.Builder.Class.HasNamespace (Reflex.Dom.Builder.Class.ElementConfig er t m)
instance forall k t (er :: Reflex.Dom.Builder.Class.Events.EventTag -> *) (s :: k). (Reflex.Class.Reflex t, er ~ Reflex.Dom.Builder.Class.Events.EventResult, Reflex.Dom.Builder.Class.DomSpace s) => Data.Default.Class.Default (Reflex.Dom.Builder.Class.ElementConfig er t s)
instance (Reflex.Dom.Builder.Class.DomBuilder t m, Reflex.PerformEvent.Class.PerformEvent t m, Control.Monad.Fix.MonadFix m, Reflex.Class.MonadHold t m) => Reflex.Dom.Builder.Class.DomBuilder t (Reflex.PostBuild.Base.PostBuildT t m)
instance (Reflex.Dom.Builder.Class.MountableDomBuilder t m, Reflex.PerformEvent.Class.PerformEvent t m, Control.Monad.Fix.MonadFix m, Reflex.Class.MonadHold t m) => Reflex.Dom.Builder.Class.MountableDomBuilder t (Reflex.PostBuild.Base.PostBuildT t m)
instance (Reflex.Dom.Builder.Class.DomBuilder t m, GHC.Base.Monoid w, Reflex.Class.MonadHold t m, Control.Monad.Fix.MonadFix m) => Reflex.Dom.Builder.Class.DomBuilder t (Reflex.DynamicWriter.DynamicWriterT t w m)
instance (Reflex.Dom.Builder.Class.DomBuilder t m, Reflex.Class.MonadHold t m, Control.Monad.Fix.MonadFix m) => Reflex.Dom.Builder.Class.DomBuilder t (Reflex.Requester.Base.RequesterT t request response m)
instance (Reflex.Dom.Builder.Class.DomBuilder t m, Reflex.Class.MonadHold t m, Control.Monad.Fix.MonadFix m, Data.Semigroup.Semigroup w) => Reflex.Dom.Builder.Class.DomBuilder t (Reflex.EventWriter.EventWriterT t w m)
instance (Reflex.Dom.Builder.Class.DomBuilder t m, Control.Monad.Fix.MonadFix m, Reflex.Class.MonadHold t m, Reflex.Patch.Group q, Reflex.Query.Class.Query q, Reflex.Patch.Additive q) => Reflex.Dom.Builder.Class.DomBuilder t (Reflex.Query.Base.QueryT t q m)
instance forall k t (d :: k) (en :: Reflex.Dom.Builder.Class.Events.EventTag). Reflex.Class.Reflex t => Reflex.Dom.Builder.Class.HasDomEvent t (Reflex.Dom.Builder.Class.Element Reflex.Dom.Builder.Class.Events.EventResult d t) en
instance forall k t (d :: k) (en :: Reflex.Dom.Builder.Class.Events.EventTag). Reflex.Class.Reflex t => Reflex.Dom.Builder.Class.HasDomEvent t (Reflex.Dom.Builder.Class.InputElement Reflex.Dom.Builder.Class.Events.EventResult d t) en
instance forall k t (d :: k) (en :: Reflex.Dom.Builder.Class.Events.EventTag). Reflex.Class.Reflex t => Reflex.Dom.Builder.Class.HasDomEvent t (Reflex.Dom.Builder.Class.TextAreaElement Reflex.Dom.Builder.Class.Events.EventResult d t) en
instance Reflex.Dom.Builder.Class.DomBuilder t m => Reflex.Dom.Builder.Class.DomBuilder t (Control.Monad.Trans.Reader.ReaderT r m)
instance Reflex.Dom.Builder.Class.MonadTransControlStateless (Control.Monad.Trans.Reader.ReaderT r)
instance Reflex.Dom.Builder.Class.DomRenderHook t m => Reflex.Dom.Builder.Class.DomRenderHook t (Control.Monad.Trans.Reader.ReaderT e m)
instance Reflex.Dom.Builder.Class.DomRenderHook t m => Reflex.Dom.Builder.Class.DomRenderHook t (Control.Monad.Trans.State.Strict.StateT e m)
instance GHC.Classes.Ord Reflex.Dom.Builder.Class.Propagation
instance GHC.Classes.Eq Reflex.Dom.Builder.Class.Propagation
instance GHC.Read.Read Reflex.Dom.Builder.Class.Propagation
instance GHC.Show.Show Reflex.Dom.Builder.Class.Propagation
instance GHC.Classes.Ord Reflex.Dom.Builder.Class.AttributeName
instance GHC.Classes.Eq Reflex.Dom.Builder.Class.AttributeName
instance GHC.Read.Read Reflex.Dom.Builder.Class.AttributeName
instance GHC.Show.Show Reflex.Dom.Builder.Class.AttributeName
instance Reflex.Class.Reflex t => Data.Default.Class.Default (Reflex.Dom.Builder.Class.TextNodeConfig t)
instance Data.String.IsString Reflex.Dom.Builder.Class.AttributeName
instance Data.Semigroup.Semigroup Reflex.Dom.Builder.Class.Propagation
instance GHC.Base.Monoid Reflex.Dom.Builder.Class.Propagation
instance Data.Semigroup.Semigroup Reflex.Dom.Builder.Class.EventFlags
instance GHC.Base.Monoid Reflex.Dom.Builder.Class.EventFlags
instance forall k t (er :: Reflex.Dom.Builder.Class.Events.EventTag -> *) (s :: k). (Reflex.Class.Reflex t, er ~ Reflex.Dom.Builder.Class.Events.EventResult, Reflex.Dom.Builder.Class.DomSpace s) => Data.Default.Class.Default (Reflex.Dom.Builder.Class.InputElementConfig er t s)
instance forall k t (er :: Reflex.Dom.Builder.Class.Events.EventTag -> *) (s :: k). (Reflex.Class.Reflex t, er ~ Reflex.Dom.Builder.Class.Events.EventResult, Reflex.Dom.Builder.Class.DomSpace s) => Data.Default.Class.Default (Reflex.Dom.Builder.Class.TextAreaElementConfig er t s)
instance forall k t (er :: Reflex.Dom.Builder.Class.Events.EventTag -> *) (s :: k). (Reflex.Class.Reflex t, er ~ Reflex.Dom.Builder.Class.Events.EventResult, Reflex.Dom.Builder.Class.DomSpace s) => Data.Default.Class.Default (Reflex.Dom.Builder.Class.RawElementConfig er t s)
instance forall k t (er :: Reflex.Dom.Builder.Class.Events.EventTag -> *) (s :: k). (Reflex.Class.Reflex t, er ~ Reflex.Dom.Builder.Class.Events.EventResult, Reflex.Dom.Builder.Class.DomSpace s) => Data.Default.Class.Default (Reflex.Dom.Builder.Class.SelectElementConfig er t s)

module Reflex.Dom.Builder.Static
data StaticDomBuilderEnv t
StaticDomBuilderEnv :: Bool -> Maybe (Behavior t Text) -> StaticDomBuilderEnv t
[_staticDomBuilderEnv_shouldEscape] :: StaticDomBuilderEnv t -> Bool

-- | When the parent element is a "select" whose value has been set, this
--   value tells us the current value. We use this to add a "selected"
--   attribute to the appropriate "option" child element. This is not yet a
--   perfect simulation of what the browser does, but it is much closer
--   than doing nothing. TODO: Handle edge cases, e.g. setting to a value
--   for which there is no option, then adding that option dynamically
--   afterwards.
[_staticDomBuilderEnv_selectValue] :: StaticDomBuilderEnv t -> Maybe (Behavior t Text)
newtype StaticDomBuilderT t m a
StaticDomBuilderT :: ReaderT (StaticDomBuilderEnv t) (StateT [Behavior t Builder] m) a -> StaticDomBuilderT t m a
[unStaticDomBuilderT] :: StaticDomBuilderT t m a -> ReaderT (StaticDomBuilderEnv t) (StateT [Behavior t Builder] m) a
runStaticDomBuilderT :: (Monad m, Reflex t) => StaticDomBuilderT t m a -> StaticDomBuilderEnv t -> m (a, Behavior t Builder)
type SupportsStaticDomBuilder t m = (Reflex t, MonadIO m, MonadHold t m, MonadFix m, PerformEvent t m, MonadReflexCreateTrigger t m, MonadRef m, Ref m ~ Ref IO, Adjustable t m)
data StaticDomSpace

-- | Static documents never produce any events, so this type has no
--   inhabitants
data StaticDomEvent (a :: k)

-- | Static documents don't process events, so all handlers are equivalent
data StaticDomHandler (a :: k) (b :: k)
StaticDomHandler :: StaticDomHandler
data StaticEventSpec (er :: EventTag -> *)
StaticEventSpec :: StaticEventSpec
hoistDMapWithKeyWithAdjust :: forall (k :: * -> *) v v' t m p. (Adjustable t m, MonadHold t m, PatchTarget (p k (Constant (Behavior t Builder))) ~ DMap k (Constant (Behavior t Builder)), Patch (p k (Constant (Behavior t Builder)))) => (forall vv vv'. (forall a. k a -> vv a -> m (vv' a)) -> DMap k vv -> Event t (p k vv) -> m (DMap k vv', Event t (p k vv'))) -> (forall vv vv'. (forall a. vv a -> vv' a) -> p k vv -> p k vv') -> (forall a. k a -> v a -> StaticDomBuilderT t m (v' a)) -> DMap k v -> Event t (p k v) -> StaticDomBuilderT t m (DMap k v', Event t (p k v'))
type StaticWidget x = PostBuildT Spider (StaticDomBuilderT Spider (PerformEventT Spider (SpiderHost Global)))
renderStatic :: StaticWidget x a -> IO (a, ByteString)
instance GHC.Generics.Generic (Reflex.Dom.Builder.Static.StaticEventSpec er)
instance Control.Monad.Exception.MonadAsyncException m => Control.Monad.Exception.MonadAsyncException (Reflex.Dom.Builder.Static.StaticDomBuilderT t m)
instance Control.Monad.Exception.MonadException m => Control.Monad.Exception.MonadException (Reflex.Dom.Builder.Static.StaticDomBuilderT t m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Reflex.Dom.Builder.Static.StaticDomBuilderT t m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Reflex.Dom.Builder.Static.StaticDomBuilderT t m)
instance GHC.Base.Monad m => GHC.Base.Monad (Reflex.Dom.Builder.Static.StaticDomBuilderT t m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Reflex.Dom.Builder.Static.StaticDomBuilderT t m)
instance GHC.Base.Functor m => GHC.Base.Functor (Reflex.Dom.Builder.Static.StaticDomBuilderT t m)
instance Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Reflex.Dom.Builder.Static.StaticDomBuilderT x m)
instance Control.Monad.Trans.Class.MonadTrans (Reflex.Dom.Builder.Static.StaticDomBuilderT t)
instance Reflex.Host.Class.MonadReflexCreateTrigger t m => Reflex.Host.Class.MonadReflexCreateTrigger t (Reflex.Dom.Builder.Static.StaticDomBuilderT t m)
instance Reflex.PerformEvent.Class.PerformEvent t m => Reflex.PerformEvent.Class.PerformEvent t (Reflex.Dom.Builder.Static.StaticDomBuilderT t m)
instance Reflex.Class.MonadSample t m => Reflex.Class.MonadSample t (Reflex.Dom.Builder.Static.StaticDomBuilderT t m)
instance Reflex.Class.MonadHold t m => Reflex.Class.MonadHold t (Reflex.Dom.Builder.Static.StaticDomBuilderT t m)
instance (GHC.Base.Monad m, Control.Monad.Ref.Ref m ~ Control.Monad.Ref.Ref GHC.Types.IO, Reflex.Class.Reflex t) => Reflex.TriggerEvent.Class.TriggerEvent t (Reflex.Dom.Builder.Static.StaticDomBuilderT t m)
instance Control.Monad.Ref.MonadRef m => Control.Monad.Ref.MonadRef (Reflex.Dom.Builder.Static.StaticDomBuilderT t m)
instance Control.Monad.Ref.MonadAtomicRef m => Control.Monad.Ref.MonadAtomicRef (Reflex.Dom.Builder.Static.StaticDomBuilderT t m)
instance Data.Default.Class.Default (Reflex.Dom.Builder.Static.StaticEventSpec er)
instance Reflex.Dom.Builder.Class.DomSpace Reflex.Dom.Builder.Static.StaticDomSpace
instance (Reflex.Class.Reflex t, Reflex.Class.Adjustable t m, Reflex.Class.MonadHold t m) => Reflex.Class.Adjustable t (Reflex.Dom.Builder.Static.StaticDomBuilderT t m)
instance Reflex.Dom.Builder.Static.SupportsStaticDomBuilder t m => Reflex.NotReady.Class.NotReady t (Reflex.Dom.Builder.Static.StaticDomBuilderT t m)
instance Reflex.Dom.Builder.Static.SupportsStaticDomBuilder t m => Reflex.Dom.Builder.Class.DomBuilder t (Reflex.Dom.Builder.Static.StaticDomBuilderT t m)

module Foreign.JavaScript.Orphans
instance (Language.Javascript.JSaddle.Types.MonadJSM m, Reflex.Host.Class.ReflexHost t) => Language.Javascript.JSaddle.Types.MonadJSM (Reflex.PostBuild.Base.PostBuildT t m)
instance (Language.Javascript.JSaddle.Types.MonadJSM (Reflex.Host.Class.HostFrame t), Reflex.Host.Class.ReflexHost t) => Language.Javascript.JSaddle.Types.MonadJSM (Reflex.PerformEvent.Base.PerformEventT t m)
instance Language.Javascript.JSaddle.Types.MonadJSM m => Language.Javascript.JSaddle.Types.MonadJSM (Reflex.DynamicWriter.DynamicWriterT t w m)
instance Language.Javascript.JSaddle.Types.MonadJSM m => Language.Javascript.JSaddle.Types.MonadJSM (Reflex.EventWriter.EventWriterT t w m)
instance Language.Javascript.JSaddle.Types.MonadJSM m => Language.Javascript.JSaddle.Types.MonadJSM (Reflex.Requester.Base.RequesterT t request response m)
instance Language.Javascript.JSaddle.Types.MonadJSM m => Language.Javascript.JSaddle.Types.MonadJSM (Reflex.TriggerEvent.Base.TriggerEventT t m)
instance Language.Javascript.JSaddle.Types.MonadJSM m => Language.Javascript.JSaddle.Types.MonadJSM (Reflex.Query.Base.QueryT t q m)

module Foreign.JavaScript.TH
class Monad m => HasJSContext m where type JSContextPhantom m :: * where {
    type family JSContextPhantom m :: *;
}
askJSContext :: HasJSContext m => m (JSContextSingleton (JSContextPhantom m))
type HasWebView = HasJSContext
newtype WithJSContextSingleton x m a
WithJSContextSingleton :: ReaderT (JSContextSingleton x) m a -> WithJSContextSingleton x m a
[unWithJSContextSingleton] :: WithJSContextSingleton x m a -> ReaderT (JSContextSingleton x) m a
runWithJSContextSingleton :: WithJSContextSingleton x m a -> JSContextSingleton x -> m a
withJSContextSingleton :: MonadJSM m => (forall x. JSContextSingleton x -> m r) -> m r

-- | Warning: <a>withJSContextSingletonMono</a> does not provide the same
--   guarantees that <a>withJSContextSingleton</a> does.
withJSContextSingletonMono :: MonadJSM m => (JSContextSingleton () -> m r) -> m r

-- | A singleton type for a given JSContext; we use this to statically
--   guarantee that different JSContexts don't get mixed up
newtype JSContextSingleton x
JSContextSingleton :: JSContextRef -> JSContextSingleton x
[unJSContextSingleton] :: JSContextSingleton x -> JSContextRef
newtype JSFFI
JSFFI :: String -> JSFFI
data JSFun x
JSFun :: JSRef x -> Function -> JSFun x
[unJSFun] :: JSFun x -> JSRef x
[unJSFunction] :: JSFun x -> Function
class IsJSContext x where data JSRef x where {
    data family JSRef x;
}
class (Monad m, MonadJSM (JSX m), MonadFix (JSX m), MonadJS x (JSX m)) => HasJS x m | m -> x where type JSX m :: * -> * where {
    type family JSX m :: * -> *;
}
liftJS :: HasJS x m => JSX m a -> m a

-- | A Monad that is capable of executing JavaScript
class Monad m => MonadJS x m | m -> x
runJS :: MonadJS x m => JSFFI -> [JSRef x] -> m (JSRef x)
forkJS :: MonadJS x m => m () -> m ThreadId
mkJSUndefined :: MonadJS x m => m (JSRef x)
isJSNull :: MonadJS x m => JSRef x -> m Bool
isJSUndefined :: MonadJS x m => JSRef x -> m Bool
fromJSBool :: MonadJS x m => JSRef x -> m Bool
fromJSString :: MonadJS x m => JSRef x -> m String
fromJSArray :: MonadJS x m => JSRef x -> m [JSRef x]
fromJSUint8Array :: MonadJS x m => JSRef x -> m ByteString
fromJSNumber :: MonadJS x m => JSRef x -> m Double
withJSBool :: MonadJS x m => Bool -> (JSRef x -> m r) -> m r
withJSString :: MonadJS x m => String -> (JSRef x -> m r) -> m r
withJSNumber :: MonadJS x m => Double -> (JSRef x -> m r) -> m r
withJSArray :: MonadJS x m => [JSRef x] -> (JSRef x -> m r) -> m r
withJSUint8Array :: MonadJS x m => ByteString -> (JSUint8Array x -> m r) -> m r

-- | Create a JSFun with zero arguments; should be equilvant to
--   `syncCallback AlwaysRetain True` in GHCJS
mkJSFun :: MonadJS x m => ([JSRef x] -> m (JSRef x)) -> m (JSFun x)
freeJSFun :: MonadJS x m => JSFun x -> m ()
setJSProp :: MonadJS x m => String -> JSRef x -> JSRef x -> m ()
getJSProp :: MonadJS x m => String -> JSRef x -> m (JSRef x)
withJSNode :: MonadJS x m => Node -> (JSRef x -> m r) -> m r
data JSCtx_JavaScriptCore x
type HasJS' = HasJS (JSCtx_JavaScriptCore ())
newtype WithJSContext x m a
WithJSContext :: ReaderT JSContextRef m a -> WithJSContext x m a
[unWithJSContext] :: WithJSContext x m a -> ReaderT JSContextRef m a
runWithJSContext :: WithJSContext x m a -> JSContextRef -> m a
lowerWithJSContext :: MonadJSM m => WithJSContext x IO a -> m a
liftWithJSContextSingletonThroughWithJSContext :: (HasJSContext m, MonadJSM m, MonadTrans t, Monad m1) => ((t1 -> t m1 a) -> WithJSContext x IO b) -> (t1 -> WithJSContextSingleton (JSContextPhantom m) m1 a) -> m b
class FromJS x a
fromJS :: (FromJS x a, MonadJS x m) => JSRef x -> m a
class ToJS x a
withJS :: (ToJS x a, MonadJS x m) => a -> (JSRef x -> m r) -> m r
newtype JSArray a
JSArray :: [a] -> JSArray a
[unJSArray] :: JSArray a -> [a]
withJSArrayFromList :: (ToJS x a, MonadJS x m) => [a] -> (JSRef x -> m r) -> m r
newtype JSUint8Array x
JSUint8Array :: JSRef x -> JSUint8Array x
[unJSUint8Array] :: JSUint8Array x -> JSRef x
importJS :: Safety -> String -> String -> Q Type -> Q [Dec]
mkJSFFI :: Safety -> String -> Q ([Dec], Exp)
parseType :: Type -> ([Type], Type)
data Safety :: *
Unsafe :: Safety
Safe :: Safety
Interruptible :: Safety
instance Control.Monad.Exception.MonadAsyncException m => Control.Monad.Exception.MonadAsyncException (Foreign.JavaScript.TH.WithJSContext x m)
instance Control.Monad.Exception.MonadException m => Control.Monad.Exception.MonadException (Foreign.JavaScript.TH.WithJSContext x m)
instance Control.Monad.Trans.Class.MonadTrans (Foreign.JavaScript.TH.WithJSContext x)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Foreign.JavaScript.TH.WithJSContext x m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Foreign.JavaScript.TH.WithJSContext x m)
instance GHC.Base.Monad m => GHC.Base.Monad (Foreign.JavaScript.TH.WithJSContext x m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Foreign.JavaScript.TH.WithJSContext x m)
instance GHC.Base.Functor m => GHC.Base.Functor (Foreign.JavaScript.TH.WithJSContext x m)
instance Control.Monad.Exception.MonadAsyncException m => Control.Monad.Exception.MonadAsyncException (Foreign.JavaScript.TH.WithJSContextSingleton x m)
instance Control.Monad.Exception.MonadException m => Control.Monad.Exception.MonadException (Foreign.JavaScript.TH.WithJSContextSingleton x m)
instance Control.Monad.Trans.Class.MonadTrans (Foreign.JavaScript.TH.WithJSContextSingleton x)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Foreign.JavaScript.TH.WithJSContextSingleton x m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Foreign.JavaScript.TH.WithJSContextSingleton x m)
instance GHC.Base.Monad m => GHC.Base.Monad (Foreign.JavaScript.TH.WithJSContextSingleton x m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Foreign.JavaScript.TH.WithJSContextSingleton x m)
instance GHC.Base.Functor m => GHC.Base.Functor (Foreign.JavaScript.TH.WithJSContextSingleton x m)
instance Foreign.JavaScript.TH.HasJSContext m => Foreign.JavaScript.TH.HasJSContext (Control.Monad.Trans.Reader.ReaderT r m)
instance Foreign.JavaScript.TH.HasJSContext m => Foreign.JavaScript.TH.HasJSContext (Control.Monad.Trans.State.Lazy.StateT r m)
instance Foreign.JavaScript.TH.HasJSContext m => Foreign.JavaScript.TH.HasJSContext (Control.Monad.Trans.State.Strict.StateT r m)
instance Foreign.JavaScript.TH.HasJSContext m => Foreign.JavaScript.TH.HasJSContext (Reflex.PostBuild.Base.PostBuildT t m)
instance (Reflex.Host.Class.ReflexHost t, Foreign.JavaScript.TH.HasJSContext (Reflex.Host.Class.HostFrame t)) => Foreign.JavaScript.TH.HasJSContext (Reflex.PerformEvent.Base.PerformEventT t m)
instance Foreign.JavaScript.TH.HasJSContext m => Foreign.JavaScript.TH.HasJSContext (Reflex.EventWriter.EventWriterT t w m)
instance Foreign.JavaScript.TH.HasJSContext m => Foreign.JavaScript.TH.HasJSContext (Reflex.DynamicWriter.DynamicWriterT t w m)
instance Foreign.JavaScript.TH.HasJSContext m => Foreign.JavaScript.TH.HasJSContext (Reflex.Requester.Base.RequesterT t request response m)
instance Foreign.JavaScript.TH.HasJSContext m => Foreign.JavaScript.TH.HasJSContext (Reflex.Query.Base.QueryT t q m)
instance Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Foreign.JavaScript.TH.WithJSContextSingleton x m)
instance Reflex.Class.Adjustable t m => Reflex.Class.Adjustable t (Foreign.JavaScript.TH.WithJSContextSingleton x m)
instance Reflex.Host.Class.MonadReflexCreateTrigger t m => Reflex.Host.Class.MonadReflexCreateTrigger t (Foreign.JavaScript.TH.WithJSContextSingleton x m)
instance Reflex.Host.Class.MonadSubscribeEvent t m => Reflex.Host.Class.MonadSubscribeEvent t (Foreign.JavaScript.TH.WithJSContextSingleton x m)
instance Reflex.Host.Class.MonadReflexHost t m => Reflex.Host.Class.MonadReflexHost t (Foreign.JavaScript.TH.WithJSContextSingleton x m)
instance Reflex.Class.MonadSample t m => Reflex.Class.MonadSample t (Foreign.JavaScript.TH.WithJSContextSingleton x m)
instance Reflex.Class.MonadHold t m => Reflex.Class.MonadHold t (Foreign.JavaScript.TH.WithJSContextSingleton x m)
instance Control.Monad.Trans.Control.MonadTransControl (Foreign.JavaScript.TH.WithJSContextSingleton x)
instance Reflex.PerformEvent.Class.PerformEvent t m => Reflex.PerformEvent.Class.PerformEvent t (Foreign.JavaScript.TH.WithJSContextSingleton x m)
instance GHC.Base.Monad m => Foreign.JavaScript.TH.HasJSContext (Foreign.JavaScript.TH.WithJSContextSingleton x m)
instance Control.Monad.Ref.MonadRef m => Control.Monad.Ref.MonadRef (Foreign.JavaScript.TH.WithJSContextSingleton x m)
instance Control.Monad.Ref.MonadAtomicRef m => Control.Monad.Ref.MonadAtomicRef (Foreign.JavaScript.TH.WithJSContextSingleton x m)
instance Foreign.JavaScript.TH.ToJS x (Foreign.JavaScript.TH.JSFun x)
instance Foreign.JavaScript.TH.HasJS x m => Foreign.JavaScript.TH.HasJS x (Control.Monad.Trans.Reader.ReaderT r m)
instance (Foreign.JavaScript.TH.HasJS x m, Reflex.Host.Class.ReflexHost t) => Foreign.JavaScript.TH.HasJS x (Reflex.PostBuild.Base.PostBuildT t m)
instance (Foreign.JavaScript.TH.HasJS x (Reflex.Host.Class.HostFrame t), Reflex.Host.Class.ReflexHost t) => Foreign.JavaScript.TH.HasJS x (Reflex.PerformEvent.Base.PerformEventT t m)
instance Foreign.JavaScript.TH.HasJS x m => Foreign.JavaScript.TH.HasJS x (Reflex.DynamicWriter.DynamicWriterT t w m)
instance Foreign.JavaScript.TH.HasJS x m => Foreign.JavaScript.TH.HasJS x (Reflex.Requester.Base.RequesterT t request response m)
instance Foreign.JavaScript.TH.HasJS x m => Foreign.JavaScript.TH.HasJS x (Reflex.Query.Base.QueryT t q m)
instance Foreign.JavaScript.TH.IsJSContext (Foreign.JavaScript.TH.JSCtx_JavaScriptCore x)
instance Control.Monad.IO.Class.MonadIO m => Foreign.JavaScript.TH.HasJS (Foreign.JavaScript.TH.JSCtx_JavaScriptCore x) (Foreign.JavaScript.TH.WithJSContextSingleton x m)
instance Control.Monad.IO.Class.MonadIO m => Language.Javascript.JSaddle.Types.MonadJSM (Foreign.JavaScript.TH.WithJSContextSingleton x m)
instance Control.Monad.IO.Class.MonadIO m => Language.Javascript.JSaddle.Types.MonadJSM (Foreign.JavaScript.TH.WithJSContext x m)
instance Foreign.JavaScript.TH.MonadJS (Foreign.JavaScript.TH.JSCtx_JavaScriptCore x) (Foreign.JavaScript.TH.WithJSContextSingleton x GHC.Types.IO)
instance Foreign.JavaScript.TH.MonadJS (Foreign.JavaScript.TH.JSCtx_JavaScriptCore x) (Foreign.JavaScript.TH.WithJSContext x GHC.Types.IO)
instance Foreign.JavaScript.TH.FromJS x ()
instance Foreign.JavaScript.TH.FromJS x GHC.Types.Bool
instance Foreign.JavaScript.TH.ToJS x GHC.Types.Bool
instance Foreign.JavaScript.TH.FromJS x GHC.Base.String
instance Foreign.JavaScript.TH.FromJS x Data.Text.Internal.Text
instance Foreign.JavaScript.TH.FromJS x a => Foreign.JavaScript.TH.FromJS x (GHC.Base.Maybe a)
instance Foreign.JavaScript.TH.ToJS x (Foreign.JavaScript.TH.JSRef x)
instance Foreign.JavaScript.TH.FromJS x (Foreign.JavaScript.TH.JSRef x)
instance Foreign.JavaScript.TH.ToJS x GHC.Base.String
instance Foreign.JavaScript.TH.ToJS x Data.Text.Internal.Text
instance Foreign.JavaScript.TH.ToJS x a => Foreign.JavaScript.TH.ToJS x (Foreign.JavaScript.TH.JSArray a)
instance Foreign.JavaScript.TH.FromJS x a => Foreign.JavaScript.TH.FromJS x (Foreign.JavaScript.TH.JSArray a)
instance Foreign.JavaScript.TH.ToJS x (Foreign.JavaScript.TH.JSUint8Array x)
instance Foreign.JavaScript.TH.FromJS x (Foreign.JavaScript.TH.JSUint8Array x)
instance Foreign.JavaScript.TH.ToJS x GHC.Word.Word8
instance Foreign.JavaScript.TH.ToJS x GHC.Types.Int
instance Foreign.JavaScript.TH.FromJS x GHC.Types.Int
instance Foreign.JavaScript.TH.ToJS x GHC.Types.Double
instance Foreign.JavaScript.TH.FromJS x GHC.Types.Double
instance Foreign.JavaScript.TH.ToJS x JSDOM.Types.Node

module Reflex.Dom.Class

-- | Alias for Data.Map.singleton
(=:) :: k -> a -> Map k a
infixr 7 =:

-- | <i>Deprecated: Instead of `x == keycodeEnter`, use `keyCodeLookup x ==
--   Enter`</i>
keycodeEnter :: Int

-- | <i>Deprecated: Instead of `x == keycodeEscape`, use `keyCodeLookup x
--   == Escape`</i>
keycodeEscape :: Int
holdOnStartup :: (PostBuild t m, PerformEvent t m, MonadHold t m) => a -> Performable m a -> m (Behavior t a)

module Reflex.Dom.Widget.Basic

-- | Breaks the given Map into pieces based on the given Set. Each piece
--   will contain only keys that are less than the key of the piece, and
--   greater than or equal to the key of the piece with the next-smaller
--   key. There will be one additional piece containing all keys from the
--   original Map that are larger or equal to the largest key in the Set.
--   Either k () is used instead of Maybe k so that the resulting map of
--   pieces is sorted so that the additional piece has the largest key. No
--   empty pieces will be included in the output.
partitionMapBySetLT :: forall k v. Ord k => Set k -> Map k v -> Map (Either k ()) (Map k v)
newtype ChildResult t k a
ChildResult :: (a, Event t (Map k (Maybe (ChildResult t k a)))) -> ChildResult t k a
[unChildResult] :: ChildResult t k a -> (a, Event t (Map k (Maybe (ChildResult t k a))))
text :: DomBuilder t m => Text -> m ()
dynText :: forall t m. (PostBuild t m, DomBuilder t m) => Dynamic t Text -> m ()
display :: (PostBuild t m, DomBuilder t m, Show a) => Dynamic t a -> m ()
button :: DomBuilder t m => Text -> m (Event t ())

-- | Given a Dynamic of widget-creating actions, create a widget that is
--   recreated whenever the Dynamic updates. The returned Event of widget
--   results occurs when the Dynamic does. Note: Often, the type <tt>a</tt>
--   is an Event, in which case the return value is an Event-of-Events that
--   would typically be flattened (via <a>switchPromptly</a>).
dyn :: (DomBuilder t m, PostBuild t m) => Dynamic t (m a) -> m (Event t a)

-- | Like <a>dyn</a> but discards result.
dyn_ :: (DomBuilder t m, PostBuild t m) => Dynamic t (m a) -> m ()

-- | Given an initial widget and an Event of widget-creating actions,
--   create a widget that is recreated whenever the Event fires. The
--   returned Dynamic of widget results occurs when the Event does. Note:
--   Often, the type <tt>a</tt> is an Event, in which case the return value
--   is a Dynamic-of-Events that would typically be flattened.
widgetHold :: (DomBuilder t m, MonadHold t m) => m a -> Event t (m a) -> m (Dynamic t a)

-- | Like <a>widgetHold</a> but discards result.
widgetHold_ :: (DomBuilder t m, MonadHold t m) => m a -> Event t (m a) -> m ()

-- | Create a DOM element &gt; el "div" (text "Hello World")
--   <a>div</a>Hello World<a>/div</a>
el :: forall t m a. DomBuilder t m => Text -> m a -> m a

-- | Create a DOM element with attributes &gt; elAttr "a" ("href" =:
--   "<a>http://google.com")</a> (text "Google!")
--   <a>href="http://google.com"</a>Google!<a>/a</a>
elAttr :: forall t m a. DomBuilder t m => Text -> Map Text Text -> m a -> m a

-- | Create a DOM element with classes &gt; elClass "div" "row" (return ())
--   <a>class="row"</a><a>/div</a>
elClass :: forall t m a. DomBuilder t m => Text -> Text -> m a -> m a

-- | Create a DOM element with Dynamic Attributes &gt; elClass "div"
--   (constDyn ("class" =: "row")) (return ())
--   <a>class="row"</a><a>/div</a>
elDynAttr :: forall t m a. (DomBuilder t m, PostBuild t m) => Text -> Dynamic t (Map Text Text) -> m a -> m a

-- | Create a DOM element with a Dynamic Class &gt; elDynClass "div"
--   (constDyn "row") (return ()) <a>class="row"</a><a>/div</a>
elDynClass :: forall t m a. (DomBuilder t m, PostBuild t m) => Text -> Dynamic t Text -> m a -> m a
elDynAttrNS :: forall t m a. (DomBuilder t m, PostBuild t m) => Maybe Text -> Text -> Dynamic t (Map Text Text) -> m a -> m a

-- | Create a DOM element and return the element &gt; do (e, _) &lt;- el'
--   "div" (text <a>Click</a>) &gt; return $ domEvent Click e
el' :: forall t m a. DomBuilder t m => Text -> m a -> m (Element EventResult (DomBuilderSpace m) t, a)

-- | Create a DOM element with attributes and return the element
elAttr' :: forall t m a. DomBuilder t m => Text -> Map Text Text -> m a -> m (Element EventResult (DomBuilderSpace m) t, a)

-- | Create a DOM element with a class and return the element
elClass' :: forall t m a. DomBuilder t m => Text -> Text -> m a -> m (Element EventResult (DomBuilderSpace m) t, a)

-- | Create a DOM element with Dynamic Attributes and return the element
elDynAttr' :: forall t m a. (DomBuilder t m, PostBuild t m) => Text -> Dynamic t (Map Text Text) -> m a -> m (Element EventResult (DomBuilderSpace m) t, a)

-- | Create a DOM element with a Dynamic class and return the element
elDynClass' :: forall t m a. (DomBuilder t m, PostBuild t m) => Text -> Dynamic t Text -> m a -> m (Element EventResult (DomBuilderSpace m) t, a)
elDynAttrNS' :: forall t m a. (DomBuilder t m, PostBuild t m) => Maybe Text -> Text -> Dynamic t (Map Text Text) -> m a -> m (Element EventResult (DomBuilderSpace m) t, a)
dynamicAttributesToModifyAttributes :: (Ord k, PostBuild t m) => Dynamic t (Map k Text) -> m (Event t (Map k (Maybe Text)))
dynamicAttributesToModifyAttributesWithInitial :: (Ord k, PostBuild t m) => Map k Text -> Dynamic t (Map k Text) -> m (Event t (Map k (Maybe Text)))
newtype Link t
Link :: Event t () -> Link t
[_link_clicked] :: Link t -> Event t ()
linkClass :: DomBuilder t m => Text -> Text -> m (Link t)
link :: DomBuilder t m => Text -> m (Link t)
divClass :: forall t m a. DomBuilder t m => Text -> m a -> m a
dtdd :: forall t m a. DomBuilder t m => Text -> m a -> m a
blank :: forall m. Monad m => m ()

-- | A widget to display a table with static columns and dynamic rows.
tableDynAttr :: forall t m r k v. (Ord k, DomBuilder t m, MonadHold t m, PostBuild t m, MonadFix m) => Text -> [(Text, k -> Dynamic t r -> m v)] -> Dynamic t (Map k r) -> (k -> m (Dynamic t (Map Text Text))) -> m (Dynamic t (Map k (Element EventResult (DomBuilderSpace m) t, [v])))

-- | A widget to construct a tabbed view that shows only one of its child
--   widgets at a time. Creates a header bar containing a <a>ul</a> with
--   one <a>li</a> per child; clicking a <a>li</a> displays the
--   corresponding child and hides all others.
tabDisplay :: forall t m k. (MonadFix m, DomBuilder t m, MonadHold t m, PostBuild t m, Ord k) => Text -> Text -> Map k (Text, m ()) -> m ()
class HasAttributes a where type Attrs a :: * where {
    type family Attrs a :: *;
}
attributes :: HasAttributes a => Lens' a (Attrs a)

module Foreign.JavaScript.Utils
bsFromMutableArrayBuffer :: MonadJSM m => MutableArrayBuffer -> m ByteString
bsToArrayBuffer :: MonadJSM m => ByteString -> m ArrayBuffer
jsonDecode :: FromJSON a => JSString -> Maybe a
js_jsonParse :: JSString -> JSM JSVal

module Reflex.Dom.WebSocket
data WebSocketConfig t a
WebSocketConfig :: Event t [a] -> Event t (Word, Text) -> Bool -> WebSocketConfig t a
[_webSocketConfig_send] :: WebSocketConfig t a -> Event t [a]
[_webSocketConfig_close] :: WebSocketConfig t a -> Event t (Word, Text)
[_webSocketConfig_reconnect] :: WebSocketConfig t a -> Bool
type WebSocket t = RawWebSocket t ByteString
data RawWebSocket t a
RawWebSocket :: Event t a -> Event t () -> Event t () -> Event t (Bool, Word, Text) -> RawWebSocket t a
[_webSocket_recv] :: RawWebSocket t a -> Event t a
[_webSocket_open] :: RawWebSocket t a -> Event t ()
[_webSocket_error] :: RawWebSocket t a -> Event t ()
[_webSocket_close] :: RawWebSocket t a -> Event t (Bool, Word, Text)
webSocket :: (MonadJSM m, MonadJSM (Performable m), HasJSContext m, PerformEvent t m, TriggerEvent t m, PostBuild t m, IsWebSocketMessage a) => Text -> WebSocketConfig t a -> m (WebSocket t)
webSocket' :: (MonadJSM m, MonadJSM (Performable m), HasJSContext m, PerformEvent t m, TriggerEvent t m, PostBuild t m, IsWebSocketMessage a) => Text -> WebSocketConfig t a -> (Either ByteString JSVal -> JSM b) -> m (RawWebSocket t b)
textWebSocket :: (IsWebSocketMessage a, MonadJSM m, MonadJSM (Performable m), HasJSContext m, PostBuild t m, TriggerEvent t m, PerformEvent t m, MonadHold t m, Reflex t) => Text -> WebSocketConfig t a -> m (RawWebSocket t Text)
jsonWebSocket :: (ToJSON a, FromJSON b, MonadJSM m, MonadJSM (Performable m), HasJSContext m, PostBuild t m, TriggerEvent t m, PerformEvent t m, MonadHold t m, Reflex t) => Text -> WebSocketConfig t a -> m (RawWebSocket t (Maybe b))
webSocketConfig_send :: forall t_a2Mxi a_a2Mxj. Lens' (WebSocketConfig t_a2Mxi a_a2Mxj) (Event t_a2Mxi [a_a2Mxj])
webSocketConfig_reconnect :: forall t_a2Mxi a_a2Mxj. Lens' (WebSocketConfig t_a2Mxi a_a2Mxj) Bool
webSocketConfig_close :: forall t_a2Mxi a_a2Mxj. Lens' (WebSocketConfig t_a2Mxi a_a2Mxj) (Event t_a2Mxi (Word, Text))
webSocket_recv :: forall t_a2Mxf a_a2Mxg. Lens' (RawWebSocket t_a2Mxf a_a2Mxg) (Event t_a2Mxf a_a2Mxg)
webSocket_open :: forall t_a2Mxf a_a2Mxg. Lens' (RawWebSocket t_a2Mxf a_a2Mxg) (Event t_a2Mxf ())
webSocket_error :: forall t_a2Mxf a_a2Mxg. Lens' (RawWebSocket t_a2Mxf a_a2Mxg) (Event t_a2Mxf ())
webSocket_close :: forall t_a2Mxf a_a2Mxg. Lens' (RawWebSocket t_a2Mxf a_a2Mxg) (Event t_a2Mxf (Bool, Word, Text))
jsonDecode :: FromJSON a => JSString -> Maybe a
instance Reflex.Class.Reflex t => Data.Default.Class.Default (Reflex.Dom.WebSocket.WebSocketConfig t a)

module Reflex.Dom.WebSocket.Query
cropQueryT :: (Reflex t, MonadHold t m, MonadFix m, Query q, Additive q, Group q, Eq q) => QueryT t q m a -> Event t (QueryResult q) -> m (a, Dynamic t q)
runWebSocketQuery :: (MonadJSM m, MonadJSM (Performable m), HasJSContext m, PostBuild t m, TriggerEvent t m, PerformEvent t m, MonadHold t m, Reflex t, ToJSON q, MonadFix m, Query q, FromJSON (QueryResult q), Additive q, Group q, Eq q) => QueryT t q m a -> Text -> m a


-- | A module for performing asynchronous HTTP calls from JavaScript using
--   the <a>XMLHttpRequest</a> API (essentially AJAX). Despite the name,
--   there is nothing whatsoever specific to XML.
--   
--   The API has two components:
--   
--   <ul>
--   <li>convenient functions for common usecases like GET and POST
--   requests to APIs using JSON.</li>
--   <li>a flexible set of functions for creating and executing arbitrary
--   requests and handling responses.</li>
--   </ul>
module Reflex.Dom.Xhr

-- | Simplified interface to <a>GET</a> URLs and return decoded results.
getAndDecode :: (MonadIO m, MonadJSM (Performable m), PerformEvent t m, HasJSContext (Performable m), TriggerEvent t m, FromJSON a) => Event t Text -> m (Event t (Maybe a))
getMay :: (Monad m, Reflex t) => (Event t a -> m (Event t b)) -> Event t (Maybe a) -> m (Event t (Maybe b))

-- | Create a <a>POST</a> request from an URL and thing with a JSON
--   representation
postJson :: (ToJSON a) => Text -> a -> XhrRequest Text

-- | Convenience function to decode JSON-encoded responses.
decodeXhrResponse :: FromJSON a => XhrResponse -> Maybe a
decodeText :: FromJSON a => Text -> Maybe a
data XhrRequest a
XhrRequest :: Text -> Text -> XhrRequestConfig a -> XhrRequest a
[_xhrRequest_method] :: XhrRequest a -> Text
[_xhrRequest_url] :: XhrRequest a -> Text
[_xhrRequest_config] :: XhrRequest a -> XhrRequestConfig a
data XhrRequestConfig a
XhrRequestConfig :: Map Text Text -> Maybe Text -> Maybe Text -> Maybe XhrResponseType -> a -> Bool -> XhrResponseHeaders -> XhrRequestConfig a
[_xhrRequestConfig_headers] :: XhrRequestConfig a -> Map Text Text
[_xhrRequestConfig_user] :: XhrRequestConfig a -> Maybe Text
[_xhrRequestConfig_password] :: XhrRequestConfig a -> Maybe Text
[_xhrRequestConfig_responseType] :: XhrRequestConfig a -> Maybe XhrResponseType
[_xhrRequestConfig_sendData] :: XhrRequestConfig a -> a
[_xhrRequestConfig_withCredentials] :: XhrRequestConfig a -> Bool
[_xhrRequestConfig_responseHeaders] :: XhrRequestConfig a -> XhrResponseHeaders

-- | Construct a request object from method, URL, and config record.
xhrRequest :: Text -> Text -> XhrRequestConfig a -> XhrRequest a
xhrRequestConfig_headers :: forall a_a38LO. Lens' (XhrRequestConfig a_a38LO) (Map Text Text)
xhrRequestConfig_password :: forall a_a38LO. Lens' (XhrRequestConfig a_a38LO) (Maybe Text)
xhrRequestConfig_responseType :: forall a_a38LO. Lens' (XhrRequestConfig a_a38LO) (Maybe XhrResponseType)
xhrRequestConfig_sendData :: forall a_a38LO a_a3bDz. Lens (XhrRequestConfig a_a38LO) (XhrRequestConfig a_a3bDz) a_a38LO a_a3bDz
xhrRequestConfig_user :: forall a_a38LO. Lens' (XhrRequestConfig a_a38LO) (Maybe Text)
xhrRequestConfig_withCredentials :: forall a_a38LO. Lens' (XhrRequestConfig a_a38LO) Bool
xhrRequestConfig_responseHeaders :: forall a_a38LO. Lens' (XhrRequestConfig a_a38LO) XhrResponseHeaders
xhrRequest_config :: forall a_a38LP a_a3bDj. Lens (XhrRequest a_a38LP) (XhrRequest a_a3bDj) (XhrRequestConfig a_a38LP) (XhrRequestConfig a_a3bDj)
xhrRequest_method :: forall a_a38LP. Lens' (XhrRequest a_a38LP) Text
xhrRequest_url :: forall a_a38LP. Lens' (XhrRequest a_a38LP) Text

-- | Given Event with an action that creates a request, build and issue the
--   request when the Event fires. Returns Event of corresponding response.
performMkRequestAsync :: (MonadJSM (Performable m), HasJSContext (Performable m), PerformEvent t m, TriggerEvent t m, IsXhrPayload a) => Event t (Performable m (XhrRequest a)) -> m (Event t XhrResponse)

-- | Builds and issues a collection of requests when the supplied Event
--   fires. When ALL requests from a given firing complete, the results are
--   collected and returned via the return Event.
performMkRequestsAsync :: (MonadJSM (Performable m), HasJSContext (Performable m), PerformEvent t m, TriggerEvent t m, Traversable f, IsXhrPayload a) => Event t (Performable m (f (XhrRequest a))) -> m (Event t (f XhrResponse))

-- | Given Event of request, issue them when the Event fires. Returns Event
--   of corresponding response.
performRequestAsync :: (MonadJSM (Performable m), HasJSContext (Performable m), PerformEvent t m, TriggerEvent t m, IsXhrPayload a) => Event t (XhrRequest a) -> m (Event t XhrResponse)

-- | Given Event of requests, issue them when the Event fires. Returns
--   Event of corresponding responses.
--   
--   The request is processed asynchronously, therefore handling does not
--   block or cause a delay while creating the connection.
performRequestAsyncWithError :: (MonadJSM (Performable m), HasJSContext (Performable m), PerformEvent t m, TriggerEvent t m, IsXhrPayload a) => Event t (XhrRequest a) -> m (Event t (Either XhrException XhrResponse))

-- | Issues a collection of requests when the supplied Event fires. When
--   ALL requests from a given firing complete, the results are collected
--   and returned via the return Event.
performRequestsAsync :: (MonadJSM (Performable m), HasJSContext (Performable m), PerformEvent t m, TriggerEvent t m, Traversable f, IsXhrPayload a) => Event t (f (XhrRequest a)) -> m (Event t (f XhrResponse))

-- | Issues a collection of requests when the supplied Event fires. When
--   ALL requests from a given firing complete, the results are collected
--   and returned via the return Event.
--   
--   The requests are processed asynchronously, therefore handling does not
--   block or cause a delay while creating the connection.
--   
--   Order of request execution and completion is not guaranteed, but order
--   of creation and the collection result is preserved.
performRequestsAsyncWithError :: (MonadJSM (Performable m), HasJSContext (Performable m), PerformEvent t m, TriggerEvent t m, Traversable f, IsXhrPayload a) => Event t (f (XhrRequest a)) -> m (Event t (f (Either XhrException XhrResponse)))
data XhrResponse
XhrResponse :: Word -> Text -> Maybe XhrResponseBody -> Maybe Text -> Map Text Text -> XhrResponse
[_xhrResponse_status] :: XhrResponse -> Word
[_xhrResponse_statusText] :: XhrResponse -> Text
[_xhrResponse_response] :: XhrResponse -> Maybe XhrResponseBody
[_xhrResponse_responseText] :: XhrResponse -> Maybe Text
[_xhrResponse_headers] :: XhrResponse -> Map Text Text
data XhrResponseBody
XhrResponseBody_Default :: Text -> XhrResponseBody
XhrResponseBody_Text :: Text -> XhrResponseBody
XhrResponseBody_Blob :: Blob -> XhrResponseBody
XhrResponseBody_ArrayBuffer :: ByteString -> XhrResponseBody
data XhrResponseHeaders

-- | Parse a subset of headers from the XHR Response
OnlyHeaders :: (Set Text) -> XhrResponseHeaders

-- | Parse all headers from the XHR Response
AllHeaders :: XhrResponseHeaders
data XhrResponseType
XhrResponseType_Default :: XhrResponseType
XhrResponseType_ArrayBuffer :: XhrResponseType
XhrResponseType_Blob :: XhrResponseType
XhrResponseType_Text :: XhrResponseType
xhrResponse_response :: Lens' XhrResponse (Maybe XhrResponseBody)
xhrResponse_responseText :: Lens' XhrResponse (Maybe Text)
xhrResponse_status :: Lens' XhrResponse Word
xhrResponse_statusText :: Lens' XhrResponse Text
xhrResponse_headers :: Lens' XhrResponse (Map Text Text)

-- | <i>Deprecated: Use xhrResponse_response or xhrResponse_responseText
--   instead.</i>
xhrResponse_body :: Lens XhrResponse XhrResponse (Maybe Text) (Maybe Text)

-- | <i>Deprecated: Use _xhrResponse_response or _xhrResponse_responseText
--   instead.</i>
_xhrResponse_body :: XhrResponse -> Maybe Text
data XhrException
XhrException_Error :: XhrException
XhrException_Aborted :: XhrException
class IsXhrPayload a
sendXhrPayload :: (IsXhrPayload a, MonadJSM m) => XMLHttpRequest -> a -> m ()

-- | Functions for this inteface are in <a>JSDOM.XMLHttpRequest</a>. Base
--   interface functions are in:
--   
--   <ul>
--   <li><a>JSDOM.XMLHttpRequestEventTarget</a></li>
--   <li><a>JSDOM.EventTarget</a></li>
--   </ul>
--   
--   <a>Mozilla XMLHttpRequest documentation</a>
data XMLHttpRequest :: *
newXMLHttpRequest :: (HasJSContext m, MonadJSM m, IsXhrPayload a) => XhrRequest a -> (XhrResponse -> JSM ()) -> m XMLHttpRequest

-- | Make a new asyncronous XHR request. This does not block (it forks),
--   and returns an XHR object immediately (which you can use to abort the
--   XHR connection), and will pass an exception (<a>XhrException</a>) to
--   the continuation if the connection cannot be made (or is aborted).
newXMLHttpRequestWithError :: (HasJSContext m, MonadJSM m, IsXhrPayload a) => XhrRequest a -> (Either XhrException XhrResponse -> JSM ()) -> m XMLHttpRequest
xmlHttpRequestGetReadyState :: MonadJSM m => XMLHttpRequest -> m Word
xmlHttpRequestGetResponseText :: (FromJSString result, MonadJSM m) => XMLHttpRequest -> m (Maybe result)
xmlHttpRequestGetStatus :: MonadJSM m => XMLHttpRequest -> m Word
xmlHttpRequestGetStatusText :: MonadJSM m => FromJSString result => XMLHttpRequest -> m result
xmlHttpRequestNew :: MonadJSM m => m XMLHttpRequest
xmlHttpRequestOnreadystatechange :: XMLHttpRequest -> EventM XMLHttpRequest Event () -> JSM (JSM ())
xmlHttpRequestOpen :: (ToJSString method, ToJSString url, ToJSString user, ToJSString password, MonadJSM m) => XMLHttpRequest -> method -> url -> Bool -> user -> password -> m ()
xmlHttpRequestSetRequestHeader :: (ToJSString header, ToJSString value, MonadJSM m) => XMLHttpRequest -> header -> value -> m ()
xmlHttpRequestSetResponseType :: MonadJSM m => XMLHttpRequest -> XMLHttpRequestResponseType -> m ()
instance GHC.Base.Functor Reflex.Dom.Xhr.XhrRequest
instance GHC.Classes.Ord a => GHC.Classes.Ord (Reflex.Dom.Xhr.XhrRequest a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Reflex.Dom.Xhr.XhrRequest a)
instance GHC.Read.Read a => GHC.Read.Read (Reflex.Dom.Xhr.XhrRequest a)
instance GHC.Show.Show a => GHC.Show.Show (Reflex.Dom.Xhr.XhrRequest a)
instance GHC.Base.Functor Reflex.Dom.Xhr.XhrRequestConfig
instance GHC.Classes.Ord a => GHC.Classes.Ord (Reflex.Dom.Xhr.XhrRequestConfig a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Reflex.Dom.Xhr.XhrRequestConfig a)
instance GHC.Read.Read a => GHC.Read.Read (Reflex.Dom.Xhr.XhrRequestConfig a)
instance GHC.Show.Show a => GHC.Show.Show (Reflex.Dom.Xhr.XhrRequestConfig a)
instance GHC.Classes.Ord Reflex.Dom.Xhr.XhrResponseHeaders
instance GHC.Classes.Eq Reflex.Dom.Xhr.XhrResponseHeaders
instance GHC.Read.Read Reflex.Dom.Xhr.XhrResponseHeaders
instance GHC.Show.Show Reflex.Dom.Xhr.XhrResponseHeaders
instance Data.Default.Class.Default Reflex.Dom.Xhr.XhrResponseHeaders
instance a ~ () => Data.Default.Class.Default (Reflex.Dom.Xhr.XhrRequestConfig a)

module Reflex.Dom.Builder.Immediate

-- | A reference to an <a>EventTrigger</a> suitable for firing with
--   <a>TriggerEventT</a>.
newtype EventTriggerRef t a :: * -> * -> *
EventTriggerRef :: IORef (Maybe (EventTrigger t a)) -> EventTriggerRef t a
[unEventTriggerRef] :: EventTriggerRef t a -> IORef (Maybe (EventTrigger t a))
data ImmediateDomBuilderEnv t
ImmediateDomBuilderEnv :: {-# UNPACK #-} !Document -> {-# UNPACK #-} !Node -> {-# UNPACK #-} !(IORef Word) -> !(JSM ()) -> ImmediateDomBuilderEnv t
[_immediateDomBuilderEnv_document] :: ImmediateDomBuilderEnv t -> {-# UNPACK #-} !Document
[_immediateDomBuilderEnv_parent] :: ImmediateDomBuilderEnv t -> {-# UNPACK #-} !Node
[_immediateDomBuilderEnv_unreadyChildren] :: ImmediateDomBuilderEnv t -> {-# UNPACK #-} !(IORef Word)
[_immediateDomBuilderEnv_commitAction] :: ImmediateDomBuilderEnv t -> !(JSM ())
newtype ImmediateDomBuilderT t m a
ImmediateDomBuilderT :: ReaderT (ImmediateDomBuilderEnv t) (RequesterT t JSM Identity (TriggerEventT t m)) a -> ImmediateDomBuilderT t m a
[unImmediateDomBuilderT] :: ImmediateDomBuilderT t m a -> ReaderT (ImmediateDomBuilderEnv t) (RequesterT t JSM Identity (TriggerEventT t m)) a
runImmediateDomBuilderT :: (MonadFix m, PerformEvent t m, MonadReflexCreateTrigger t m, MonadJSM m, MonadJSM (Performable m), MonadRef m, Ref m ~ IORef) => ImmediateDomBuilderT t m a -> ImmediateDomBuilderEnv t -> Chan [DSum (EventTriggerRef t) TriggerInvocation] -> m a
askParent :: Monad m => ImmediateDomBuilderT t m Node
askEvents :: Monad m => ImmediateDomBuilderT t m (Chan [DSum (EventTriggerRef t) TriggerInvocation])
append :: MonadJSM m => Node -> ImmediateDomBuilderT t m ()
textNodeInternal :: (MonadJSM m, ToDOMString contents) => contents -> ImmediateDomBuilderT t m Text

-- | s and e must both be children of the same node and s must precede e;
--   all nodes between s and e will be removed, but s and e will not be
--   removed
deleteBetweenExclusive :: (MonadJSM m, IsNode start, IsNode end) => start -> end -> m ()

-- | s and e must both be children of the same node and s must precede e;
--   all nodes between s and e will be moved into the given
--   DocumentFragment, but s and e will not be moved
extractBetweenExclusive :: (MonadJSM m, IsNode start, IsNode end) => DocumentFragment -> start -> end -> m ()

-- | s and e must both be children of the same node and s must precede e; s
--   and all nodes between s and e will be removed, but e will not be
--   removed
deleteUpTo :: (MonadJSM m, IsNode start, IsNode end) => start -> end -> m ()
extractUpTo :: (MonadJSM m, IsNode start, IsNode end) => DocumentFragment -> start -> end -> m ()
type SupportsImmediateDomBuilder t m = (Reflex t, MonadJSM m, MonadHold t m, MonadFix m, MonadReflexCreateTrigger t m, MonadRef m, Ref m ~ Ref JSM, Adjustable t m, PrimMonad m)
collectUpTo :: (MonadJSM m, IsNode start, IsNode end) => start -> end -> m DocumentFragment
collectUpToGivenParent :: (MonadJSM m, IsNode parent, IsNode start, IsNode end) => parent -> start -> end -> m DocumentFragment
newtype EventFilterTriggerRef t er (en :: EventTag)
EventFilterTriggerRef :: (IORef (Maybe (EventTrigger t (er en)))) -> EventFilterTriggerRef t er
wrap :: forall m er t. (Reflex t, MonadFix m, MonadJSM m, MonadReflexCreateTrigger t m) => RawElement GhcjsDomSpace -> RawElementConfig er t GhcjsDomSpace -> ImmediateDomBuilderT t m (Element er GhcjsDomSpace t)
makeElement :: forall er t m a. (MonadJSM m, MonadFix m, MonadReflexCreateTrigger t m, Adjustable t m) => Text -> ElementConfig er t GhcjsDomSpace -> ImmediateDomBuilderT t m a -> ImmediateDomBuilderT t m ((Element er GhcjsDomSpace t, a), Element)
newtype GhcjsDomHandler a b
GhcjsDomHandler :: (a -> JSM b) -> GhcjsDomHandler a b
[unGhcjsDomHandler] :: GhcjsDomHandler a b -> a -> JSM b
newtype GhcjsDomHandler1 a b
GhcjsDomHandler1 :: (forall (x :: EventTag). a x -> JSM (b x)) -> GhcjsDomHandler1 a b
[unGhcjsDomHandler1] :: GhcjsDomHandler1 a b -> forall (x :: EventTag). a x -> JSM (b x)
newtype GhcjsDomEvent en
GhcjsDomEvent :: EventType en -> GhcjsDomEvent en
[unGhcjsDomEvent] :: GhcjsDomEvent en -> EventType en
data GhcjsDomSpace
newtype GhcjsEventFilter er en
GhcjsEventFilter :: (GhcjsDomEvent en -> JSM (EventFlags, JSM (Maybe (er en)))) -> GhcjsEventFilter er en
data Pair1 (f :: k -> *) (g :: k -> *) (a :: k)
Pair1 :: (f a) -> (g a) -> Pair1
data Maybe1 f a
Nothing1 :: Maybe1 f a
Just1 :: (f a) -> Maybe1 f a
data GhcjsEventSpec er
GhcjsEventSpec :: DMap EventName (GhcjsEventFilter er) -> GhcjsEventHandler er -> GhcjsEventSpec er
[_ghcjsEventSpec_filters] :: GhcjsEventSpec er -> DMap EventName (GhcjsEventFilter er)
[_ghcjsEventSpec_handler] :: GhcjsEventSpec er -> GhcjsEventHandler er
class Monad m => HasDocument m where askDocument = lift askDocument
askDocument :: HasDocument m => m Document
askDocument :: (HasDocument m, m ~ f m', MonadTrans f, Monad m', HasDocument m') => m Document
ghcjsEventSpec_filters :: forall er_a3GE2. Lens' (GhcjsEventSpec er_a3GE2) (DMap EventName (GhcjsEventFilter er_a3GE2))
ghcjsEventSpec_handler :: forall er_a3GE2. Lens' (GhcjsEventSpec er_a3GE2) (GhcjsEventHandler er_a3GE2)
newtype GhcjsEventHandler er
GhcjsEventHandler :: (forall en. (EventName en, GhcjsDomEvent en) -> JSM (Maybe (er en))) -> GhcjsEventHandler er
[unGhcjsEventHandler] :: GhcjsEventHandler er -> forall en. (EventName en, GhcjsDomEvent en) -> JSM (Maybe (er en))
drawChildUpdate :: (MonadIO m, MonadJSM m) => ImmediateDomBuilderEnv t -> (IORef (ChildReadyState k) -> JSM ()) -> ImmediateDomBuilderT t m (v' a) -> RequesterT t JSM Identity (TriggerEventT t m) (Compose ((,,,) DocumentFragment Text (IORef (ChildReadyState k))) v' a)
data ChildReadyState k
ChildReadyState_Ready :: ChildReadyState k
ChildReadyState_Unready :: !(Maybe (Some k)) -> ChildReadyState k
data ChildReadyStateInt
ChildReadyStateInt_Ready :: ChildReadyStateInt
ChildReadyStateInt_Unready :: !(Maybe Int) -> ChildReadyStateInt
mkHasFocus :: (MonadHold t m, Reflex t) => Element er d t -> m (Dynamic t Bool)
insertBefore :: (MonadJSM m, IsNode new, IsNode existing) => new -> existing -> m ()
defaultDomEventHandler :: IsElement e => e -> EventName en -> EventM e (EventType en) (Maybe (EventResult en))
defaultDomWindowEventHandler :: Window -> EventName en -> EventM Window (EventType en) (Maybe (EventResult en))
withIsEvent :: EventName en -> (IsEvent (EventType en) => r) -> r
showEventName :: EventName en -> String
elementOnEventName :: IsElement e => EventName en -> e -> EventM e (EventType en) () -> JSM (JSM ())
windowOnEventName :: EventName en -> Window -> EventM Window (EventType en) () -> JSM (JSM ())
wrapDomEvent :: (TriggerEvent t m, MonadJSM m) => e -> (e -> EventM e event () -> JSM (JSM ())) -> EventM e event a -> m (Event t a)
subscribeDomEvent :: (EventM e event () -> JSM (JSM ())) -> EventM e event (Maybe a) -> Chan [DSum (EventTriggerRef t) TriggerInvocation] -> EventTrigger t a -> JSM (JSM ())
wrapDomEventMaybe :: (TriggerEvent t m, MonadJSM m) => e -> (e -> EventM e event () -> JSM (JSM ())) -> EventM e event (Maybe a) -> m (Event t a)
wrapDomEventsMaybe :: (MonadJSM m, MonadReflexCreateTrigger t m) => e -> (forall en. IsEvent (EventType en) => EventName en -> EventM e (EventType en) (Maybe (f en))) -> (forall en. EventName en -> e -> EventM e (EventType en) () -> JSM (JSM ())) -> ImmediateDomBuilderT t m (EventSelector t (WrapArg f EventName))
getKeyEvent :: EventM e KeyboardEvent Word
getMouseEventCoords :: EventM e MouseEvent (Int, Int)
getTouchEvent :: EventM e TouchEvent TouchEventResult
data WindowConfig t
WindowConfig :: WindowConfig t
data Window t
Window :: EventSelector t (WrapArg EventResult EventName) -> Window -> Window t
[_window_events] :: Window t -> EventSelector t (WrapArg EventResult EventName)
[_window_raw] :: Window t -> Window
wrapWindow :: (MonadJSM m, MonadReflexCreateTrigger t m) => Window -> WindowConfig t -> ImmediateDomBuilderT t m (Window t)
traverseDMapWithKeyWithAdjust' :: forall t m (k :: * -> *) v v'. (Adjustable t m, MonadHold t m, MonadFix m, MonadIO m, MonadJSM m, PrimMonad m, GCompare k) => (forall a. k a -> v a -> ImmediateDomBuilderT t m (v' a)) -> DMap k v -> Event t (PatchDMap k v) -> ImmediateDomBuilderT t m (DMap k v', Event t (PatchDMap k v'))
hoistTraverseWithKeyWithAdjust :: forall (k :: * -> *) v v' t m p. (Adjustable t m, MonadHold t m, GCompare k, MonadIO m, MonadJSM m, PrimMonad m, MonadFix m, Patch (p k v), PatchTarget (p k (Constant Int)) ~ DMap k (Constant Int), Monoid (p k (Compose ((,,,) DocumentFragment Text (IORef (ChildReadyState k))) v')), Patch (p k (Constant Int))) => (forall vv vv'. (forall a. k a -> vv a -> RequesterT t JSM Identity (TriggerEventT t m) (vv' a)) -> DMap k vv -> Event t (p k vv) -> RequesterT t JSM Identity (TriggerEventT t m) (DMap k vv', Event t (p k vv'))) -> (forall vv vv'. (forall a. vv a -> vv' a) -> p k vv -> p k vv') -> (p k (Compose ((,,,) DocumentFragment Text (IORef (ChildReadyState k))) v') -> DMap k (Constant (IORef (ChildReadyState k))) -> IO (DMap k (Constant (IORef (ChildReadyState k))))) -> (IORef (Map (Some k) Text) -> IORef Text -> p k (Compose ((,,,) DocumentFragment Text (IORef (ChildReadyState k))) v') -> JSM ()) -> (forall a. k a -> v a -> ImmediateDomBuilderT t m (v' a)) -> DMap k v -> Event t (p k v) -> ImmediateDomBuilderT t m (DMap k v', Event t (p k v'))
traverseIntMapWithKeyWithAdjust' :: forall t m v v'. (Adjustable t m, MonadHold t m, MonadFix m, MonadIO m, MonadJSM m, PrimMonad m) => (Key -> v -> ImmediateDomBuilderT t m v') -> IntMap v -> Event t (PatchIntMap v) -> ImmediateDomBuilderT t m (IntMap v', Event t (PatchIntMap v'))
hoistTraverseIntMapWithKeyWithAdjust :: forall v v' t m p. (Adjustable t m, MonadIO m, MonadJSM m, MonadFix m, PrimMonad m, Monoid (p (DocumentFragment, Text, IORef ChildReadyStateInt, v')), Functor p) => ((Key -> v -> RequesterT t JSM Identity (TriggerEventT t m) (DocumentFragment, Text, IORef ChildReadyStateInt, v')) -> IntMap v -> Event t (p v) -> RequesterT t JSM Identity (TriggerEventT t m) (IntMap (DocumentFragment, Text, IORef ChildReadyStateInt, v'), Event t (p (DocumentFragment, Text, IORef ChildReadyStateInt, v')))) -> (p (DocumentFragment, Text, IORef ChildReadyStateInt, v') -> IntMap (IORef ChildReadyStateInt) -> IO (IntMap (IORef ChildReadyStateInt))) -> (IORef (IntMap Text) -> IORef Text -> p (DocumentFragment, Text, IORef ChildReadyStateInt, v') -> JSM ()) -> (Key -> v -> ImmediateDomBuilderT t m v') -> IntMap v -> Event t (p v) -> ImmediateDomBuilderT t m (IntMap v', Event t (p v'))
instance JSDOM.Types.IsElement Reflex.Dom.Builder.Immediate.ElementEventTarget
instance JSDOM.Types.IsNode Reflex.Dom.Builder.Immediate.ElementEventTarget
instance JSDOM.Types.IsAnimatable Reflex.Dom.Builder.Immediate.ElementEventTarget
instance JSDOM.Types.IsChildNode Reflex.Dom.Builder.Immediate.ElementEventTarget
instance JSDOM.Types.IsNonDocumentTypeChildNode Reflex.Dom.Builder.Immediate.ElementEventTarget
instance JSDOM.Types.IsParentNode Reflex.Dom.Builder.Immediate.ElementEventTarget
instance JSDOM.Types.IsSlotable Reflex.Dom.Builder.Immediate.ElementEventTarget
instance GHCJS.Marshal.Internal.ToJSVal Reflex.Dom.Builder.Immediate.ElementEventTarget
instance JSDOM.Types.IsGObject Reflex.Dom.Builder.Immediate.ElementEventTarget
instance GHC.Classes.Ord Reflex.Dom.Builder.Immediate.ChildReadyStateInt
instance GHC.Classes.Eq Reflex.Dom.Builder.Immediate.ChildReadyStateInt
instance GHC.Read.Read Reflex.Dom.Builder.Immediate.ChildReadyStateInt
instance GHC.Show.Show Reflex.Dom.Builder.Immediate.ChildReadyStateInt
instance forall k (k1 :: k -> *). Data.GADT.Compare.GCompare k1 => GHC.Classes.Ord (Reflex.Dom.Builder.Immediate.ChildReadyState k1)
instance forall k (k1 :: k -> *). Data.GADT.Compare.GEq k1 => GHC.Classes.Eq (Reflex.Dom.Builder.Immediate.ChildReadyState k1)
instance forall k (k1 :: k -> *). Data.GADT.Show.GRead k1 => GHC.Read.Read (Reflex.Dom.Builder.Immediate.ChildReadyState k1)
instance forall k (k1 :: k -> *). Data.GADT.Show.GShow k1 => GHC.Show.Show (Reflex.Dom.Builder.Immediate.ChildReadyState k1)
instance Control.Monad.Exception.MonadAsyncException m => Control.Monad.Exception.MonadAsyncException (Reflex.Dom.Builder.Immediate.ImmediateDomBuilderT t m)
instance Control.Monad.Exception.MonadException m => Control.Monad.Exception.MonadException (Reflex.Dom.Builder.Immediate.ImmediateDomBuilderT t m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Reflex.Dom.Builder.Immediate.ImmediateDomBuilderT t m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Reflex.Dom.Builder.Immediate.ImmediateDomBuilderT t m)
instance GHC.Base.Monad m => GHC.Base.Monad (Reflex.Dom.Builder.Immediate.ImmediateDomBuilderT t m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Reflex.Dom.Builder.Immediate.ImmediateDomBuilderT t m)
instance GHC.Base.Functor m => GHC.Base.Functor (Reflex.Dom.Builder.Immediate.ImmediateDomBuilderT t m)
instance Language.Javascript.JSaddle.Types.MonadJSM m => Language.Javascript.JSaddle.Types.MonadJSM (Reflex.Dom.Builder.Immediate.ImmediateDomBuilderT t m)
instance Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Reflex.Dom.Builder.Immediate.ImmediateDomBuilderT x m)
instance Control.Monad.Trans.Class.MonadTrans (Reflex.Dom.Builder.Immediate.ImmediateDomBuilderT t)
instance (Reflex.Class.Reflex t, Control.Monad.Fix.MonadFix m) => Reflex.Dom.Builder.Class.DomRenderHook t (Reflex.Dom.Builder.Immediate.ImmediateDomBuilderT t m)
instance Reflex.Dom.Builder.Immediate.HasDocument m => Reflex.Dom.Builder.Immediate.HasDocument (Control.Monad.Trans.Reader.ReaderT r m)
instance Reflex.Dom.Builder.Immediate.HasDocument m => Reflex.Dom.Builder.Immediate.HasDocument (Control.Monad.Trans.State.Strict.StateT s m)
instance Reflex.Dom.Builder.Immediate.HasDocument m => Reflex.Dom.Builder.Immediate.HasDocument (Control.Monad.Trans.State.Lazy.StateT s m)
instance Reflex.Dom.Builder.Immediate.HasDocument m => Reflex.Dom.Builder.Immediate.HasDocument (Reflex.EventWriter.EventWriterT t w m)
instance Reflex.Dom.Builder.Immediate.HasDocument m => Reflex.Dom.Builder.Immediate.HasDocument (Reflex.DynamicWriter.DynamicWriterT t w m)
instance Reflex.Dom.Builder.Immediate.HasDocument m => Reflex.Dom.Builder.Immediate.HasDocument (Reflex.PostBuild.Base.PostBuildT t m)
instance Reflex.Dom.Builder.Immediate.HasDocument m => Reflex.Dom.Builder.Immediate.HasDocument (Reflex.Requester.Base.RequesterT t request response m)
instance Reflex.Dom.Builder.Immediate.HasDocument m => Reflex.Dom.Builder.Immediate.HasDocument (Reflex.Query.Base.QueryT t q m)
instance GHC.Base.Monad m => Reflex.Dom.Builder.Immediate.HasDocument (Reflex.Dom.Builder.Immediate.ImmediateDomBuilderT t m)
instance Reflex.Dom.Builder.Class.DomSpace Reflex.Dom.Builder.Immediate.GhcjsDomSpace
instance er ~ Reflex.Dom.Builder.Class.Events.EventResult => Data.Default.Class.Default (Reflex.Dom.Builder.Immediate.GhcjsEventSpec er)
instance Reflex.Dom.Builder.Immediate.SupportsImmediateDomBuilder t m => Reflex.NotReady.Class.NotReady t (Reflex.Dom.Builder.Immediate.ImmediateDomBuilderT t m)
instance Reflex.Dom.Builder.Immediate.SupportsImmediateDomBuilder t m => Reflex.Dom.Builder.Class.DomBuilder t (Reflex.Dom.Builder.Immediate.ImmediateDomBuilderT t m)
instance Reflex.Dom.Builder.Immediate.SupportsImmediateDomBuilder t m => Reflex.Dom.Builder.Class.MountableDomBuilder t (Reflex.Dom.Builder.Immediate.ImmediateDomBuilderT t m)
instance (Reflex.Class.Reflex t, Reflex.Class.Adjustable t m, Language.Javascript.JSaddle.Types.MonadJSM m, Reflex.Class.MonadHold t m, Control.Monad.Fix.MonadFix m, Control.Monad.Primitive.PrimMonad m) => Reflex.Class.Adjustable t (Reflex.Dom.Builder.Immediate.ImmediateDomBuilderT t m)
instance Reflex.PerformEvent.Class.PerformEvent t m => Reflex.PerformEvent.Class.PerformEvent t (Reflex.Dom.Builder.Immediate.ImmediateDomBuilderT t m)
instance Reflex.PostBuild.Class.PostBuild t m => Reflex.PostBuild.Class.PostBuild t (Reflex.Dom.Builder.Immediate.ImmediateDomBuilderT t m)
instance Reflex.Host.Class.MonadReflexCreateTrigger t m => Reflex.Host.Class.MonadReflexCreateTrigger t (Reflex.Dom.Builder.Immediate.ImmediateDomBuilderT t m)
instance (GHC.Base.Monad m, Control.Monad.Ref.MonadRef m, Control.Monad.Ref.Ref m ~ Control.Monad.Ref.Ref GHC.Types.IO, Reflex.Host.Class.MonadReflexCreateTrigger t m) => Reflex.TriggerEvent.Class.TriggerEvent t (Reflex.Dom.Builder.Immediate.ImmediateDomBuilderT t m)
instance Foreign.JavaScript.TH.HasJSContext m => Foreign.JavaScript.TH.HasJSContext (Reflex.Dom.Builder.Immediate.ImmediateDomBuilderT t m)
instance Control.Monad.Ref.MonadRef m => Control.Monad.Ref.MonadRef (Reflex.Dom.Builder.Immediate.ImmediateDomBuilderT t m)
instance Control.Monad.Ref.MonadAtomicRef m => Control.Monad.Ref.MonadAtomicRef (Reflex.Dom.Builder.Immediate.ImmediateDomBuilderT t m)
instance (Foreign.JavaScript.TH.HasJS x m, Reflex.Host.Class.ReflexHost t) => Foreign.JavaScript.TH.HasJS x (Reflex.Dom.Builder.Immediate.ImmediateDomBuilderT t m)
instance GHCJS.Marshal.Internal.FromJSVal Reflex.Dom.Builder.Immediate.ElementEventTarget
instance JSDOM.Types.IsEventTarget Reflex.Dom.Builder.Immediate.ElementEventTarget
instance JSDOM.Types.IsGlobalEventHandlers Reflex.Dom.Builder.Immediate.ElementEventTarget
instance JSDOM.Types.IsDocumentAndElementEventHandlers Reflex.Dom.Builder.Immediate.ElementEventTarget
instance Reflex.Class.MonadSample t m => Reflex.Class.MonadSample t (Reflex.Dom.Builder.Immediate.ImmediateDomBuilderT t m)
instance Reflex.Class.MonadHold t m => Reflex.Class.MonadHold t (Reflex.Dom.Builder.Immediate.ImmediateDomBuilderT t m)
instance forall k (t :: k). Data.Default.Class.Default (Reflex.Dom.Builder.Immediate.WindowConfig t)

module Reflex.Dom.Builder.InputDisabled

-- | A DomBuilder transformer that disables all <a>inputElement</a>s,
--   <a>textAreaElement</a>s, and <a>selectElement</a>s by adding the
--   "disabled" HTML attribute. Note that <a>element</a>s that happen to
--   have "input", "textarea", or "select" as their tag will NOT be
--   disabled.
newtype InputDisabledT m a
InputDisabledT :: m a -> InputDisabledT m a
[runInputDisabledT] :: InputDisabledT m a -> m a
disableElementConfig :: Reflex t => ElementConfig er t m -> ElementConfig er t m
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Reflex.Dom.Builder.InputDisabled.InputDisabledT m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Reflex.Dom.Builder.InputDisabled.InputDisabledT m)
instance Control.Monad.Ref.MonadAtomicRef m => Control.Monad.Ref.MonadAtomicRef (Reflex.Dom.Builder.InputDisabled.InputDisabledT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Reflex.Dom.Builder.InputDisabled.InputDisabledT m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Reflex.Dom.Builder.InputDisabled.InputDisabledT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Reflex.Dom.Builder.InputDisabled.InputDisabledT m)
instance Reflex.Class.MonadSample t m => Reflex.Class.MonadSample t (Reflex.Dom.Builder.InputDisabled.InputDisabledT m)
instance Reflex.Class.MonadHold t m => Reflex.Class.MonadHold t (Reflex.Dom.Builder.InputDisabled.InputDisabledT m)
instance Reflex.TriggerEvent.Class.TriggerEvent t m => Reflex.TriggerEvent.Class.TriggerEvent t (Reflex.Dom.Builder.InputDisabled.InputDisabledT m)
instance Language.Javascript.JSaddle.Types.MonadJSM m => Language.Javascript.JSaddle.Types.MonadJSM (Reflex.Dom.Builder.InputDisabled.InputDisabledT m)
instance Control.Monad.Trans.Class.MonadTrans Reflex.Dom.Builder.InputDisabled.InputDisabledT
instance Control.Monad.Trans.Control.MonadTransControl Reflex.Dom.Builder.InputDisabled.InputDisabledT
instance Control.Monad.Ref.MonadRef m => Control.Monad.Ref.MonadRef (Reflex.Dom.Builder.InputDisabled.InputDisabledT m)
instance Reflex.PerformEvent.Class.PerformEvent t m => Reflex.PerformEvent.Class.PerformEvent t (Reflex.Dom.Builder.InputDisabled.InputDisabledT m)
instance Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Reflex.Dom.Builder.InputDisabled.InputDisabledT m)
instance Reflex.PostBuild.Class.PostBuild t m => Reflex.PostBuild.Class.PostBuild t (Reflex.Dom.Builder.InputDisabled.InputDisabledT m)
instance Reflex.Host.Class.MonadReflexCreateTrigger t m => Reflex.Host.Class.MonadReflexCreateTrigger t (Reflex.Dom.Builder.InputDisabled.InputDisabledT m)
instance Reflex.Class.Adjustable t m => Reflex.Class.Adjustable t (Reflex.Dom.Builder.InputDisabled.InputDisabledT m)
instance Reflex.NotReady.Class.NotReady t m => Reflex.NotReady.Class.NotReady t (Reflex.Dom.Builder.InputDisabled.InputDisabledT m)
instance Reflex.Dom.Builder.Class.DomBuilder t m => Reflex.Dom.Builder.Class.DomBuilder t (Reflex.Dom.Builder.InputDisabled.InputDisabledT m)
instance Reflex.Dom.Builder.Immediate.HasDocument m => Reflex.Dom.Builder.Immediate.HasDocument (Reflex.Dom.Builder.InputDisabled.InputDisabledT m)
instance Foreign.JavaScript.TH.HasJSContext m => Foreign.JavaScript.TH.HasJSContext (Reflex.Dom.Builder.InputDisabled.InputDisabledT m)
instance Foreign.JavaScript.TH.HasJS js m => Foreign.JavaScript.TH.HasJS js (Reflex.Dom.Builder.InputDisabled.InputDisabledT m)

module Reflex.Dom.Location

-- | Builds a Dynamic carrying the current window location.
browserHistoryWith :: (MonadJSM m, TriggerEvent t m, MonadHold t m) => (forall jsm. MonadJSM jsm => Location -> jsm a) -> m (Dynamic t a)

-- | Returns the URI-decoded location after the host and port; i.e. returns
--   the path, query, and fragment of the location.
getLocationAfterHost :: (MonadJSM m) => m Text

-- | Returns the URI-decoded fragment/hash of the current window location.
getLocationFragment :: (MonadJSM m) => m Text

-- | Returns the host of the current window location
getLocationHost :: (MonadJSM m) => m Text

-- | Returns the URI-decoded path of the current window location.
getLocationPath :: (MonadJSM m) => m Text

-- | Returns the protocol/scheme (e.g. <tt>http:</tt> or <tt>https:</tt>)
--   of the current window location
getLocationProtocol :: (MonadJSM m) => m Text

-- | Returns the full URI-decoded URL of the current window location.
getLocationUrl :: (MonadJSM m) => m Text
manageHistory :: (MonadJSM m, TriggerEvent t m, MonadHold t m, PerformEvent t m, MonadJSM (Performable m)) => Event t HistoryCommand -> m (Dynamic t HistoryItem)
data HistoryCommand
HistoryCommand_PushState :: HistoryStateUpdate -> HistoryCommand
HistoryCommand_ReplaceState :: HistoryStateUpdate -> HistoryCommand
data HistoryStateUpdate
HistoryStateUpdate :: SerializedScriptValue -> Text -> Maybe URI -> HistoryStateUpdate
[_historyStateUpdate_state] :: HistoryStateUpdate -> SerializedScriptValue
[_historyStateUpdate_title] :: HistoryStateUpdate -> Text

-- | If Just, update the URI; otherwise leave it unchanged NOTE: All URIs
--   in this module are assumed to be already percent-escaped
[_historyStateUpdate_uri] :: HistoryStateUpdate -> Maybe URI
data HistoryItem
HistoryItem :: SerializedScriptValue -> URI -> HistoryItem
[_historyItem_state] :: HistoryItem -> SerializedScriptValue

-- | NOTE: All URIs in this module are assumed to be already
--   percent-escaped
[_historyItem_uri] :: HistoryItem -> URI
getLocationUri :: MonadJSM m => Location -> m URI

module Reflex.Dom.Old
class MonadWidgetConstraints t m => MonadWidget t m
type El = Element EventResult GhcjsDomSpace
data ElConfig attrs
ElConfig :: Maybe Text -> attrs -> ElConfig attrs
[_elConfig_namespace] :: ElConfig attrs -> Maybe Text
[_elConfig_attributes] :: ElConfig attrs -> attrs
elConfig_namespace :: forall attrs_a5lW5. Lens' (ElConfig attrs_a5lW5) (Maybe Text)
elConfig_attributes :: forall attrs_a5lW5 attrs_a5lX0. Lens (ElConfig attrs_a5lW5) (ElConfig attrs_a5lX0) attrs_a5lW5 attrs_a5lX0

-- | <i>Deprecated: Use 'domEvent Click' instead</i>
_el_clicked :: Reflex t => Element EventResult d t -> Event t ()

-- | <i>Deprecated: Use <a>_element_raw</a> instead</i>
_el_element :: El t -> RawElement GhcjsDomSpace

-- | <i>Deprecated: Use <a>_element_events</a> instead; or, if possible,
--   use <a>domEvent</a> instead to retrieve a particular event</i>
_el_events :: Element er d t -> EventSelector t (WrapArg er EventName)
addVoidAction :: MonadWidget t m => Event t (WidgetHost m ()) -> m ()
type AttributeMap = Map Text Text
class Attributes m attrs t
buildElementInternal :: (Attributes m attrs t, MonadWidget t m) => Maybe Text -> Text -> attrs -> m a -> m (Element EventResult (DomBuilderSpace m) t, a)
buildElement :: (MonadWidget t m, Attributes m attrs t) => Text -> attrs -> m a -> m (RawElement (DomBuilderSpace m), a)
buildElementNS :: (MonadWidget t m, Attributes m attrs t) => Maybe Text -> Text -> attrs -> m a -> m (RawElement (DomBuilderSpace m), a)
buildEmptyElement :: (MonadWidget t m, Attributes m attrs t) => Text -> attrs -> m (RawElement (DomBuilderSpace m))
buildEmptyElementNS :: (MonadWidget t m, Attributes m attrs t) => Maybe Text -> Text -> attrs -> m (RawElement (DomBuilderSpace m))
elDynHtml' :: MonadWidget t m => Text -> Dynamic t Text -> m (Element EventResult GhcjsDomSpace t)
elDynHtmlAttr' :: (MonadJSM m, MonadWidget t m) => Text -> Map Text Text -> Dynamic t Text -> m (Element EventResult GhcjsDomSpace t)
elStopPropagationNS :: forall t m en a. (MonadWidget t m) => Maybe Text -> Text -> EventName en -> m a -> m a
elWith :: (MonadWidget t m, Attributes m attrs t) => Text -> ElConfig attrs -> m a -> m a
elWith' :: (MonadWidget t m, Attributes m attrs t) => Text -> ElConfig attrs -> m a -> m (Element EventResult (DomBuilderSpace m) t, a)
emptyElWith :: (MonadWidget t m, Attributes m attrs t) => Text -> ElConfig attrs -> m ()
emptyElWith' :: (MonadWidget t m, Attributes m attrs t) => Text -> ElConfig attrs -> m (Element EventResult (DomBuilderSpace m) t)
namedNodeMapGetNames :: NamedNodeMap -> JSM (Set Text)
nodeClear :: IsNode self => self -> JSM ()
onEventName :: IsHTMLElement e => EventName en -> e -> EventM e (EventType en) () -> JSM (JSM ())
schedulePostBuild :: (PostBuild t m, PerformEvent t m) => WidgetHost m () -> m ()
text' :: MonadWidget t m => Text -> m Text
unsafePlaceElement :: MonadWidget t m => HTMLElement -> m (Element EventResult (DomBuilderSpace m) t)
type WidgetHost m = Performable m
wrapElement :: forall t m. MonadWidget t m => (forall en. HTMLElement -> EventName en -> EventM Element (EventType en) (Maybe (EventResult en))) -> HTMLElement -> m (El t)
instance Reflex.Dom.Old.MonadWidgetConstraints t m => Reflex.Dom.Old.MonadWidget t m
instance Reflex.Dom.Old.Attributes m (Data.Map.Base.Map Data.Text.Internal.Text Data.Text.Internal.Text) t
instance Reflex.PostBuild.Class.PostBuild t m => Reflex.Dom.Old.Attributes m (Reflex.Class.Dynamic t (Data.Map.Base.Map Data.Text.Internal.Text Data.Text.Internal.Text)) t
instance Reflex.Dom.Widget.Basic.HasAttributes (Reflex.Dom.Old.ElConfig attrs)
instance Reflex.Dom.Builder.Class.HasNamespace (Reflex.Dom.Old.ElConfig attrs)
instance attrs ~ Data.Map.Base.Map Data.Text.Internal.Text Data.Text.Internal.Text => Data.Default.Class.Default (Reflex.Dom.Old.ElConfig attrs)

module Reflex.Dom.Prerender
class Prerender js m | m -> js
prerenderClientDict :: Prerender js m => Maybe (Dict (PrerenderClientConstraint js m))

-- | Draw one widget when prerendering (e.g. server-side) and another when
--   the widget is fully instantiated. In a given execution of this
--   function, there will be exactly one invocation of exactly one of the
--   arguments.
prerender :: forall js m a. Prerender js m => m a -> (PrerenderClientConstraint js m => m a) -> m a
instance (Foreign.JavaScript.TH.HasJS js m, Foreign.JavaScript.TH.HasJS js (Reflex.PerformEvent.Class.Performable m), Foreign.JavaScript.TH.HasJSContext m, Foreign.JavaScript.TH.HasJSContext (Reflex.PerformEvent.Class.Performable m), Language.Javascript.JSaddle.Types.MonadJSM m, Language.Javascript.JSaddle.Types.MonadJSM (Reflex.PerformEvent.Class.Performable m), Control.Monad.Fix.MonadFix m, Control.Monad.Fix.MonadFix (Reflex.PerformEvent.Class.Performable m), Reflex.Host.Class.ReflexHost t) => Reflex.Dom.Prerender.Prerender js (Reflex.Dom.Builder.Immediate.ImmediateDomBuilderT t m)
instance js ~ Reflex.Dom.Prerender.NoJavaScript => Reflex.Dom.Prerender.Prerender js (Reflex.Dom.Builder.Static.StaticDomBuilderT t m)
instance (Reflex.Dom.Prerender.Prerender js m, Reflex.Host.Class.ReflexHost t) => Reflex.Dom.Prerender.Prerender js (Reflex.PostBuild.Base.PostBuildT t m)
instance Reflex.Dom.Prerender.Prerender js m => Reflex.Dom.Prerender.Prerender js (Reflex.DynamicWriter.DynamicWriterT t w m)
instance Reflex.Dom.Prerender.Prerender js m => Reflex.Dom.Prerender.Prerender js (Control.Monad.Trans.Reader.ReaderT w m)
instance Reflex.Dom.Prerender.Prerender js m => Reflex.Dom.Prerender.Prerender js (Reflex.Requester.Base.RequesterT t request response m)
instance Reflex.Dom.Prerender.Prerender js m => Reflex.Dom.Prerender.Prerender js (Reflex.Query.Base.QueryT t q m)
instance Reflex.Dom.Prerender.Prerender js m => Reflex.Dom.Prerender.Prerender js (Reflex.Dom.Builder.InputDisabled.InputDisabledT m)

module Reflex.Dom.Specializations

module Reflex.Dom.Main
mainWidget :: (forall x. Widget x ()) -> JSM ()

-- | Warning: <a>mainWidget'</a> is provided only as performance tweak. It
--   is expected to disappear in future releases.
mainWidget' :: Widget () () -> JSM ()
mainWidgetWithHead :: (forall x. Widget x ()) -> (forall x. Widget x ()) -> JSM ()
mainWidgetWithCss :: ByteString -> (forall x. Widget x ()) -> JSM ()

-- | The Reflex timeline for interacting with the DOM
type DomTimeline = Spider

-- | The ReflexHost the DOM lives in
type DomHost = SpiderHost Global
runDomHost :: DomHost a -> IO a
type Widget x = PostBuildT DomTimeline (ImmediateDomBuilderT DomTimeline (WithJSContextSingleton x (PerformEventT DomTimeline DomHost)))
attachWidget :: IsElement e => e -> JSContextSingleton x -> Widget x a -> JSM a

-- | Warning: <a>mainWidgetWithHead'</a> is provided only as performance
--   tweak. It is expected to disappear in future releases.
mainWidgetWithHead' :: (a -> Widget () b, b -> Widget () a) -> JSM ()
replaceElementContents :: IsElement e => e -> DocumentFragment -> JSM ()
attachWidget' :: IsElement e => e -> JSContextSingleton x -> Widget x a -> JSM (a, FireCommand DomTimeline DomHost)
type EventChannel = Chan [DSum (EventTriggerRef DomTimeline) TriggerInvocation]
attachWidget'' :: (EventChannel -> PerformEventT DomTimeline DomHost (a, IORef (Maybe (EventTrigger DomTimeline ())))) -> IO (a, FireCommand DomTimeline DomHost)
processAsyncEvents :: EventChannel -> FireCommand DomTimeline DomHost -> IO ()

-- | Run a reflex-dom application inside of an existing DOM element with
--   the given ID
mainWidgetInElementById :: Text -> (forall x. Widget x ()) -> JSM ()
newtype AppInput t
AppInput :: Window t -> AppInput t
[_appInput_window] :: AppInput t -> Window t
newtype AppOutput t
AppOutput :: WindowConfig t -> AppOutput t
[_appOutput_windowConfig] :: AppOutput t -> WindowConfig t
runApp' :: (t ~ DomTimeline) => (forall x. AppInput t -> Widget x (AppOutput t)) -> JSM ()

module Reflex.Dom.Widget.Input
data TextInput t
TextInput :: Dynamic t Text -> Event t Text -> Event t Word -> Event t Word -> Event t Word -> Dynamic t Bool -> InputElement EventResult GhcjsDomSpace t -> TextInput t
[_textInput_value] :: TextInput t -> Dynamic t Text
[_textInput_input] :: TextInput t -> Event t Text
[_textInput_keypress] :: TextInput t -> Event t Word
[_textInput_keydown] :: TextInput t -> Event t Word
[_textInput_keyup] :: TextInput t -> Event t Word
[_textInput_hasFocus] :: TextInput t -> Dynamic t Bool
[_textInput_builderElement] :: TextInput t -> InputElement EventResult GhcjsDomSpace t
_textInput_element :: TextInput t -> HTMLInputElement
data TextInputConfig t
TextInputConfig :: Text -> Text -> Event t Text -> Dynamic t (Map Text Text) -> TextInputConfig t
[_textInputConfig_inputType] :: TextInputConfig t -> Text
[_textInputConfig_initialValue] :: TextInputConfig t -> Text
[_textInputConfig_setValue] :: TextInputConfig t -> Event t Text
[_textInputConfig_attributes] :: TextInputConfig t -> Dynamic t (Map Text Text)

-- | Create an input whose value is a string. By default, the "type"
--   attribute is set to "text", but it can be changed using the
--   _textInputConfig_inputType field. Note that only types for which the
--   value is always a string will work - types whose value may be null
--   will not work properly with this widget.
textInput :: (DomBuilder t m, PostBuild t m, DomBuilderSpace m ~ GhcjsDomSpace) => TextInputConfig t -> m (TextInput t)

-- | <i>Deprecated: Use 'keypress Enter' instead</i>
textInputGetEnter :: Reflex t => TextInput t -> Event t ()
keypress :: (Reflex t, HasDomEvent t e KeypressTag, DomEventType e KeypressTag ~ Word) => Key -> e -> Event t ()
keydown :: (Reflex t, HasDomEvent t e KeydownTag, DomEventType e KeydownTag ~ Word) => Key -> e -> Event t ()
keyup :: (Reflex t, HasDomEvent t e KeyupTag, DomEventType e KeyupTag ~ Word) => Key -> e -> Event t ()
data RangeInputConfig t
RangeInputConfig :: Float -> Event t Float -> Dynamic t (Map Text Text) -> RangeInputConfig t
[_rangeInputConfig_initialValue] :: RangeInputConfig t -> Float
[_rangeInputConfig_setValue] :: RangeInputConfig t -> Event t Float
[_rangeInputConfig_attributes] :: RangeInputConfig t -> Dynamic t (Map Text Text)
data RangeInput t
RangeInput :: Dynamic t Float -> Event t Float -> Event t (Int, Int) -> Dynamic t Bool -> HTMLInputElement -> RangeInput t
[_rangeInput_value] :: RangeInput t -> Dynamic t Float
[_rangeInput_input] :: RangeInput t -> Event t Float
[_rangeInput_mouseup] :: RangeInput t -> Event t (Int, Int)
[_rangeInput_hasFocus] :: RangeInput t -> Dynamic t Bool
[_rangeInput_element] :: RangeInput t -> HTMLInputElement

-- | Create an input whose value is a float.
--   <a>https://www.w3.org/wiki/HTML/Elements/input/range</a>
rangeInput :: (DomBuilder t m, PostBuild t m, DomBuilderSpace m ~ GhcjsDomSpace) => RangeInputConfig t -> m (RangeInput t)
data TextAreaConfig t
TextAreaConfig :: Text -> Event t Text -> Dynamic t (Map Text Text) -> TextAreaConfig t
[_textAreaConfig_initialValue] :: TextAreaConfig t -> Text
[_textAreaConfig_setValue] :: TextAreaConfig t -> Event t Text
[_textAreaConfig_attributes] :: TextAreaConfig t -> Dynamic t (Map Text Text)
data TextArea t
TextArea :: Dynamic t Text -> Event t Text -> Dynamic t Bool -> Event t Word -> HTMLTextAreaElement -> TextArea t
[_textArea_value] :: TextArea t -> Dynamic t Text
[_textArea_input] :: TextArea t -> Event t Text
[_textArea_hasFocus] :: TextArea t -> Dynamic t Bool
[_textArea_keypress] :: TextArea t -> Event t Word
[_textArea_element] :: TextArea t -> HTMLTextAreaElement
textArea :: (DomBuilder t m, PostBuild t m, DomBuilderSpace m ~ GhcjsDomSpace) => TextAreaConfig t -> m (TextArea t)
data CheckboxConfig t
CheckboxConfig :: Event t Bool -> Dynamic t (Map Text Text) -> CheckboxConfig t
[_checkboxConfig_setValue] :: CheckboxConfig t -> Event t Bool
[_checkboxConfig_attributes] :: CheckboxConfig t -> Dynamic t (Map Text Text)
data Checkbox t
Checkbox :: Dynamic t Bool -> Event t Bool -> Checkbox t
[_checkbox_value] :: Checkbox t -> Dynamic t Bool
[_checkbox_change] :: Checkbox t -> Event t Bool

-- | Create an editable checkbox Note: if the "type" or "checked"
--   attributes are provided as attributes, they will be ignored
checkbox :: (DomBuilder t m, PostBuild t m) => Bool -> CheckboxConfig t -> m (Checkbox t)
regularToCheckboxViewEventType :: EventName t -> EventResultType t -> CheckboxViewEventResultType t
newtype CheckboxViewEventResult en
CheckboxViewEventResult :: CheckboxViewEventResultType en -> CheckboxViewEventResult en
[unCheckboxViewEventResult] :: CheckboxViewEventResult en -> CheckboxViewEventResultType en
checkboxView :: forall t m. (DomBuilder t m, DomBuilderSpace m ~ GhcjsDomSpace, PostBuild t m, MonadHold t m) => Dynamic t (Map Text Text) -> Dynamic t Bool -> m (Event t Bool)
data FileInput d t
FileInput :: Dynamic t [File] -> RawInputElement d -> FileInput d t
[_fileInput_value] :: FileInput d t -> Dynamic t [File]
[_fileInput_element] :: FileInput d t -> RawInputElement d
newtype FileInputConfig t
FileInputConfig :: Dynamic t (Map Text Text) -> FileInputConfig t
[_fileInputConfig_attributes] :: FileInputConfig t -> Dynamic t (Map Text Text)
fileInput :: forall t m. (MonadIO m, MonadJSM m, MonadFix m, MonadHold t m, TriggerEvent t m, DomBuilder t m, PostBuild t m, DomBuilderSpace m ~ GhcjsDomSpace) => FileInputConfig t -> m (FileInput (DomBuilderSpace m) t)
data Dropdown t k
Dropdown :: Dynamic t k -> Event t k -> Dropdown t k
[_dropdown_value] :: Dropdown t k -> Dynamic t k
[_dropdown_change] :: Dropdown t k -> Event t k
data DropdownConfig t k
DropdownConfig :: Event t k -> Dynamic t (Map Text Text) -> DropdownConfig t k
[_dropdownConfig_setValue] :: DropdownConfig t k -> Event t k
[_dropdownConfig_attributes] :: DropdownConfig t k -> Dynamic t (Map Text Text)
newtype DropdownViewEventResult en
DropdownViewEventResult :: DropdownViewEventResultType en -> DropdownViewEventResult en
[unDropdownViewEventResult] :: DropdownViewEventResult en -> DropdownViewEventResultType en
regularToDropdownViewEventType :: EventName t -> EventResultType t -> DropdownViewEventResultType t

-- | Create a dropdown box The first argument gives the initial value of
--   the dropdown; if it is not present in the map of options provided, it
--   will be added with an empty string as its text
dropdown :: forall k t m. (DomBuilder t m, MonadFix m, MonadHold t m, PostBuild t m, Ord k) => k -> Dynamic t (Map k Text) -> DropdownConfig t k -> m (Dropdown t k)
checkbox_value :: forall t_a6szg. Lens' (Checkbox t_a6szg) (Dynamic t_a6szg Bool)
checkbox_change :: forall t_a6szg. Lens' (Checkbox t_a6szg) (Event t_a6szg Bool)
checkboxConfig_setValue :: forall t_a6szh. Lens' (CheckboxConfig t_a6szh) (Event t_a6szh Bool)
checkboxConfig_attributes :: forall t_a6szh. Lens' (CheckboxConfig t_a6szh) (Dynamic t_a6szh (Map Text Text))
dropdown_value :: forall t_a6sz8 k_a6sz9. Lens' (Dropdown t_a6sz8 k_a6sz9) (Dynamic t_a6sz8 k_a6sz9)
dropdown_change :: forall t_a6sz8 k_a6sz9. Lens' (Dropdown t_a6sz8 k_a6sz9) (Event t_a6sz8 k_a6sz9)
dropdownConfig_setValue :: forall t_a6sz6 k_a6sz7 k_a6tRx. Lens (DropdownConfig t_a6sz6 k_a6sz7) (DropdownConfig t_a6sz6 k_a6tRx) (Event t_a6sz6 k_a6sz7) (Event t_a6sz6 k_a6tRx)
dropdownConfig_attributes :: forall t_a6sz6 k_a6sz7. Lens' (DropdownConfig t_a6sz6 k_a6sz7) (Dynamic t_a6sz6 (Map Text Text))
fileInput_value :: forall d_a6szb t_a6szc t_a6tRo. Lens (FileInput d_a6szb t_a6szc) (FileInput d_a6szb t_a6tRo) (Dynamic t_a6szc [File]) (Dynamic t_a6tRo [File])
fileInput_element :: forall d_a6szb t_a6szc d_a6tRn. Lens (FileInput d_a6szb t_a6szc) (FileInput d_a6tRn t_a6szc) (RawInputElement d_a6szb) (RawInputElement d_a6tRn)
fileInputConfig_attributes :: forall t_a6sza t_a6tRl. Iso (FileInputConfig t_a6sza) (FileInputConfig t_a6tRl) (Dynamic t_a6sza (Map Text Text)) (Dynamic t_a6tRl (Map Text Text))
rangeInput_value :: forall t_a6szk. Lens' (RangeInput t_a6szk) (Dynamic t_a6szk Float)
rangeInput_mouseup :: forall t_a6szk. Lens' (RangeInput t_a6szk) (Event t_a6szk (Int, Int))
rangeInput_input :: forall t_a6szk. Lens' (RangeInput t_a6szk) (Event t_a6szk Float)
rangeInput_hasFocus :: forall t_a6szk. Lens' (RangeInput t_a6szk) (Dynamic t_a6szk Bool)
rangeInput_element :: forall t_a6szk. Lens' (RangeInput t_a6szk) HTMLInputElement
rangeInputConfig_setValue :: forall t_a6szl. Lens' (RangeInputConfig t_a6szl) (Event t_a6szl Float)
rangeInputConfig_initialValue :: forall t_a6szl. Lens' (RangeInputConfig t_a6szl) Float
rangeInputConfig_attributes :: forall t_a6szl. Lens' (RangeInputConfig t_a6szl) (Dynamic t_a6szl (Map Text Text))
textInput_value :: forall t_a6szn. Lens' (TextInput t_a6szn) (Dynamic t_a6szn Text)
textInput_keyup :: forall t_a6szn. Lens' (TextInput t_a6szn) (Event t_a6szn Word)
textInput_keypress :: forall t_a6szn. Lens' (TextInput t_a6szn) (Event t_a6szn Word)
textInput_keydown :: forall t_a6szn. Lens' (TextInput t_a6szn) (Event t_a6szn Word)
textInput_input :: forall t_a6szn. Lens' (TextInput t_a6szn) (Event t_a6szn Text)
textInput_hasFocus :: forall t_a6szn. Lens' (TextInput t_a6szn) (Dynamic t_a6szn Bool)
textInput_builderElement :: forall t_a6szn. Lens' (TextInput t_a6szn) (InputElement EventResult GhcjsDomSpace t_a6szn)
textInputConfig_setValue :: forall t_a6szm. Lens' (TextInputConfig t_a6szm) (Event t_a6szm Text)
textInputConfig_inputType :: forall t_a6szm. Lens' (TextInputConfig t_a6szm) Text
textInputConfig_initialValue :: forall t_a6szm. Lens' (TextInputConfig t_a6szm) Text
textInputConfig_attributes :: forall t_a6szm. Lens' (TextInputConfig t_a6szm) (Dynamic t_a6szm (Map Text Text))
textArea_value :: forall t_a6szi. Lens' (TextArea t_a6szi) (Dynamic t_a6szi Text)
textArea_keypress :: forall t_a6szi. Lens' (TextArea t_a6szi) (Event t_a6szi Word)
textArea_input :: forall t_a6szi. Lens' (TextArea t_a6szi) (Event t_a6szi Text)
textArea_hasFocus :: forall t_a6szi. Lens' (TextArea t_a6szi) (Dynamic t_a6szi Bool)
textArea_element :: forall t_a6szi. Lens' (TextArea t_a6szi) HTMLTextAreaElement
textAreaConfig_setValue :: forall t_a6szj. Lens' (TextAreaConfig t_a6szj) (Event t_a6szj Text)
textAreaConfig_initialValue :: forall t_a6szj. Lens' (TextAreaConfig t_a6szj) Text
textAreaConfig_attributes :: forall t_a6szj. Lens' (TextAreaConfig t_a6szj) (Dynamic t_a6szj (Map Text Text))
class HasSetValue a where type SetValue a :: * where {
    type family SetValue a :: *;
}
setValue :: HasSetValue a => Lens' a (SetValue a)
class HasValue a where type Value a :: * where {
    type family Value a :: *;
}
value :: HasValue a => a -> Value a

-- | The default value for this type.
def :: Default a => a

-- | <a>&amp;</a> is a reverse application operator. This provides
--   notational convenience. Its precedence is one higher than that of the
--   forward application operator <a>$</a>, which allows <a>&amp;</a> to be
--   nested in <a>$</a>.
(&) :: a -> (a -> b) -> b
infixl 1 &

-- | Replace the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> with a constant value.
--   
--   This is an infix version of <a>set</a>, provided for consistency with
--   (<a>.=</a>).
--   
--   <pre>
--   f <a>&lt;$</a> a  <a>mapped</a> <a>.~</a> f <a>$</a> a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b,c,d) &amp; _4 .~ e
--   (a,b,c,e)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (42,"world") &amp; _1 .~ "hello"
--   ("hello","world")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both .~ c
--   (c,c)
--   </pre>
--   
--   <pre>
--   (<a>.~</a>) :: <a>Setter</a> s t a b    -&gt; b -&gt; s -&gt; t
--   (<a>.~</a>) :: <a>Iso</a> s t a b       -&gt; b -&gt; s -&gt; t
--   (<a>.~</a>) :: <a>Lens</a> s t a b      -&gt; b -&gt; s -&gt; t
--   (<a>.~</a>) :: <a>Traversal</a> s t a b -&gt; b -&gt; s -&gt; t
--   </pre>
(.~) :: ASetter s t a b -> b -> s -> t
infixr 4 .~
instance Reflex.Dom.Widget.Basic.HasAttributes (Reflex.Dom.Widget.Input.TextAreaConfig t)
instance Reflex.Dom.Widget.Basic.HasAttributes (Reflex.Dom.Widget.Input.TextInputConfig t)
instance Reflex.Dom.Widget.Basic.HasAttributes (Reflex.Dom.Widget.Input.RangeInputConfig t)
instance Reflex.Dom.Widget.Basic.HasAttributes (Reflex.Dom.Widget.Input.DropdownConfig t k)
instance Reflex.Dom.Widget.Basic.HasAttributes (Reflex.Dom.Widget.Input.CheckboxConfig t)
instance Reflex.Dom.Widget.Basic.HasAttributes (Reflex.Dom.Widget.Input.FileInputConfig t)
instance Reflex.Dom.Widget.Input.HasSetValue (Reflex.Dom.Widget.Input.TextAreaConfig t)
instance Reflex.Dom.Widget.Input.HasSetValue (Reflex.Dom.Widget.Input.TextInputConfig t)
instance Reflex.Dom.Widget.Input.HasSetValue (Reflex.Dom.Widget.Input.RangeInputConfig t)
instance Reflex.Dom.Widget.Input.HasSetValue (Reflex.Dom.Widget.Input.DropdownConfig t k)
instance Reflex.Dom.Widget.Input.HasSetValue (Reflex.Dom.Widget.Input.CheckboxConfig t)
instance forall k (er :: Reflex.Dom.Builder.Class.Events.EventTag -> GHC.Types.*) (d :: k) t. Reflex.Dom.Widget.Input.HasValue (Reflex.Dom.Builder.Class.InputElement er d t)
instance forall k (er :: Reflex.Dom.Builder.Class.Events.EventTag -> GHC.Types.*) (d :: k) t. Reflex.Dom.Widget.Input.HasValue (Reflex.Dom.Builder.Class.TextAreaElement er d t)
instance Reflex.Dom.Widget.Input.HasValue (Reflex.Dom.Widget.Input.TextArea t)
instance Reflex.Dom.Widget.Input.HasValue (Reflex.Dom.Widget.Input.TextInput t)
instance Reflex.Dom.Widget.Input.HasValue (Reflex.Dom.Widget.Input.RangeInput t)
instance forall k (d :: k) t. Reflex.Dom.Widget.Input.HasValue (Reflex.Dom.Widget.Input.FileInput d t)
instance Reflex.Dom.Widget.Input.HasValue (Reflex.Dom.Widget.Input.Dropdown t k)
instance Reflex.Dom.Widget.Input.HasValue (Reflex.Dom.Widget.Input.Checkbox t)
instance Reflex.Class.Reflex t => Reflex.Dom.Builder.Class.HasDomEvent t (Reflex.Dom.Widget.Input.TextInput t) en
instance Reflex.Class.Reflex t => Data.Default.Class.Default (Reflex.Dom.Widget.Input.TextInputConfig t)
instance Reflex.Class.Reflex t => Data.Default.Class.Default (Reflex.Dom.Widget.Input.RangeInputConfig t)
instance Reflex.Class.Reflex t => Data.Default.Class.Default (Reflex.Dom.Widget.Input.TextAreaConfig t)
instance Reflex.Class.Reflex t => Data.Default.Class.Default (Reflex.Dom.Widget.Input.CheckboxConfig t)
instance Reflex.Class.Reflex t => Data.Default.Class.Default (Reflex.Dom.Widget.Input.FileInputConfig t)
instance Reflex.Class.Reflex t => Data.Default.Class.Default (Reflex.Dom.Widget.Input.DropdownConfig t k)

module Reflex.Dom.Widget.Lazy

-- | A list view for long lists. Creates a scrollable element and only
--   renders child row elements near the current scroll position.
virtualListWithSelection :: forall t m k v. (DomBuilder t m, PostBuild t m, MonadHold t m, PerformEvent t m, MonadJSM (Performable m), DomBuilderSpace m ~ GhcjsDomSpace, MonadFix m, Ord k) => Dynamic t Int -> Int -> Dynamic t Int -> Int -> Event t Int -> Text -> Dynamic t (Map Text Text) -> Text -> Dynamic t (Map Text Text) -> (k -> Dynamic t (Maybe v) -> Dynamic t Bool -> m ()) -> Dynamic t (Map k v) -> (Int -> k) -> m (Dynamic t (Int, Int), Event t k)
virtualList :: forall t m k v a. (DomBuilder t m, PostBuild t m, MonadHold t m, PerformEvent t m, MonadJSM (Performable m), DomBuilderSpace m ~ GhcjsDomSpace, MonadFix m, Ord k) => Dynamic t Int -> Int -> Dynamic t Int -> Int -> Event t Int -> (k -> Int) -> Map k v -> Event t (Map k (Maybe v)) -> (k -> v -> Event t v -> m a) -> m (Dynamic t (Int, Int), Dynamic t (Map k a))
virtualListBuffered :: (DomBuilder t m, PostBuild t m, MonadHold t m, PerformEvent t m, MonadJSM (Performable m), DomBuilderSpace m ~ GhcjsDomSpace, MonadFix m, Ord k) => Int -> Dynamic t Int -> Int -> Dynamic t Int -> Int -> Event t Int -> (k -> Int) -> Map k v -> Event t (Map k (Maybe v)) -> (k -> v -> Event t v -> m a) -> m (Event t (Int, Int), Dynamic t (Map k a))

module Reflex.Dom.Widget.Resize

-- | A widget that wraps the given widget in a div and fires an event when
--   resized. Adapted from github.com<i>marcj</i>css-element-queries
resizeDetector :: (MonadJSM m, DomBuilder t m, PostBuild t m, TriggerEvent t m, PerformEvent t m, MonadHold t m, DomBuilderSpace m ~ GhcjsDomSpace, MonadJSM (Performable m), MonadFix m) => m a -> m (Event t (), a)
resizeDetectorWithStyle :: (MonadJSM m, DomBuilder t m, PostBuild t m, TriggerEvent t m, PerformEvent t m, MonadHold t m, DomBuilderSpace m ~ GhcjsDomSpace, MonadJSM (Performable m), MonadFix m) => Text -> m a -> m (Event t (), a)
resizeDetectorWithAttrs :: (MonadJSM m, DomBuilder t m, PostBuild t m, TriggerEvent t m, PerformEvent t m, MonadHold t m, DomBuilderSpace m ~ GhcjsDomSpace, MonadJSM (Performable m), MonadFix m) => Map Text Text -> m a -> m (Event t (), a)

module Reflex.Dom.Widget

module Reflex.Dom.Core
