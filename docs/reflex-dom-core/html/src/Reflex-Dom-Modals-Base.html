<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>src/Reflex/Dom/Modals/Base.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-
<a name="line-2"></a>{-# LANGUAGE CPP #-}
<a name="line-3"></a>{-# LANGUAGE FlexibleInstances #-}
<a name="line-4"></a>{-# LANGUAGE GeneralizedNewtypeDeriving #-}
<a name="line-5"></a>{-# LANGUAGE OverloadedStrings #-}
<a name="line-6"></a>{-# LANGUAGE MultiParamTypeClasses #-}
<a name="line-7"></a>{-# LANGUAGE RankNTypes #-}
<a name="line-8"></a>{-# LANGUAGE RecursiveDo #-}
<a name="line-9"></a>{-# LANGUAGE ScopedTypeVariables #-}
<a name="line-10"></a>{-# LANGUAGE TypeFamilies #-}
<a name="line-11"></a>{-# LANGUAGE UndecidableInstances #-}
<a name="line-12"></a>-}</span>
<a name="line-13"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>Reflex</span><span class='hs-varop'>.</span><span class='hs-conid'>Dom</span><span class='hs-varop'>.</span><span class='hs-conid'>Modals</span><span class='hs-varop'>.</span><span class='hs-conid'>Base</span>
<a name="line-14"></a><span class='hs-keyword'>where</span>
<a name="line-15"></a><span class='hs-comment'>{-
<a name="line-16"></a>  ( ModalsT (..)
<a name="line-17"></a>  , ModalLayerConfig (..)
<a name="line-18"></a>  , withModalLayer
<a name="line-19"></a>  )where
<a name="line-20"></a>
<a name="line-21"></a>import Control.Lens hiding (element)
<a name="line-22"></a>import Control.Monad.Fix
<a name="line-23"></a>import Control.Monad.Primitive
<a name="line-24"></a>import Control.Monad.Ref
<a name="line-25"></a>import Control.Monad.Trans
<a name="line-26"></a>import Data.Coerce
<a name="line-27"></a>import Data.Default
<a name="line-28"></a>import Data.Dependent.Map (DMap, DSum (..), GCompare)
<a name="line-29"></a>import qualified Data.Dependent.Map as DMap
<a name="line-30"></a>import Data.Functor.Compose
<a name="line-31"></a>import Data.Proxy
<a name="line-32"></a>import Data.Semigroup
<a name="line-33"></a>import Data.Text (Text)
<a name="line-34"></a>import qualified Data.Text as T
<a name="line-35"></a>import Foreign.JavaScript.TH
<a name="line-36"></a>import Language.Javascript.JSaddle (MonadJSM)
<a name="line-37"></a>
<a name="line-38"></a>import Data.Functor.Misc
<a name="line-39"></a>import Reflex
<a name="line-40"></a>import Reflex.Dom.Builder.Class
<a name="line-41"></a>import Reflex.Dom.Builder.Immediate
<a name="line-42"></a>import Reflex.Dom.Class
<a name="line-43"></a>import Reflex.Dom.Modals.Class
<a name="line-44"></a>import Reflex.Host.Class
<a name="line-45"></a>
<a name="line-46"></a>instance (Reflex t, PrimMonad m) =&gt; ModalOpener t (ModalsT t m) where
<a name="line-47"></a>  requestingModal = ModalsT . requesting . fmap Compose
<a name="line-48"></a>
<a name="line-49"></a>newtype ModalsT t m a = ModalsT { unModalsT :: RequesterT t (Compose (ModalsT t m) (Event t)) Maybe m a }
<a name="line-50"></a>  deriving (Functor, Applicative, Monad, MonadIO, MonadFix)
<a name="line-51"></a>
<a name="line-52"></a>instance Wrapped (ModalsT t m a) where
<a name="line-53"></a>  type Unwrapped (ModalsT t m a) = RequesterT t (Compose (ModalsT t m) (Event t)) Maybe m a
<a name="line-54"></a>  _Wrapped' = iso coerce coerce
<a name="line-55"></a>
<a name="line-56"></a>instance ModalsT t m a ~ x =&gt; Rewrapped (ModalsT t m a) x
<a name="line-57"></a>
<a name="line-58"></a>instance MonadTrans (ModalsT t) where
<a name="line-59"></a>  lift = ModalsT . lift
<a name="line-60"></a>
<a name="line-61"></a>instance (Reflex t, PostBuild t m) =&gt; PostBuild t (ModalsT t m) where
<a name="line-62"></a>  getPostBuild = view _Unwrapped getPostBuild
<a name="line-63"></a>
<a name="line-64"></a>instance MonadSample t m =&gt; MonadSample t (ModalsT t m) where
<a name="line-65"></a>  {-# INLINABLE sample #-}
<a name="line-66"></a>  sample = lift . sample
<a name="line-67"></a>
<a name="line-68"></a>instance MonadHold t m =&gt; MonadHold t (ModalsT t m) where
<a name="line-69"></a>  {-# INLINABLE hold #-}
<a name="line-70"></a>  hold v0 = lift . hold v0
<a name="line-71"></a>  {-# INLINABLE holdDyn #-}
<a name="line-72"></a>  holdDyn v0 = lift . holdDyn v0
<a name="line-73"></a>  {-# INLINABLE holdIncremental #-}
<a name="line-74"></a>  holdIncremental v0 = lift . holdIncremental v0
<a name="line-75"></a>
<a name="line-76"></a>instance PerformEvent t m =&gt; PerformEvent t (ModalsT t m) where
<a name="line-77"></a>  type Performable (ModalsT t m) = Performable m
<a name="line-78"></a>  {-# INLINABLE performEvent_ #-}
<a name="line-79"></a>  performEvent_ = lift . performEvent_
<a name="line-80"></a>  {-# INLINABLE performEvent #-}
<a name="line-81"></a>  performEvent = lift . performEvent
<a name="line-82"></a>
<a name="line-83"></a>instance (ReflexHost t, MonadReflexCreateTrigger t m) =&gt; MonadReflexCreateTrigger t (ModalsT t m) where
<a name="line-84"></a>  {-# INLINABLE newEventWithTrigger #-}
<a name="line-85"></a>  newEventWithTrigger = ModalsT . lift . newEventWithTrigger
<a name="line-86"></a>  {-# INLINABLE newFanEventWithTrigger #-}
<a name="line-87"></a>  newFanEventWithTrigger f = ModalsT $ lift $ newFanEventWithTrigger f
<a name="line-88"></a>
<a name="line-89"></a>instance TriggerEvent t m =&gt; TriggerEvent t (ModalsT t m) where
<a name="line-90"></a>  {-# INLINABLE newTriggerEvent #-}
<a name="line-91"></a>  newTriggerEvent = lift newTriggerEvent
<a name="line-92"></a>  {-# INLINABLE newTriggerEventWithOnComplete #-}
<a name="line-93"></a>  newTriggerEventWithOnComplete = lift newTriggerEventWithOnComplete
<a name="line-94"></a>  newEventWithLazyTriggerWithOnComplete = lift . newEventWithLazyTriggerWithOnComplete
<a name="line-95"></a>
<a name="line-96"></a>instance MonadRef m =&gt; MonadRef (ModalsT t m) where
<a name="line-97"></a>  type Ref (ModalsT t m) = Ref m
<a name="line-98"></a>  {-# INLINABLE newRef #-}
<a name="line-99"></a>  newRef = lift . newRef
<a name="line-100"></a>  {-# INLINABLE readRef #-}
<a name="line-101"></a>  readRef = lift . readRef
<a name="line-102"></a>  {-# INLINABLE writeRef #-}
<a name="line-103"></a>  writeRef r = lift . writeRef r
<a name="line-104"></a>
<a name="line-105"></a>instance MonadAtomicRef m =&gt; MonadAtomicRef (ModalsT t m) where
<a name="line-106"></a>  {-# INLINABLE atomicModifyRef #-}
<a name="line-107"></a>  atomicModifyRef r = lift . atomicModifyRef r
<a name="line-108"></a>
<a name="line-109"></a>instance (Adjustable t m, MonadHold t m, MonadFix m) =&gt; Adjustable t (ModalsT t m) where
<a name="line-110"></a>  runWithReplace a0 a' = ModalsT $ runWithReplace (unModalsT a0) (fmapCheap unModalsT a')
<a name="line-111"></a>  traverseDMapWithKeyWithAdjust f dm0 dm' = ModalsT $ traverseDMapWithKeyWithAdjust (coerce f) dm0 dm'
<a name="line-112"></a>  traverseDMapWithKeyWithAdjustWithMove f dm0 dm' = ModalsT $ traverseDMapWithKeyWithAdjustWithMove (coerce f) dm0 dm'
<a name="line-113"></a>
<a name="line-114"></a>instance (DomBuilder t m, PerformEvent t m, MonadFix m, MonadHold t m) =&gt; DomBuilder t (ModalsT t m) where
<a name="line-115"></a>  type DomBuilderSpace (ModalsT t m) = DomBuilderSpace m
<a name="line-116"></a>  element = coerce (element :: Text -&gt; ElementConfig er t (DomBuilderSpace m) -&gt; Unwrapped (ModalsT t m a) -&gt; Unwrapped (ModalsT t m (Element er (DomBuilderSpace m) t, a)))
<a name="line-117"></a>  inputElement = coerce (inputElement :: InputElementConfig er t (DomBuilderSpace m) -&gt; Unwrapped (ModalsT t m (InputElement er (DomBuilderSpace m) t)))
<a name="line-118"></a>  textAreaElement = coerce (textAreaElement :: TextAreaElementConfig er t (DomBuilderSpace m) -&gt; Unwrapped (ModalsT t m (TextAreaElement er (DomBuilderSpace m) t)))
<a name="line-119"></a>  selectElement = coerce (selectElement :: SelectElementConfig er t (DomBuilderSpace m) -&gt; Unwrapped (ModalsT t m a) -&gt; Unwrapped (ModalsT t m (SelectElement er (DomBuilderSpace m) t, a)))
<a name="line-120"></a>  wrapRawElement e = (view _Unwrapped :: forall a. Unwrapped (ModalsT t m a) -&gt; ModalsT t m a) . wrapRawElement e
<a name="line-121"></a>
<a name="line-122"></a>instance HasDocument m =&gt; HasDocument (ModalsT t m)
<a name="line-123"></a>instance HasJSContext m =&gt; HasJSContext (ModalsT t m) where
<a name="line-124"></a>  type JSContextPhantom (ModalsT t m) = JSContextPhantom m
<a name="line-125"></a>  askJSContext = ModalsT askJSContext
<a name="line-126"></a>#ifndef ghcjs_HOST_OS
<a name="line-127"></a>instance MonadJSM m =&gt; MonadJSM (ModalsT t m)
<a name="line-128"></a>#endif
<a name="line-129"></a>
<a name="line-130"></a>data ModalLayerConfig t m = ModalLayerConfig
<a name="line-131"></a>  { _modalLayerConfig_backdropElementConfig :: ElementConfig EventResult t (DomBuilderSpace m)
<a name="line-132"></a>  , _modalLayerConfig_bodyElementConfig :: ElementConfig EventResult t (DomBuilderSpace m)
<a name="line-133"></a>  }
<a name="line-134"></a>
<a name="line-135"></a>instance (DomBuilder t m) =&gt; Default (ModalLayerConfig t m) where
<a name="line-136"></a>  def = ModalLayerConfig
<a name="line-137"></a>    { _modalLayerConfig_backdropElementConfig = (def :: ElementConfig EventResult t (DomBuilderSpace m))
<a name="line-138"></a>        &amp; elementConfig_eventSpec %~ addEventSpecFlags (Proxy :: Proxy (DomBuilderSpace m)) Click (const stopPropagation)
<a name="line-139"></a>        &amp; initialAttributes .~ ("style" =: T.intercalate ";"
<a name="line-140"></a>            [ "position:absolute"
<a name="line-141"></a>            , "left:0", "right:0", "top:0", "bottom:0"
<a name="line-142"></a>            , "background-color:rgba(0,0,0,0.1)"
<a name="line-143"></a>            , "display:flex", "justify-content:center", "align-items:center"
<a name="line-144"></a>            ])
<a name="line-145"></a>    , _modalLayerConfig_bodyElementConfig = (def :: ElementConfig EventResult t (DomBuilderSpace m))
<a name="line-146"></a>        &amp; elementConfig_eventSpec %~ addEventSpecFlags (Proxy :: Proxy (DomBuilderSpace m)) Click (const stopPropagation)
<a name="line-147"></a>        &amp; initialAttributes .~ ("style" =: "background-color:white;opacity:1;padding:1em")
<a name="line-148"></a>    }
<a name="line-149"></a>
<a name="line-150"></a>instance (MonadQuery t q m, Monad m) =&gt; MonadQuery t q (ModalsT t m) where
<a name="line-151"></a>  tellQueryIncremental = lift . tellQueryIncremental
<a name="line-152"></a>  askQueryResult = lift askQueryResult
<a name="line-153"></a>  queryIncremental = lift . queryIncremental
<a name="line-154"></a>
<a name="line-155"></a>withModalLayer :: forall t m a. (Reflex t, MonadFix m, DomBuilder t m, MonadHold t m)
<a name="line-156"></a>               =&gt; ModalLayerConfig t m
<a name="line-157"></a>               -&gt; ModalsT t m a
<a name="line-158"></a>               -&gt; m a
<a name="line-159"></a>withModalLayer cfg (ModalsT a) = do
<a name="line-160"></a>  rec (result, requests) &lt;- do
<a name="line-161"></a>        runRequesterT a modalDone
<a name="line-162"></a>      modalDone &lt;- modalInner requests cfg
<a name="line-163"></a>  return result
<a name="line-164"></a>
<a name="line-165"></a>modalInner :: forall t m k. (GCompare k, MonadHold t m, MonadFix m, DomBuilder t m)
<a name="line-166"></a>           =&gt; Event t (DMap k (Compose (ModalsT t m) (Event t)))
<a name="line-167"></a>           -&gt; ModalLayerConfig t m
<a name="line-168"></a>           -&gt; m (Event t (DMap k Maybe))
<a name="line-169"></a>modalInner rqs' cfg = do
<a name="line-170"></a>  rec let rqs = fmap toInsertionsDMap rqs'
<a name="line-171"></a>          dones = fmap toDeletionsDMap modalDone
<a name="line-172"></a>      (m0, mpatch) &lt;- traverseDMapWithKeyWithAdjust (\_ v -&gt; Compose &lt;$&gt; modalBody cfg v) DMap.empty (rqs &lt;&gt; dones)
<a name="line-173"></a>      modal &lt;- fmap (merge . mapKeyValuePairsMonotonic wrapArgs) . incrementalToDynamic &lt;$&gt; holdIncremental m0 mpatch
<a name="line-174"></a>      let modalDone = fmap (mapKeyValuePairsMonotonic unwrapArgs) $ switch $ current modal
<a name="line-175"></a>  return modalDone
<a name="line-176"></a> where
<a name="line-177"></a>  wrapArgs (k :=&gt; v) = WrapArg k :=&gt; getCompose v
<a name="line-178"></a>  unwrapArgs :: DSum (WrapArg Maybe k) Identity -&gt; DSum k Maybe
<a name="line-179"></a>  unwrapArgs (WrapArg k :=&gt; Identity v) = k :=&gt; v
<a name="line-180"></a>  toInsertionsDMap :: DMap k v -&gt; PatchDMap k v
<a name="line-181"></a>  toInsertionsDMap = coerce . DMap.map (ComposeMaybe . Just)
<a name="line-182"></a>  toDeletionsDMap :: forall k' v v'. DMap k' v -&gt; PatchDMap k' v'
<a name="line-183"></a>  toDeletionsDMap = coerce . DMap.map (\(_ :: v a) -&gt; ComposeMaybe (Nothing :: Maybe (v' a)))
<a name="line-184"></a>
<a name="line-185"></a>modalBody :: forall t m a. (MonadHold t m, MonadFix m, DomBuilder t m)
<a name="line-186"></a>          =&gt; ModalLayerConfig t m
<a name="line-187"></a>          -&gt; Compose (ModalsT t m) (Event t) a
<a name="line-188"></a>          -&gt; m (Event t (Maybe a))
<a name="line-189"></a>modalBody cfg v = do
<a name="line-190"></a>  (overlay, complete) &lt;- element "div" (_modalLayerConfig_backdropElementConfig cfg) $ do
<a name="line-191"></a>    fmap snd $ element "div" (_modalLayerConfig_bodyElementConfig cfg) $ do
<a name="line-192"></a>      rec (rsps, rqs') &lt;- runRequesterT (unModalsT (getCompose v)) innerDone
<a name="line-193"></a>          innerDone &lt;- modalInner rqs' cfg
<a name="line-194"></a>      return rsps
<a name="line-195"></a>  return $ leftmost
<a name="line-196"></a>    [ Just &lt;$&gt; complete
<a name="line-197"></a>    , Nothing &lt;$ domEvent Click overlay
<a name="line-198"></a>    ]
<a name="line-199"></a>-}</span>
</pre></body>
</html>
